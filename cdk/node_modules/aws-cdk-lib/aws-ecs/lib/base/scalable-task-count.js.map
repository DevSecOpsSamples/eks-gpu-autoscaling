{
  "version": 3,
  "sources": ["scalable-task-count.ts"],
  "sourcesContent": ["import * as appscaling from '../../../aws-applicationautoscaling';\nimport * as cloudwatch from '../../../aws-cloudwatch';\nimport * as elbv2 from '../../../aws-elasticloadbalancingv2';\nimport { Construct } from 'constructs';\n\n/**\n * The properties of a scalable attribute representing task count.\n */\nexport interface ScalableTaskCountProps extends appscaling.BaseScalableAttributeProps {\n\n}\n\n/**\n * The scalable attribute representing task count.\n */\nexport class ScalableTaskCount extends appscaling.BaseScalableAttribute {\n\n  /**\n   * Constructs a new instance of the ScalableTaskCount class.\n   */\n  constructor(scope: Construct, id: string, props: ScalableTaskCountProps) {\n    super(scope, id, props);\n  }\n\n  /**\n   * Scales in or out based on a specified scheduled time.\n   */\n  public scaleOnSchedule(id: string, props: appscaling.ScalingSchedule) {\n    return super.doScaleOnSchedule(id, props);\n  }\n\n  /**\n   * Scales in or out based on a specified metric value.\n   */\n  public scaleOnMetric(id: string, props: appscaling.BasicStepScalingPolicyProps) {\n    return super.doScaleOnMetric(id, props);\n  }\n\n  /**\n   * Scales in or out to achieve a target CPU utilization.\n   */\n  public scaleOnCpuUtilization(id: string, props: CpuUtilizationScalingProps) {\n    return super.doScaleToTrackMetric(id, {\n      predefinedMetric: appscaling.PredefinedMetric.ECS_SERVICE_AVERAGE_CPU_UTILIZATION,\n      policyName: props.policyName,\n      disableScaleIn: props.disableScaleIn,\n      targetValue: props.targetUtilizationPercent,\n      scaleInCooldown: props.scaleInCooldown,\n      scaleOutCooldown: props.scaleOutCooldown,\n    });\n  }\n\n  /**\n   * Scales in or out to achieve a target memory utilization.\n   */\n  public scaleOnMemoryUtilization(id: string, props: MemoryUtilizationScalingProps) {\n    return super.doScaleToTrackMetric(id, {\n      predefinedMetric: appscaling.PredefinedMetric.ECS_SERVICE_AVERAGE_MEMORY_UTILIZATION,\n      targetValue: props.targetUtilizationPercent,\n      policyName: props.policyName,\n      disableScaleIn: props.disableScaleIn,\n      scaleInCooldown: props.scaleInCooldown,\n      scaleOutCooldown: props.scaleOutCooldown,\n    });\n  }\n\n  /**\n   * Scales in or out to achieve a target Application Load Balancer request count per target.\n   */\n  public scaleOnRequestCount(id: string, props: RequestCountScalingProps) {\n    const resourceLabel = props.targetGroup.firstLoadBalancerFullName +\n       '/' + props.targetGroup.targetGroupFullName;\n\n    return super.doScaleToTrackMetric(id, {\n      predefinedMetric: appscaling.PredefinedMetric.ALB_REQUEST_COUNT_PER_TARGET,\n      resourceLabel,\n      targetValue: props.requestsPerTarget,\n      policyName: props.policyName,\n      disableScaleIn: props.disableScaleIn,\n      scaleInCooldown: props.scaleInCooldown,\n      scaleOutCooldown: props.scaleOutCooldown,\n    });\n  }\n\n  /**\n   * Scales in or out to achieve a target on a custom metric.\n   */\n  public scaleToTrackCustomMetric(id: string, props: TrackCustomMetricProps) {\n    return super.doScaleToTrackMetric(id, {\n      customMetric: props.metric,\n      targetValue: props.targetValue,\n      policyName: props.policyName,\n      disableScaleIn: props.disableScaleIn,\n      scaleInCooldown: props.scaleInCooldown,\n      scaleOutCooldown: props.scaleOutCooldown,\n    });\n  }\n}\n\n/**\n * The properties for enabling scaling based on CPU utilization.\n */\nexport interface CpuUtilizationScalingProps extends appscaling.BaseTargetTrackingProps {\n  /**\n   * The target value for CPU utilization across all tasks in the service.\n   */\n  readonly targetUtilizationPercent: number;\n}\n\n/**\n * The properties for enabling scaling based on memory utilization.\n */\nexport interface MemoryUtilizationScalingProps extends appscaling.BaseTargetTrackingProps {\n  /**\n   * The target value for memory utilization across all tasks in the service.\n   */\n  readonly targetUtilizationPercent: number;\n}\n\n/**\n * The properties for enabling scaling based on Application Load Balancer (ALB) request counts.\n */\nexport interface RequestCountScalingProps extends appscaling.BaseTargetTrackingProps {\n  /**\n   * The number of ALB requests per target.\n   */\n  readonly requestsPerTarget: number;\n\n  /**\n   * The ALB target group name.\n   */\n  readonly targetGroup: elbv2.ApplicationTargetGroup;\n}\n\n/**\n * The properties for enabling target tracking scaling based on a custom CloudWatch metric.\n */\nexport interface TrackCustomMetricProps extends appscaling.BaseTargetTrackingProps {\n  /**\n   * The custom CloudWatch metric to track.\n   *\n   * The metric must represent utilization; that is, you will always get the following behavior:\n   *\n   * - metric > targetValue => scale out\n   * - metric < targetValue => scale in\n   */\n  readonly metric: cloudwatch.IMetric;\n\n  /**\n   * The target value for the custom CloudWatch metric.\n   */\n  readonly targetValue: number;\n}\n"],
  "mappings": "2NAAA,WAAA,QAAA,qCAAA,EAeA,MAAa,yBAA0B,YAAW,qBAAqB,CAKrE,YAAY,MAAkB,GAAY,MAA6B,CACrE,MAAM,MAAO,GAAI,KAAK,4EAMjB,gBAAgB,GAAY,MAAiC,8FAC3D,MAAM,kBAAkB,GAAI,KAAK,EAMnC,cAAc,GAAY,MAA6C,0GACrE,MAAM,gBAAgB,GAAI,KAAK,EAMjC,sBAAsB,GAAY,MAAiC,sFACjE,MAAM,qBAAqB,GAAI,CACpC,iBAAkB,WAAW,iBAAiB,oCAC9C,WAAY,MAAM,WAClB,eAAgB,MAAM,eACtB,YAAa,MAAM,yBACnB,gBAAiB,MAAM,gBACvB,iBAAkB,MAAM,iBACzB,EAMI,yBAAyB,GAAY,MAAoC,yFACvE,MAAM,qBAAqB,GAAI,CACpC,iBAAkB,WAAW,iBAAiB,uCAC9C,YAAa,MAAM,yBACnB,WAAY,MAAM,WAClB,eAAgB,MAAM,eACtB,gBAAiB,MAAM,gBACvB,iBAAkB,MAAM,iBACzB,EAMI,oBAAoB,GAAY,MAA+B,6EACpE,KAAM,eAAgB,MAAM,YAAY,0BACrC,IAAM,MAAM,YAAY,oBAE3B,MAAO,OAAM,qBAAqB,GAAI,CACpC,iBAAkB,WAAW,iBAAiB,6BAC9C,cACA,YAAa,MAAM,kBACnB,WAAY,MAAM,WAClB,eAAgB,MAAM,eACtB,gBAAiB,MAAM,gBACvB,iBAAkB,MAAM,iBACzB,EAMI,yBAAyB,GAAY,MAA6B,kFAChE,MAAM,qBAAqB,GAAI,CACpC,aAAc,MAAM,OACpB,YAAa,MAAM,YACnB,WAAY,MAAM,WAClB,eAAgB,MAAM,eACtB,gBAAiB,MAAM,gBACvB,iBAAkB,MAAM,iBACzB,GAhFL,QAAA,kBAAA",
  "names": []
}
