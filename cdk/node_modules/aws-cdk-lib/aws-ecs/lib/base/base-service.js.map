{
  "version": 3,
  "sources": ["base-service.ts"],
  "sourcesContent": ["import * as appscaling from '../../../aws-applicationautoscaling';\nimport * as cloudwatch from '../../../aws-cloudwatch';\nimport * as ec2 from '../../../aws-ec2';\nimport * as elb from '../../../aws-elasticloadbalancing';\nimport * as elbv2 from '../../../aws-elasticloadbalancingv2';\nimport * as iam from '../../../aws-iam';\nimport * as cloudmap from '../../../aws-servicediscovery';\nimport { Annotations, Duration, IResolvable, IResource, Lazy, Resource, Stack, ArnFormat } from '../../../core';\nimport { Construct } from 'constructs';\nimport { LoadBalancerTargetOptions, NetworkMode, TaskDefinition } from '../base/task-definition';\nimport { ICluster, CapacityProviderStrategy, ExecuteCommandLogging, Cluster } from '../cluster';\nimport { ContainerDefinition, Protocol } from '../container-definition';\nimport { CfnService } from '../ecs.generated';\nimport { ScalableTaskCount } from './scalable-task-count';\n\n/**\n * The interface for a service.\n */\nexport interface IService extends IResource {\n  /**\n   * The Amazon Resource Name (ARN) of the service.\n   *\n   * @attribute\n   */\n  readonly serviceArn: string;\n\n  /**\n   * The name of the service.\n   *\n   * @attribute\n   */\n  readonly serviceName: string;\n}\n\n/**\n * The deployment controller to use for the service.\n */\nexport interface DeploymentController {\n  /**\n   * The deployment controller type to use.\n   *\n   * @default DeploymentControllerType.ECS\n   */\n  readonly type?: DeploymentControllerType;\n}\n\n/**\n * The deployment circuit breaker to use for the service\n */\nexport interface DeploymentCircuitBreaker {\n  /**\n   * Whether to enable rollback on deployment failure\n   * @default false\n   */\n  readonly rollback?: boolean;\n\n}\n\nexport interface EcsTarget {\n  /**\n   * The name of the container.\n   */\n  readonly containerName: string;\n\n  /**\n   * The port number of the container. Only applicable when using application/network load balancers.\n   *\n   * @default - Container port of the first added port mapping.\n   */\n  readonly containerPort?: number;\n\n  /**\n   * The protocol used for the port mapping. Only applicable when using application load balancers.\n   *\n   * @default Protocol.TCP\n   */\n  readonly protocol?: Protocol;\n\n  /**\n   * ID for a target group to be created.\n   */\n  readonly newTargetGroupId: string;\n\n  /**\n   * Listener and properties for adding target group to the listener.\n   */\n  readonly listener: ListenerConfig;\n}\n\n/**\n * Interface for ECS load balancer target.\n */\nexport interface IEcsLoadBalancerTarget extends elbv2.IApplicationLoadBalancerTarget, elbv2.INetworkLoadBalancerTarget, elb.ILoadBalancerTarget {\n}\n\n/**\n * The properties for the base Ec2Service or FargateService service.\n */\nexport interface BaseServiceOptions {\n  /**\n   * The name of the cluster that hosts the service.\n   */\n  readonly cluster: ICluster;\n\n  /**\n   * The desired number of instantiations of the task definition to keep running on the service.\n   *\n   * @default - When creating the service, default is 1; when updating the service, default uses\n   * the current task number.\n   */\n  readonly desiredCount?: number;\n\n  /**\n   * The name of the service.\n   *\n   * @default - CloudFormation-generated name.\n   */\n  readonly serviceName?: string;\n\n  /**\n   * The maximum number of tasks, specified as a percentage of the Amazon ECS\n   * service's DesiredCount value, that can run in a service during a\n   * deployment.\n   *\n   * @default - 100 if daemon, otherwise 200\n   */\n  readonly maxHealthyPercent?: number;\n\n  /**\n   * The minimum number of tasks, specified as a percentage of\n   * the Amazon ECS service's DesiredCount value, that must\n   * continue to run and remain healthy during a deployment.\n   *\n   * @default - 0 if daemon, otherwise 50\n   */\n  readonly minHealthyPercent?: number;\n\n  /**\n   * The period of time, in seconds, that the Amazon ECS service scheduler ignores unhealthy\n   * Elastic Load Balancing target health checks after a task has first started.\n   *\n   * @default - defaults to 60 seconds if at least one load balancer is in-use and it is not already set\n   */\n  readonly healthCheckGracePeriod?: Duration;\n\n  /**\n   * The options for configuring an Amazon ECS service to use service discovery.\n   *\n   * @default - AWS Cloud Map service discovery is not enabled.\n   */\n  readonly cloudMapOptions?: CloudMapOptions;\n\n  /**\n   * Specifies whether to propagate the tags from the task definition or the service to the tasks in the service\n   *\n   * Valid values are: PropagatedTagSource.SERVICE, PropagatedTagSource.TASK_DEFINITION or PropagatedTagSource.NONE\n   *\n   * @default PropagatedTagSource.NONE\n   */\n  readonly propagateTags?: PropagatedTagSource;\n\n  /**\n   * Specifies whether to propagate the tags from the task definition or the service to the tasks in the service.\n   * Tags can only be propagated to the tasks within the service during service creation.\n   *\n   * @deprecated Use `propagateTags` instead.\n   * @default PropagatedTagSource.NONE\n   */\n  readonly propagateTaskTagsFrom?: PropagatedTagSource;\n\n  /**\n   * Specifies whether to enable Amazon ECS managed tags for the tasks within the service. For more information, see\n   * [Tagging Your Amazon ECS Resources](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-using-tags.html)\n   *\n   * @default false\n   */\n  readonly enableECSManagedTags?: boolean;\n\n  /**\n   * Specifies which deployment controller to use for the service. For more information, see\n   * [Amazon ECS Deployment Types](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/deployment-types.html)\n   *\n   * @default - Rolling update (ECS)\n   */\n  readonly deploymentController?: DeploymentController;\n\n  /**\n   * Whether to enable the deployment circuit breaker. If this property is defined, circuit breaker will be implicitly\n   * enabled.\n   * @default - disabled\n   */\n  readonly circuitBreaker?: DeploymentCircuitBreaker;\n\n  /**\n   * A list of Capacity Provider strategies used to place a service.\n   *\n   * @default - undefined\n   *\n   */\n  readonly capacityProviderStrategies?: CapacityProviderStrategy[];\n\n  /**\n   * Whether to enable the ability to execute into a container\n   *\n   *  @default - undefined\n   */\n  readonly enableExecuteCommand?: boolean;\n}\n\n/**\n * Complete base service properties that are required to be supplied by the implementation\n * of the BaseService class.\n */\nexport interface BaseServiceProps extends BaseServiceOptions {\n  /**\n   * The launch type on which to run your service.\n   *\n   * LaunchType will be omitted if capacity provider strategies are specified on the service.\n   *\n   * @see - https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ecs-service.html#cfn-ecs-service-capacityproviderstrategy\n   *\n   * Valid values are: LaunchType.ECS or LaunchType.FARGATE or LaunchType.EXTERNAL\n   */\n  readonly launchType: LaunchType;\n}\n\n/**\n * Base class for configuring listener when registering targets.\n */\nexport abstract class ListenerConfig {\n  /**\n   * Create a config for adding target group to ALB listener.\n   */\n  public static applicationListener(listener: elbv2.ApplicationListener, props?: elbv2.AddApplicationTargetsProps): ListenerConfig {\n    return new ApplicationListenerConfig(listener, props);\n  }\n\n  /**\n   * Create a config for adding target group to NLB listener.\n   */\n  public static networkListener(listener: elbv2.NetworkListener, props?: elbv2.AddNetworkTargetsProps): ListenerConfig {\n    return new NetworkListenerConfig(listener, props);\n  }\n\n  /**\n   * Create and attach a target group to listener.\n   */\n  public abstract addTargets(id: string, target: LoadBalancerTargetOptions, service: BaseService): void;\n}\n\n/**\n * Class for configuring application load balancer listener when registering targets.\n */\nclass ApplicationListenerConfig extends ListenerConfig {\n  constructor(private readonly listener: elbv2.ApplicationListener, private readonly props?: elbv2.AddApplicationTargetsProps) {\n    super();\n  }\n\n  /**\n   * Create and attach a target group to listener.\n   */\n  public addTargets(id: string, target: LoadBalancerTargetOptions, service: BaseService) {\n    const props = this.props || {};\n    const protocol = props.protocol;\n    const port = props.port ?? (protocol === elbv2.ApplicationProtocol.HTTPS ? 443 : 80);\n    this.listener.addTargets(id, {\n      ... props,\n      targets: [\n        service.loadBalancerTarget({\n          ...target,\n        }),\n      ],\n      port,\n    });\n  }\n}\n\n/**\n * Class for configuring network load balancer listener when registering targets.\n */\nclass NetworkListenerConfig extends ListenerConfig {\n  constructor(private readonly listener: elbv2.NetworkListener, private readonly props?: elbv2.AddNetworkTargetsProps) {\n    super();\n  }\n\n  /**\n   * Create and attach a target group to listener.\n   */\n  public addTargets(id: string, target: LoadBalancerTargetOptions, service: BaseService) {\n    const port = this.props?.port ?? 80;\n    this.listener.addTargets(id, {\n      ... this.props,\n      targets: [\n        service.loadBalancerTarget({\n          ...target,\n        }),\n      ],\n      port,\n    });\n  }\n}\n\n/**\n * The interface for BaseService.\n */\nexport interface IBaseService extends IService {\n  /**\n   * The cluster that hosts the service.\n   */\n  readonly cluster: ICluster;\n}\n\n/**\n * The base class for Ec2Service and FargateService services.\n */\nexport abstract class BaseService extends Resource\n  implements IBaseService, elbv2.IApplicationLoadBalancerTarget, elbv2.INetworkLoadBalancerTarget, elb.ILoadBalancerTarget {\n  /**\n   * Import an existing ECS/Fargate Service using the service cluster format.\n   * The format is the \"new\" format \"arn:aws:ecs:region:aws_account_id:service/cluster-name/service-name\".\n   * @see https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-account-settings.html#ecs-resource-ids\n   */\n  public static fromServiceArnWithCluster(scope: Construct, id: string, serviceArn: string): IBaseService {\n    const stack = Stack.of(scope);\n    const arn = stack.splitArn(serviceArn, ArnFormat.SLASH_RESOURCE_NAME);\n    const resourceName = arn.resourceName;\n    if (!resourceName) {\n      throw new Error('Missing resource Name from service ARN: ${serviceArn}');\n    }\n    const resourceNameParts = resourceName.split('/');\n    if (resourceNameParts.length !== 2) {\n      throw new Error(`resource name ${resourceName} from service ARN: ${serviceArn} is not using the ARN cluster format`);\n    }\n    const clusterName = resourceNameParts[0];\n    const serviceName = resourceNameParts[1];\n\n    const clusterArn = Stack.of(scope).formatArn({\n      partition: arn.partition,\n      region: arn.region,\n      account: arn.account,\n      service: 'ecs',\n      resource: 'cluster',\n      resourceName: clusterName,\n    });\n\n    const cluster = Cluster.fromClusterArn(scope, `${id}Cluster`, clusterArn);\n\n    class Import extends Resource implements IBaseService {\n      public readonly serviceArn = serviceArn;\n      public readonly serviceName = serviceName;\n      public readonly cluster = cluster;\n    }\n\n    return new Import(scope, id, {\n      environmentFromArn: serviceArn,\n    });\n  }\n\n  /**\n   * The security groups which manage the allowed network traffic for the service.\n   */\n  public readonly connections: ec2.Connections = new ec2.Connections();\n\n  /**\n   * The Amazon Resource Name (ARN) of the service.\n   */\n  public readonly serviceArn: string;\n\n  /**\n   * The name of the service.\n   *\n   * @attribute\n   */\n  public readonly serviceName: string;\n\n  /**\n   * The task definition to use for tasks in the service.\n   */\n  public readonly taskDefinition: TaskDefinition;\n\n  /**\n   * The cluster that hosts the service.\n   */\n  public readonly cluster: ICluster;\n\n  /**\n   * The details of the AWS Cloud Map service.\n   */\n  protected cloudmapService?: cloudmap.Service;\n\n  /**\n   * A list of Elastic Load Balancing load balancer objects, containing the load balancer name, the container\n   * name (as it appears in a container definition), and the container port to access from the load balancer.\n   */\n  protected loadBalancers = new Array<CfnService.LoadBalancerProperty>();\n\n  /**\n   * A list of Elastic Load Balancing load balancer objects, containing the load balancer name, the container\n   * name (as it appears in a container definition), and the container port to access from the load balancer.\n   */\n  protected networkConfiguration?: CfnService.NetworkConfigurationProperty;\n\n  /**\n   * The details of the service discovery registries to assign to this service.\n   * For more information, see Service Discovery.\n   */\n  protected serviceRegistries = new Array<CfnService.ServiceRegistryProperty>();\n\n  private readonly resource: CfnService;\n  private scalableTaskCount?: ScalableTaskCount;\n\n  /**\n   * Constructs a new instance of the BaseService class.\n   */\n  constructor(\n    scope: Construct,\n    id: string,\n    props: BaseServiceProps,\n    additionalProps: any,\n    taskDefinition: TaskDefinition) {\n    super(scope, id, {\n      physicalName: props.serviceName,\n    });\n\n    if (props.propagateTags && props.propagateTaskTagsFrom) {\n      throw new Error('You can only specify either propagateTags or propagateTaskTagsFrom. Alternatively, you can leave both blank');\n    }\n\n    this.taskDefinition = taskDefinition;\n\n    // launchType will set to undefined if using external DeploymentController or capacityProviderStrategies\n    const launchType = props.deploymentController?.type === DeploymentControllerType.EXTERNAL ||\n      props.capacityProviderStrategies !== undefined ?\n      undefined : props.launchType;\n\n    const propagateTagsFromSource = props.propagateTaskTagsFrom ?? props.propagateTags ?? PropagatedTagSource.NONE;\n\n    this.resource = new CfnService(this, 'Service', {\n      desiredCount: props.desiredCount,\n      serviceName: this.physicalName,\n      loadBalancers: Lazy.any({ produce: () => this.loadBalancers }, { omitEmptyArray: true }),\n      deploymentConfiguration: {\n        maximumPercent: props.maxHealthyPercent || 200,\n        minimumHealthyPercent: props.minHealthyPercent === undefined ? 50 : props.minHealthyPercent,\n        deploymentCircuitBreaker: props.circuitBreaker ? {\n          enable: true,\n          rollback: props.circuitBreaker.rollback ?? false,\n        } : undefined,\n      },\n      propagateTags: propagateTagsFromSource === PropagatedTagSource.NONE ? undefined : props.propagateTags,\n      enableEcsManagedTags: props.enableECSManagedTags ?? false,\n      deploymentController: props.circuitBreaker ? {\n        type: DeploymentControllerType.ECS,\n      } : props.deploymentController,\n      launchType: launchType,\n      enableExecuteCommand: props.enableExecuteCommand,\n      capacityProviderStrategy: props.capacityProviderStrategies,\n      healthCheckGracePeriodSeconds: this.evaluateHealthGracePeriod(props.healthCheckGracePeriod),\n      /* role: never specified, supplanted by Service Linked Role */\n      networkConfiguration: Lazy.any({ produce: () => this.networkConfiguration }, { omitEmptyArray: true }),\n      serviceRegistries: Lazy.any({ produce: () => this.serviceRegistries }, { omitEmptyArray: true }),\n      ...additionalProps,\n    });\n\n    if (props.deploymentController?.type === DeploymentControllerType.EXTERNAL) {\n      Annotations.of(this).addWarning('taskDefinition and launchType are blanked out when using external deployment controller.');\n    }\n\n    this.serviceArn = this.getResourceArnAttribute(this.resource.ref, {\n      service: 'ecs',\n      resource: 'service',\n      resourceName: `${props.cluster.clusterName}/${this.physicalName}`,\n    });\n    this.serviceName = this.getResourceNameAttribute(this.resource.attrName);\n\n    this.cluster = props.cluster;\n\n    if (props.cloudMapOptions) {\n      this.enableCloudMap(props.cloudMapOptions);\n    }\n\n    if (props.enableExecuteCommand) {\n      this.enableExecuteCommand();\n\n      const logging = this.cluster.executeCommandConfiguration?.logging ?? ExecuteCommandLogging.DEFAULT;\n\n      if (this.cluster.executeCommandConfiguration?.kmsKey) {\n        this.enableExecuteCommandEncryption(logging);\n      }\n      if (logging !== ExecuteCommandLogging.NONE) {\n        this.executeCommandLogConfiguration();\n      }\n    }\n    this.node.defaultChild = this.resource;\n  }\n\n  /**\n   * The CloudMap service created for this service, if any.\n   */\n  public get cloudMapService(): cloudmap.IService | undefined {\n    return this.cloudmapService;\n  }\n\n  private executeCommandLogConfiguration() {\n    const logConfiguration = this.cluster.executeCommandConfiguration?.logConfiguration;\n    this.taskDefinition.addToTaskRolePolicy(new iam.PolicyStatement({\n      actions: [\n        'logs:DescribeLogGroups',\n      ],\n      resources: ['*'],\n    }));\n\n    const logGroupArn = logConfiguration?.cloudWatchLogGroup ? `arn:${this.stack.partition}:logs:${this.stack.region}:${this.stack.account}:log-group:${logConfiguration.cloudWatchLogGroup.logGroupName}:*` : '*';\n    this.taskDefinition.addToTaskRolePolicy(new iam.PolicyStatement({\n      actions: [\n        'logs:CreateLogStream',\n        'logs:DescribeLogStreams',\n        'logs:PutLogEvents',\n      ],\n      resources: [logGroupArn],\n    }));\n\n    if (logConfiguration?.s3Bucket?.bucketName) {\n      this.taskDefinition.addToTaskRolePolicy(new iam.PolicyStatement({\n        actions: [\n          's3:GetBucketLocation',\n        ],\n        resources: ['*'],\n      }));\n      this.taskDefinition.addToTaskRolePolicy(new iam.PolicyStatement({\n        actions: [\n          's3:PutObject',\n        ],\n        resources: [`arn:${this.stack.partition}:s3:::${logConfiguration.s3Bucket.bucketName}/*`],\n      }));\n      if (logConfiguration.s3EncryptionEnabled) {\n        this.taskDefinition.addToTaskRolePolicy(new iam.PolicyStatement({\n          actions: [\n            's3:GetEncryptionConfiguration',\n          ],\n          resources: [`arn:${this.stack.partition}:s3:::${logConfiguration.s3Bucket.bucketName}`],\n        }));\n      }\n    }\n  }\n\n  private enableExecuteCommandEncryption(logging: ExecuteCommandLogging) {\n    this.taskDefinition.addToTaskRolePolicy(new iam.PolicyStatement({\n      actions: [\n        'kms:Decrypt',\n        'kms:GenerateDataKey',\n      ],\n      resources: [`${this.cluster.executeCommandConfiguration?.kmsKey?.keyArn}`],\n    }));\n\n    this.cluster.executeCommandConfiguration?.kmsKey?.addToResourcePolicy(new iam.PolicyStatement({\n      actions: [\n        'kms:*',\n      ],\n      resources: ['*'],\n      principals: [new iam.ArnPrincipal(`arn:${this.stack.partition}:iam::${this.stack.account}:root`)],\n    }));\n\n    if (logging === ExecuteCommandLogging.DEFAULT || this.cluster.executeCommandConfiguration?.logConfiguration?.cloudWatchEncryptionEnabled) {\n      this.cluster.executeCommandConfiguration?.kmsKey?.addToResourcePolicy(new iam.PolicyStatement({\n        actions: [\n          'kms:Encrypt*',\n          'kms:Decrypt*',\n          'kms:ReEncrypt*',\n          'kms:GenerateDataKey*',\n          'kms:Describe*',\n        ],\n        resources: ['*'],\n        principals: [new iam.ServicePrincipal(`logs.${this.stack.region}.amazonaws.com`)],\n        conditions: {\n          ArnLike: { 'kms:EncryptionContext:aws:logs:arn': `arn:${this.stack.partition}:logs:${this.stack.region}:${this.stack.account}:*` },\n        },\n      }));\n    }\n  }\n\n  /**\n   * This method is called to attach this service to an Application Load Balancer.\n   *\n   * Don't call this function directly. Instead, call `listener.addTargets()`\n   * to add this service to a load balancer.\n   */\n  public attachToApplicationTargetGroup(targetGroup: elbv2.IApplicationTargetGroup): elbv2.LoadBalancerTargetProps {\n    return this.defaultLoadBalancerTarget.attachToApplicationTargetGroup(targetGroup);\n  }\n\n  /**\n   * Registers the service as a target of a Classic Load Balancer (CLB).\n   *\n   * Don't call this. Call `loadBalancer.addTarget()` instead.\n   */\n  public attachToClassicLB(loadBalancer: elb.LoadBalancer): void {\n    return this.defaultLoadBalancerTarget.attachToClassicLB(loadBalancer);\n  }\n\n  /**\n   * Return a load balancing target for a specific container and port.\n   *\n   * Use this function to create a load balancer target if you want to load balance to\n   * another container than the first essential container or the first mapped port on\n   * the container.\n   *\n   * Use the return value of this function where you would normally use a load balancer\n   * target, instead of the `Service` object itself.\n   *\n   * @example\n   *\n   * declare const listener: elbv2.ApplicationListener;\n   * declare const service: ecs.BaseService;\n   * listener.addTargets('ECS', {\n   *   port: 80,\n   *   targets: [service.loadBalancerTarget({\n   *     containerName: 'MyContainer',\n   *     containerPort: 1234,\n   *   })],\n   * });\n   */\n  public loadBalancerTarget(options: LoadBalancerTargetOptions): IEcsLoadBalancerTarget {\n    const self = this;\n    const target = this.taskDefinition._validateTarget(options);\n    const connections = self.connections;\n    return {\n      attachToApplicationTargetGroup(targetGroup: elbv2.ApplicationTargetGroup): elbv2.LoadBalancerTargetProps {\n        targetGroup.registerConnectable(self, self.taskDefinition._portRangeFromPortMapping(target.portMapping));\n        return self.attachToELBv2(targetGroup, target.containerName, target.portMapping.containerPort);\n      },\n      attachToNetworkTargetGroup(targetGroup: elbv2.NetworkTargetGroup): elbv2.LoadBalancerTargetProps {\n        return self.attachToELBv2(targetGroup, target.containerName, target.portMapping.containerPort);\n      },\n      connections,\n      attachToClassicLB(loadBalancer: elb.LoadBalancer): void {\n        return self.attachToELB(loadBalancer, target.containerName, target.portMapping.containerPort);\n      },\n    };\n  }\n\n  /**\n   * Use this function to create all load balancer targets to be registered in this service, add them to\n   * target groups, and attach target groups to listeners accordingly.\n   *\n   * Alternatively, you can use `listener.addTargets()` to create targets and add them to target groups.\n   *\n   * @example\n   *\n   * declare const listener: elbv2.ApplicationListener;\n   * declare const service: ecs.BaseService;\n   * service.registerLoadBalancerTargets(\n   *   {\n   *     containerName: 'web',\n   *     containerPort: 80,\n   *     newTargetGroupId: 'ECS',\n   *     listener: ecs.ListenerConfig.applicationListener(listener, {\n   *       protocol: elbv2.ApplicationProtocol.HTTPS\n   *     }),\n   *   },\n   * )\n   */\n  public registerLoadBalancerTargets(...targets: EcsTarget[]) {\n    for (const target of targets) {\n      target.listener.addTargets(target.newTargetGroupId, {\n        containerName: target.containerName,\n        containerPort: target.containerPort,\n        protocol: target.protocol,\n      }, this);\n    }\n  }\n\n  /**\n   * This method is called to attach this service to a Network Load Balancer.\n   *\n   * Don't call this function directly. Instead, call `listener.addTargets()`\n   * to add this service to a load balancer.\n   */\n  public attachToNetworkTargetGroup(targetGroup: elbv2.INetworkTargetGroup): elbv2.LoadBalancerTargetProps {\n    return this.defaultLoadBalancerTarget.attachToNetworkTargetGroup(targetGroup);\n  }\n\n  /**\n   * An attribute representing the minimum and maximum task count for an AutoScalingGroup.\n   */\n  public autoScaleTaskCount(props: appscaling.EnableScalingProps) {\n    if (this.scalableTaskCount) {\n      throw new Error('AutoScaling of task count already enabled for this service');\n    }\n\n    return this.scalableTaskCount = new ScalableTaskCount(this, 'TaskCount', {\n      serviceNamespace: appscaling.ServiceNamespace.ECS,\n      resourceId: `service/${this.cluster.clusterName}/${this.serviceName}`,\n      dimension: 'ecs:service:DesiredCount',\n      role: this.makeAutoScalingRole(),\n      ...props,\n    });\n  }\n\n  /**\n   * Enable CloudMap service discovery for the service\n   *\n   * @returns The created CloudMap service\n   */\n  public enableCloudMap(options: CloudMapOptions): cloudmap.Service {\n    const sdNamespace = options.cloudMapNamespace ?? this.cluster.defaultCloudMapNamespace;\n    if (sdNamespace === undefined) {\n      throw new Error('Cannot enable service discovery if a Cloudmap Namespace has not been created in the cluster.');\n    }\n\n    // Determine DNS type based on network mode\n    const networkMode = this.taskDefinition.networkMode;\n    if (networkMode === NetworkMode.NONE) {\n      throw new Error('Cannot use a service discovery if NetworkMode is None. Use Bridge, Host or AwsVpc instead.');\n    }\n\n    // Bridge or host network mode requires SRV records\n    let dnsRecordType = options.dnsRecordType;\n\n    if (networkMode === NetworkMode.BRIDGE || networkMode === NetworkMode.HOST) {\n      if (dnsRecordType === undefined) {\n        dnsRecordType = cloudmap.DnsRecordType.SRV;\n      }\n      if (dnsRecordType !== cloudmap.DnsRecordType.SRV) {\n        throw new Error('SRV records must be used when network mode is Bridge or Host.');\n      }\n    }\n\n    // Default DNS record type for AwsVpc network mode is A Records\n    if (networkMode === NetworkMode.AWS_VPC) {\n      if (dnsRecordType === undefined) {\n        dnsRecordType = cloudmap.DnsRecordType.A;\n      }\n    }\n\n    const { containerName, containerPort } = determineContainerNameAndPort({\n      taskDefinition: this.taskDefinition,\n      dnsRecordType: dnsRecordType!,\n      container: options.container,\n      containerPort: options.containerPort,\n    });\n\n    const cloudmapService = new cloudmap.Service(this, 'CloudmapService', {\n      namespace: sdNamespace,\n      name: options.name,\n      dnsRecordType: dnsRecordType!,\n      customHealthCheck: { failureThreshold: options.failureThreshold || 1 },\n      dnsTtl: options.dnsTtl,\n    });\n\n    const serviceArn = cloudmapService.serviceArn;\n\n    // add Cloudmap service to the ECS Service's serviceRegistry\n    this.addServiceRegistry({\n      arn: serviceArn,\n      containerName,\n      containerPort,\n    });\n\n    this.cloudmapService = cloudmapService;\n\n    return cloudmapService;\n  }\n\n  /**\n   * Associates this service with a CloudMap service\n   */\n  public associateCloudMapService(options: AssociateCloudMapServiceOptions): void {\n    const service = options.service;\n\n    const { containerName, containerPort } = determineContainerNameAndPort({\n      taskDefinition: this.taskDefinition,\n      dnsRecordType: service.dnsRecordType,\n      container: options.container,\n      containerPort: options.containerPort,\n    });\n\n    // add Cloudmap service to the ECS Service's serviceRegistry\n    this.addServiceRegistry({\n      arn: service.serviceArn,\n      containerName,\n      containerPort,\n    });\n  }\n\n  /**\n   * This method returns the specified CloudWatch metric name for this service.\n   */\n  public metric(metricName: string, props?: cloudwatch.MetricOptions): cloudwatch.Metric {\n    return new cloudwatch.Metric({\n      namespace: 'AWS/ECS',\n      metricName,\n      dimensionsMap: { ClusterName: this.cluster.clusterName, ServiceName: this.serviceName },\n      ...props,\n    }).attachTo(this);\n  }\n\n  /**\n   * This method returns the CloudWatch metric for this service's memory utilization.\n   *\n   * @default average over 5 minutes\n   */\n  public metricMemoryUtilization(props?: cloudwatch.MetricOptions): cloudwatch.Metric {\n    return this.metric('MemoryUtilization', props);\n  }\n\n  /**\n   * This method returns the CloudWatch metric for this service's CPU utilization.\n   *\n   * @default average over 5 minutes\n   */\n  public metricCpuUtilization(props?: cloudwatch.MetricOptions): cloudwatch.Metric {\n    return this.metric('CPUUtilization', props);\n  }\n\n  /**\n   * This method is called to create a networkConfiguration.\n   * @deprecated use configureAwsVpcNetworkingWithSecurityGroups instead.\n   */\n  // eslint-disable-next-line max-len\n  protected configureAwsVpcNetworking(vpc: ec2.IVpc, assignPublicIp?: boolean, vpcSubnets?: ec2.SubnetSelection, securityGroup?: ec2.ISecurityGroup) {\n    if (vpcSubnets === undefined) {\n      vpcSubnets = assignPublicIp ? { subnetType: ec2.SubnetType.PUBLIC } : {};\n    }\n    if (securityGroup === undefined) {\n      securityGroup = new ec2.SecurityGroup(this, 'SecurityGroup', { vpc });\n    }\n    this.connections.addSecurityGroup(securityGroup);\n\n    this.networkConfiguration = {\n      awsvpcConfiguration: {\n        assignPublicIp: assignPublicIp ? 'ENABLED' : 'DISABLED',\n        subnets: vpc.selectSubnets(vpcSubnets).subnetIds,\n        securityGroups: Lazy.list({ produce: () => [securityGroup!.securityGroupId] }),\n      },\n    };\n  }\n\n  /**\n   * This method is called to create a networkConfiguration.\n   */\n  // eslint-disable-next-line max-len\n  protected configureAwsVpcNetworkingWithSecurityGroups(vpc: ec2.IVpc, assignPublicIp?: boolean, vpcSubnets?: ec2.SubnetSelection, securityGroups?: ec2.ISecurityGroup[]) {\n    if (vpcSubnets === undefined) {\n      vpcSubnets = assignPublicIp ? { subnetType: ec2.SubnetType.PUBLIC } : {};\n    }\n    if (securityGroups === undefined || securityGroups.length === 0) {\n      securityGroups = [new ec2.SecurityGroup(this, 'SecurityGroup', { vpc })];\n    }\n\n    securityGroups.forEach((sg) => { this.connections.addSecurityGroup(sg); }, this);\n\n    this.networkConfiguration = {\n      awsvpcConfiguration: {\n        assignPublicIp: assignPublicIp ? 'ENABLED' : 'DISABLED',\n        subnets: vpc.selectSubnets(vpcSubnets).subnetIds,\n        securityGroups: securityGroups.map((sg) => sg.securityGroupId),\n      },\n    };\n  }\n\n  private renderServiceRegistry(registry: ServiceRegistry): CfnService.ServiceRegistryProperty {\n    return {\n      registryArn: registry.arn,\n      containerName: registry.containerName,\n      containerPort: registry.containerPort,\n    };\n  }\n\n  /**\n   * Shared logic for attaching to an ELB\n   */\n  private attachToELB(loadBalancer: elb.LoadBalancer, containerName: string, containerPort: number): void {\n    if (this.taskDefinition.networkMode === NetworkMode.AWS_VPC) {\n      throw new Error('Cannot use a Classic Load Balancer if NetworkMode is AwsVpc. Use Host or Bridge instead.');\n    }\n    if (this.taskDefinition.networkMode === NetworkMode.NONE) {\n      throw new Error('Cannot use a Classic Load Balancer if NetworkMode is None. Use Host or Bridge instead.');\n    }\n\n    this.loadBalancers.push({\n      loadBalancerName: loadBalancer.loadBalancerName,\n      containerName,\n      containerPort,\n    });\n  }\n\n  /**\n   * Shared logic for attaching to an ELBv2\n   */\n  private attachToELBv2(targetGroup: elbv2.ITargetGroup, containerName: string, containerPort: number): elbv2.LoadBalancerTargetProps {\n    if (this.taskDefinition.networkMode === NetworkMode.NONE) {\n      throw new Error('Cannot use a load balancer if NetworkMode is None. Use Bridge, Host or AwsVpc instead.');\n    }\n\n    this.loadBalancers.push({\n      targetGroupArn: targetGroup.targetGroupArn,\n      containerName,\n      containerPort,\n    });\n\n    // Service creation can only happen after the load balancer has\n    // been associated with our target group(s), so add ordering dependency.\n    this.resource.node.addDependency(targetGroup.loadBalancerAttached);\n\n    const targetType = this.taskDefinition.networkMode === NetworkMode.AWS_VPC ? elbv2.TargetType.IP : elbv2.TargetType.INSTANCE;\n    return { targetType };\n  }\n\n  private get defaultLoadBalancerTarget() {\n    return this.loadBalancerTarget({\n      containerName: this.taskDefinition.defaultContainer!.containerName,\n    });\n  }\n\n  /**\n   * Generate the role that will be used for autoscaling this service\n   */\n  private makeAutoScalingRole(): iam.IRole {\n    // Use a Service Linked Role.\n    return iam.Role.fromRoleArn(this, 'ScalingRole', Stack.of(this).formatArn({\n      region: '',\n      service: 'iam',\n      resource: 'role/aws-service-role/ecs.application-autoscaling.amazonaws.com',\n      resourceName: 'AWSServiceRoleForApplicationAutoScaling_ECSService',\n    }));\n  }\n\n  /**\n   * Associate Service Discovery (Cloud Map) service\n   */\n  private addServiceRegistry(registry: ServiceRegistry) {\n    if (this.serviceRegistries.length >= 1) {\n      throw new Error('Cannot associate with the given service discovery registry. ECS supports at most one service registry per service.');\n    }\n\n    const sr = this.renderServiceRegistry(registry);\n    this.serviceRegistries.push(sr);\n  }\n\n  /**\n   *  Return the default grace period when load balancers are configured and\n   *  healthCheckGracePeriod is not already set\n   */\n  private evaluateHealthGracePeriod(providedHealthCheckGracePeriod?: Duration): IResolvable {\n    return Lazy.any({\n      produce: () => providedHealthCheckGracePeriod?.toSeconds() ?? (this.loadBalancers.length > 0 ? 60 : undefined),\n    });\n  }\n\n  private enableExecuteCommand() {\n    this.taskDefinition.addToTaskRolePolicy(new iam.PolicyStatement({\n      actions: [\n        'ssmmessages:CreateControlChannel',\n        'ssmmessages:CreateDataChannel',\n        'ssmmessages:OpenControlChannel',\n        'ssmmessages:OpenDataChannel',\n      ],\n      resources: ['*'],\n    }));\n  }\n}\n\n/**\n * The options to enabling AWS Cloud Map for an Amazon ECS service.\n */\nexport interface CloudMapOptions {\n  /**\n   * The name of the Cloud Map service to attach to the ECS service.\n   *\n   * @default CloudFormation-generated name\n   */\n  readonly name?: string,\n\n  /**\n   * The service discovery namespace for the Cloud Map service to attach to the ECS service.\n   *\n   * @default - the defaultCloudMapNamespace associated to the cluster\n   */\n  readonly cloudMapNamespace?: cloudmap.INamespace;\n\n  /**\n   * The DNS record type that you want AWS Cloud Map to create. The supported record types are A or SRV.\n   *\n   * @default - DnsRecordType.A if TaskDefinition.networkMode = AWS_VPC, otherwise DnsRecordType.SRV\n   */\n  readonly dnsRecordType?: cloudmap.DnsRecordType.A | cloudmap.DnsRecordType.SRV,\n\n  /**\n   * The amount of time that you want DNS resolvers to cache the settings for this record.\n   *\n   * @default Duration.minutes(1)\n   */\n  readonly dnsTtl?: Duration;\n\n  /**\n   * The number of 30-second intervals that you want Cloud Map to wait after receiving an UpdateInstanceCustomHealthStatus\n   * request before it changes the health status of a service instance.\n   *\n   * NOTE: This is used for HealthCheckCustomConfig\n   */\n  readonly failureThreshold?: number;\n\n  /**\n   * The container to point to for a SRV record.\n   * @default - the task definition's default container\n   */\n  readonly container?: ContainerDefinition;\n\n  /**\n   * The port to point to for a SRV record.\n   * @default - the default port of the task definition's default container\n   */\n  readonly containerPort?: number;\n}\n\n/**\n * The options for using a cloudmap service.\n */\nexport interface AssociateCloudMapServiceOptions {\n  /**\n   * The cloudmap service to register with.\n   */\n  readonly service: cloudmap.IService;\n\n  /**\n   * The container to point to for a SRV record.\n   * @default - the task definition's default container\n   */\n  readonly container?: ContainerDefinition;\n\n  /**\n   * The port to point to for a SRV record.\n   * @default - the default port of the task definition's default container\n   */\n  readonly containerPort?: number;\n}\n\n/**\n * Service Registry for ECS service\n */\ninterface ServiceRegistry {\n  /**\n   * Arn of the Cloud Map Service that will register a Cloud Map Instance for your ECS Service\n   */\n  readonly arn: string;\n\n  /**\n   * The container name value, already specified in the task definition, to be used for your service discovery service.\n   * If the task definition that your service task specifies uses the bridge or host network mode,\n   * you must specify a containerName and containerPort combination from the task definition.\n   * If the task definition that your service task specifies uses the awsvpc network mode and a type SRV DNS record is\n   * used, you must specify either a containerName and containerPort combination or a port value, but not both.\n   */\n  readonly containerName?: string;\n\n  /**\n   * The container port value, already specified in the task definition, to be used for your service discovery service.\n   * If the task definition that your service task specifies uses the bridge or host network mode,\n   * you must specify a containerName and containerPort combination from the task definition.\n   * If the task definition that your service task specifies uses the awsvpc network mode and a type SRV DNS record is\n   * used, you must specify either a containerName and containerPort combination or a port value, but not both.\n   */\n  readonly containerPort?: number;\n}\n\n/**\n * The launch type of an ECS service\n */\nexport enum LaunchType {\n  /**\n   * The service will be launched using the EC2 launch type\n   */\n  EC2 = 'EC2',\n\n  /**\n   * The service will be launched using the FARGATE launch type\n   */\n  FARGATE = 'FARGATE',\n\n  /**\n   * The service will be launched using the EXTERNAL launch type\n   */\n  EXTERNAL = 'EXTERNAL'\n}\n\n/**\n * The deployment controller type to use for the service.\n */\nexport enum DeploymentControllerType {\n  /**\n   * The rolling update (ECS) deployment type involves replacing the current\n   * running version of the container with the latest version.\n   */\n  ECS = 'ECS',\n\n  /**\n   * The blue/green (CODE_DEPLOY) deployment type uses the blue/green deployment model powered by AWS CodeDeploy\n   */\n  CODE_DEPLOY = 'CODE_DEPLOY',\n\n  /**\n   * The external (EXTERNAL) deployment type enables you to use any third-party deployment controller\n   */\n  EXTERNAL = 'EXTERNAL'\n}\n\n/**\n * Propagate tags from either service or task definition\n */\nexport enum PropagatedTagSource {\n  /**\n   * Propagate tags from service\n   */\n  SERVICE = 'SERVICE',\n\n  /**\n   * Propagate tags from task definition\n   */\n  TASK_DEFINITION = 'TASK_DEFINITION',\n\n  /**\n   * Do not propagate\n   */\n  NONE = 'NONE'\n}\n\n/**\n * Options for `determineContainerNameAndPort`\n */\ninterface DetermineContainerNameAndPortOptions {\n  dnsRecordType: cloudmap.DnsRecordType;\n  taskDefinition: TaskDefinition;\n  container?: ContainerDefinition;\n  containerPort?: number;\n}\n\n/**\n * Determine the name of the container and port to target for the service registry.\n */\nfunction determineContainerNameAndPort(options: DetermineContainerNameAndPortOptions) {\n  // If the record type is SRV, then provide the containerName and containerPort to target.\n  // We use the name of the default container and the default port of the default container\n  // unless the user specifies otherwise.\n  if (options.dnsRecordType === cloudmap.DnsRecordType.SRV) {\n    // Ensure the user-provided container is from the right task definition.\n    if (options.container && options.container.taskDefinition != options.taskDefinition) {\n      throw new Error('Cannot add discovery for a container from another task definition');\n    }\n\n    const container = options.container ?? options.taskDefinition.defaultContainer!;\n\n    // Ensure that any port given by the user is mapped.\n    if (options.containerPort && !container.portMappings.some(mapping => mapping.containerPort === options.containerPort)) {\n      throw new Error('Cannot add discovery for a container port that has not been mapped');\n    }\n\n    return {\n      containerName: container.containerName,\n      containerPort: options.containerPort ?? options.taskDefinition.defaultContainer!.containerPort,\n    };\n  }\n\n  return {};\n}\n"],
  "mappings": "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",
  "names": []
}
