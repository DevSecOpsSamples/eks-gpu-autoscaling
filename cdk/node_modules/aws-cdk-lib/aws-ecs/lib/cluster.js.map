{
  "version": 3,
  "sources": ["cluster.ts"],
  "sourcesContent": ["import * as autoscaling from '../../aws-autoscaling';\nimport * as cloudwatch from '../../aws-cloudwatch';\nimport * as ec2 from '../../aws-ec2';\nimport * as iam from '../../aws-iam';\nimport * as kms from '../../aws-kms';\nimport * as logs from '../../aws-logs';\nimport * as s3 from '../../aws-s3';\nimport * as cloudmap from '../../aws-servicediscovery';\nimport { Duration, Lazy, IResource, Resource, Stack, Aspects, IAspect, ArnFormat } from '../../core';\nimport { Construct, IConstruct } from 'constructs';\nimport { BottleRocketImage, EcsOptimizedAmi } from './amis';\nimport { InstanceDrainHook } from './drain-hook/instance-drain-hook';\nimport { ECSMetrics } from './ecs-canned-metrics.generated';\nimport { CfnCluster, CfnCapacityProvider, CfnClusterCapacityProviderAssociations } from './ecs.generated';\n\n/**\n * The properties used to define an ECS cluster.\n */\nexport interface ClusterProps {\n  /**\n   * The name for the cluster.\n   *\n   * @default CloudFormation-generated name\n   */\n  readonly clusterName?: string;\n\n  /**\n   * The VPC where your ECS instances will be running or your ENIs will be deployed\n   *\n   * @default - creates a new VPC with two AZs\n   */\n  readonly vpc?: ec2.IVpc;\n\n  /**\n   * The service discovery namespace created in this cluster\n   *\n   * @default - no service discovery namespace created, you can use `addDefaultCloudMapNamespace` to add a\n   * default service discovery namespace later.\n   */\n  readonly defaultCloudMapNamespace?: CloudMapNamespaceOptions;\n\n  /**\n   * The ec2 capacity to add to the cluster\n   *\n   * @default - no EC2 capacity will be added, you can use `addCapacity` to add capacity later.\n   */\n  readonly capacity?: AddCapacityOptions;\n\n  /**\n   * The capacity providers to add to the cluster\n   *\n   * @default - None. Currently only FARGATE and FARGATE_SPOT are supported.\n   * @deprecated Use {@link ClusterProps.enableFargateCapacityProviders} instead.\n   */\n  readonly capacityProviders?: string[];\n\n  /**\n   * Whether to enable Fargate Capacity Providers\n   *\n   * @default false\n   */\n  readonly enableFargateCapacityProviders?: boolean;\n\n  /**\n   * If true CloudWatch Container Insights will be enabled for the cluster\n   *\n   * @default - Container Insights will be disabled for this cluser.\n   */\n  readonly containerInsights?: boolean;\n\n  /**\n   * The execute command configuration for the cluster\n   *\n   * @default - no configuration will be provided.\n   */\n  readonly executeCommandConfiguration?: ExecuteCommandConfiguration;\n}\n\n/**\n * The machine image type\n */\nexport enum MachineImageType {\n  /**\n   * Amazon ECS-optimized Amazon Linux 2 AMI\n   */\n  AMAZON_LINUX_2,\n  /**\n   * Bottlerocket AMI\n   */\n  BOTTLEROCKET\n}\n\n/**\n * A regional grouping of one or more container instances on which you can run tasks and services.\n */\nexport class Cluster extends Resource implements ICluster {\n  /**\n   * Import an existing cluster to the stack from its attributes.\n   */\n  public static fromClusterAttributes(scope: Construct, id: string, attrs: ClusterAttributes): ICluster {\n    return new ImportedCluster(scope, id, attrs);\n  }\n\n  /**\n   * Import an existing cluster to the stack from the cluster ARN.\n   * This does not provide access to the vpc, hasEc2Capacity, or connections -\n   * use the `fromClusterAttributes` method to access those properties.\n   */\n  public static fromClusterArn(scope: Construct, id: string, clusterArn: string): ICluster {\n    const stack = Stack.of(scope);\n    const arn = stack.splitArn(clusterArn, ArnFormat.SLASH_RESOURCE_NAME);\n    const clusterName = arn.resourceName;\n\n    if (!clusterName) {\n      throw new Error(`Missing required Cluster Name from Cluster ARN: ${clusterArn}`);\n    }\n\n    const errorSuffix = 'is not available for a Cluster imported using fromClusterArn(), please use fromClusterAttributes() instead.';\n\n    class Import extends Resource implements ICluster {\n      public readonly clusterArn = clusterArn;\n      public readonly clusterName = clusterName!;\n      get hasEc2Capacity(): boolean {\n        throw new Error(`hasEc2Capacity ${errorSuffix}`);\n      }\n      get connections(): ec2.Connections {\n        throw new Error(`connections ${errorSuffix}`);\n      }\n      get vpc(): ec2.IVpc {\n        throw new Error(`vpc ${errorSuffix}`);\n      }\n    }\n\n    return new Import(scope, id, {\n      environmentFromArn: clusterArn,\n    });\n  }\n\n  /**\n   * Manage the allowed network connections for the cluster with Security Groups.\n   */\n  public readonly connections: ec2.Connections = new ec2.Connections();\n\n  /**\n   * The VPC associated with the cluster.\n   */\n  public readonly vpc: ec2.IVpc;\n\n  /**\n   * The Amazon Resource Name (ARN) that identifies the cluster.\n   */\n  public readonly clusterArn: string;\n\n  /**\n   * The name of the cluster.\n   */\n  public readonly clusterName: string;\n\n  /**\n   * The names of both ASG and Fargate capacity providers associated with the cluster.\n   */\n  private _capacityProviderNames: string[] = [];\n\n  /**\n   * The AWS Cloud Map namespace to associate with the cluster.\n   */\n  private _defaultCloudMapNamespace?: cloudmap.INamespace;\n\n  /**\n   * Specifies whether the cluster has EC2 instance capacity.\n   */\n  private _hasEc2Capacity: boolean = false;\n\n  /**\n   * The autoscaling group for added Ec2 capacity\n   */\n  private _autoscalingGroup?: autoscaling.IAutoScalingGroup;\n\n  /**\n   * The execute command configuration for the cluster\n   */\n  private _executeCommandConfiguration?: ExecuteCommandConfiguration;\n\n  /**\n   * Constructs a new instance of the Cluster class.\n   */\n  constructor(scope: Construct, id: string, props: ClusterProps = {}) {\n    super(scope, id, {\n      physicalName: props.clusterName,\n    });\n\n    /**\n     * clusterSettings needs to be undefined if containerInsights is not explicitly set in order to allow any\n     * containerInsights settings on the account to apply.  See:\n     * https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ecs-cluster-clustersettings.html#cfn-ecs-cluster-clustersettings-value\n    */\n    let clusterSettings = undefined;\n    if (props.containerInsights !== undefined) {\n      clusterSettings = [{ name: 'containerInsights', value: props.containerInsights ? ContainerInsights.ENABLED : ContainerInsights.DISABLED }];\n    }\n\n    this._capacityProviderNames = props.capacityProviders ?? [];\n    if (props.enableFargateCapacityProviders) {\n      this.enableFargateCapacityProviders();\n    }\n\n    if (props.executeCommandConfiguration) {\n      if ((props.executeCommandConfiguration.logging === ExecuteCommandLogging.OVERRIDE) !==\n        (props.executeCommandConfiguration.logConfiguration !== undefined)) {\n        throw new Error('Execute command log configuration must only be specified when logging is OVERRIDE.');\n      }\n      this._executeCommandConfiguration = props.executeCommandConfiguration;\n    }\n\n    const cluster = new CfnCluster(this, 'Resource', {\n      clusterName: this.physicalName,\n      clusterSettings,\n      configuration: this._executeCommandConfiguration && this.renderExecuteCommandConfiguration(),\n    });\n\n    this.clusterArn = this.getResourceArnAttribute(cluster.attrArn, {\n      service: 'ecs',\n      resource: 'cluster',\n      resourceName: this.physicalName,\n    });\n    this.clusterName = this.getResourceNameAttribute(cluster.ref);\n\n    this.vpc = props.vpc || new ec2.Vpc(this, 'Vpc', { maxAzs: 2 });\n\n\n    this._defaultCloudMapNamespace = props.defaultCloudMapNamespace !== undefined\n      ? this.addDefaultCloudMapNamespace(props.defaultCloudMapNamespace)\n      : undefined;\n\n    this._autoscalingGroup = props.capacity !== undefined\n      ? this.addCapacity('DefaultAutoScalingGroup', props.capacity)\n      : undefined;\n\n    // Only create cluster capacity provider associations if there are any EC2\n    // capacity providers. Ordinarily we'd just add the construct to the tree\n    // since it's harmless, but we'd prefer not to add unexpected new\n    // resources to the stack which could surprise users working with\n    // brown-field CDK apps and stacks.\n    Aspects.of(this).add(new MaybeCreateCapacityProviderAssociations(this, id, this._capacityProviderNames));\n  }\n\n  /**\n   * Enable the Fargate capacity providers for this cluster.\n   */\n  public enableFargateCapacityProviders() {\n    for (const provider of ['FARGATE', 'FARGATE_SPOT']) {\n      if (!this._capacityProviderNames.includes(provider)) {\n        this._capacityProviderNames.push(provider);\n      }\n    }\n  }\n\n  private renderExecuteCommandConfiguration() : CfnCluster.ClusterConfigurationProperty {\n    return {\n      executeCommandConfiguration: {\n        kmsKeyId: this._executeCommandConfiguration?.kmsKey?.keyArn,\n        logConfiguration: this._executeCommandConfiguration?.logConfiguration && this.renderExecuteCommandLogConfiguration(),\n        logging: this._executeCommandConfiguration?.logging,\n      },\n    };\n  }\n\n  private renderExecuteCommandLogConfiguration(): CfnCluster.ExecuteCommandLogConfigurationProperty {\n    const logConfiguration = this._executeCommandConfiguration?.logConfiguration;\n    if (logConfiguration?.s3EncryptionEnabled && !logConfiguration?.s3Bucket) {\n      throw new Error('You must specify an S3 bucket name in the execute command log configuration to enable S3 encryption.');\n    }\n    if (logConfiguration?.cloudWatchEncryptionEnabled && !logConfiguration?.cloudWatchLogGroup) {\n      throw new Error('You must specify a CloudWatch log group in the execute command log configuration to enable CloudWatch encryption.');\n    }\n    return {\n      cloudWatchEncryptionEnabled: logConfiguration?.cloudWatchEncryptionEnabled,\n      cloudWatchLogGroupName: logConfiguration?.cloudWatchLogGroup?.logGroupName,\n      s3BucketName: logConfiguration?.s3Bucket?.bucketName,\n      s3EncryptionEnabled: logConfiguration?.s3EncryptionEnabled,\n      s3KeyPrefix: logConfiguration?.s3KeyPrefix,\n    };\n  }\n\n  /**\n   * Add an AWS Cloud Map DNS namespace for this cluster.\n   * NOTE: HttpNamespaces are not supported, as ECS always requires a DNSConfig when registering an instance to a Cloud\n   * Map service.\n   */\n  public addDefaultCloudMapNamespace(options: CloudMapNamespaceOptions): cloudmap.INamespace {\n    if (this._defaultCloudMapNamespace !== undefined) {\n      throw new Error('Can only add default namespace once.');\n    }\n\n    const namespaceType = options.type !== undefined\n      ? options.type\n      : cloudmap.NamespaceType.DNS_PRIVATE;\n\n    const sdNamespace = namespaceType === cloudmap.NamespaceType.DNS_PRIVATE ?\n      new cloudmap.PrivateDnsNamespace(this, 'DefaultServiceDiscoveryNamespace', {\n        name: options.name,\n        vpc: this.vpc,\n      }) :\n      new cloudmap.PublicDnsNamespace(this, 'DefaultServiceDiscoveryNamespace', {\n        name: options.name,\n      });\n\n    this._defaultCloudMapNamespace = sdNamespace;\n\n    return sdNamespace;\n  }\n\n  /**\n   * Getter for namespace added to cluster\n   */\n  public get defaultCloudMapNamespace(): cloudmap.INamespace | undefined {\n    return this._defaultCloudMapNamespace;\n  }\n\n  /**\n   * It is highly recommended to use {@link Cluster.addAsgCapacityProvider} instead of this method.\n   *\n   * This method adds compute capacity to a cluster by creating an AutoScalingGroup with the specified options.\n   *\n   * Returns the AutoScalingGroup so you can add autoscaling settings to it.\n   */\n  public addCapacity(id: string, options: AddCapacityOptions): autoscaling.AutoScalingGroup {\n    // Do 2-way defaulting here: if the machineImageType is BOTTLEROCKET, pick the right AMI.\n    // Otherwise, determine the machineImageType from the given AMI.\n    const machineImage = options.machineImage ??\n      (options.machineImageType === MachineImageType.BOTTLEROCKET ? new BottleRocketImage({\n        architecture: options.instanceType.architecture,\n      }) : new EcsOptimizedAmi());\n\n    const machineImageType = options.machineImageType ??\n      (isBottleRocketImage(machineImage) ? MachineImageType.BOTTLEROCKET : MachineImageType.AMAZON_LINUX_2);\n\n    const autoScalingGroup = new autoscaling.AutoScalingGroup(this, id, {\n      vpc: this.vpc,\n      machineImage,\n      updateType: options.updateType || autoscaling.UpdateType.REPLACING_UPDATE,\n      ...options,\n    });\n\n    this.addAutoScalingGroup(autoScalingGroup, {\n      machineImageType: machineImageType,\n      ...options,\n    });\n\n    return autoScalingGroup;\n  }\n\n  /**\n   * This method adds an Auto Scaling Group Capacity Provider to a cluster.\n   *\n   * @param provider the capacity provider to add to this cluster.\n   */\n  public addAsgCapacityProvider(provider: AsgCapacityProvider, options: AddAutoScalingGroupCapacityOptions= {}) {\n    // Don't add the same capacity provider more than once.\n    if (this._capacityProviderNames.includes(provider.capacityProviderName)) {\n      return;\n    }\n    this._hasEc2Capacity = true;\n    this.configureAutoScalingGroup(provider.autoScalingGroup, {\n      ...options,\n      machineImageType: provider.machineImageType,\n      // Don't enable the instance-draining lifecycle hook if managed termination protection is enabled\n      taskDrainTime: provider.enableManagedTerminationProtection ? Duration.seconds(0) : options.taskDrainTime,\n    });\n\n    this._capacityProviderNames.push(provider.capacityProviderName);\n  }\n\n  /**\n   * This method adds compute capacity to a cluster using the specified AutoScalingGroup.\n   *\n   * @deprecated Use {@link Cluster.addAsgCapacityProvider} instead.\n   * @param autoScalingGroup the ASG to add to this cluster.\n   * [disable-awslint:ref-via-interface] is needed in order to install the ECS\n   * agent by updating the ASGs user data.\n   */\n  public addAutoScalingGroup(autoScalingGroup: autoscaling.AutoScalingGroup, options: AddAutoScalingGroupCapacityOptions = {}) {\n    this._hasEc2Capacity = true;\n    this.connections.connections.addSecurityGroup(...autoScalingGroup.connections.securityGroups);\n    this.configureAutoScalingGroup(autoScalingGroup, options);\n  }\n\n  private configureAutoScalingGroup(autoScalingGroup: autoscaling.AutoScalingGroup, options: AddAutoScalingGroupCapacityOptions = {}) {\n    if (autoScalingGroup.osType === ec2.OperatingSystemType.WINDOWS) {\n      this.configureWindowsAutoScalingGroup(autoScalingGroup, options);\n    } else {\n      // Tie instances to cluster\n      switch (options.machineImageType) {\n        // Bottlerocket AMI\n        case MachineImageType.BOTTLEROCKET: {\n          autoScalingGroup.addUserData(\n            // Connect to the cluster\n            // Source: https://github.com/bottlerocket-os/bottlerocket/blob/develop/QUICKSTART-ECS.md#connecting-to-your-cluster\n            '[settings.ecs]',\n            `cluster = \"${this.clusterName}\"`,\n          );\n          // Enabling SSM\n          // Source: https://github.com/bottlerocket-os/bottlerocket/blob/develop/QUICKSTART-ECS.md#enabling-ssm\n          autoScalingGroup.role.addManagedPolicy(iam.ManagedPolicy.fromAwsManagedPolicyName('AmazonSSMManagedInstanceCore'));\n          // required managed policy\n          autoScalingGroup.role.addManagedPolicy(iam.ManagedPolicy.fromAwsManagedPolicyName('service-role/AmazonEC2ContainerServiceforEC2Role'));\n          break;\n        }\n        default:\n          // Amazon ECS-optimized AMI for Amazon Linux 2\n          autoScalingGroup.addUserData(`echo ECS_CLUSTER=${this.clusterName} >> /etc/ecs/ecs.config`);\n          if (!options.canContainersAccessInstanceRole) {\n            // Deny containers access to instance metadata service\n            // Source: https://docs.aws.amazon.com/AmazonECS/latest/developerguide/instance_IAM_role.html\n            autoScalingGroup.addUserData('sudo iptables --insert FORWARD 1 --in-interface docker+ --destination 169.254.169.254/32 --jump DROP');\n            autoScalingGroup.addUserData('sudo service iptables save');\n            // The following is only for AwsVpc networking mode, but doesn't hurt for the other modes.\n            autoScalingGroup.addUserData('echo ECS_AWSVPC_BLOCK_IMDS=true >> /etc/ecs/ecs.config');\n          }\n\n          if (autoScalingGroup.spotPrice && options.spotInstanceDraining) {\n            autoScalingGroup.addUserData('echo ECS_ENABLE_SPOT_INSTANCE_DRAINING=true >> /etc/ecs/ecs.config');\n          }\n      }\n    }\n\n    // ECS instances must be able to do these things\n    // Source: https://docs.aws.amazon.com/AmazonECS/latest/developerguide/instance_IAM_role.html\n    // But, scoped down to minimal permissions required.\n    //  Notes:\n    //   - 'ecs:CreateCluster' removed. The cluster already exists.\n    autoScalingGroup.addToRolePolicy(new iam.PolicyStatement({\n      actions: [\n        'ecs:DeregisterContainerInstance',\n        'ecs:RegisterContainerInstance',\n        'ecs:Submit*',\n      ],\n      resources: [\n        this.clusterArn,\n      ],\n    }));\n    autoScalingGroup.addToRolePolicy(new iam.PolicyStatement({\n      actions: [\n        // These act on a cluster instance, and the instance doesn't exist until the service starts.\n        // Thus, scope to the cluster using a condition.\n        // See: https://docs.aws.amazon.com/IAM/latest/UserGuide/list_amazonelasticcontainerservice.html\n        'ecs:Poll',\n        'ecs:StartTelemetrySession',\n      ],\n      resources: ['*'],\n      conditions: {\n        ArnEquals: { 'ecs:cluster': this.clusterArn },\n      },\n    }));\n    autoScalingGroup.addToRolePolicy(new iam.PolicyStatement({\n      actions: [\n        // These do not support resource constraints, and must be resource '*'\n        'ecs:DiscoverPollEndpoint',\n        'ecr:GetAuthorizationToken',\n        // Preserved for backwards compatibility.\n        // Users are able to enable cloudwatch agent using CDK. Existing\n        // customers might be installing CW agent as part of user-data so if we\n        // remove these permissions we will break that customer use cases.\n        'logs:CreateLogStream',\n        'logs:PutLogEvents',\n      ],\n      resources: ['*'],\n    }));\n\n    // 0 disables, otherwise forward to underlying implementation which picks the sane default\n    if (!options.taskDrainTime || options.taskDrainTime.toSeconds() !== 0) {\n      new InstanceDrainHook(autoScalingGroup, 'DrainECSHook', {\n        autoScalingGroup,\n        cluster: this,\n        drainTime: options.taskDrainTime,\n        topicEncryptionKey: options.topicEncryptionKey,\n      });\n    }\n  }\n\n  /**\n   * This method enables the Fargate or Fargate Spot capacity providers on the cluster.\n   *\n   * @param provider the capacity provider to add to this cluster.\n   * @deprecated Use {@link enableFargateCapacityProviders} instead.\n   * @see {@link addAsgCapacityProvider} to add an Auto Scaling Group capacity provider to the cluster.\n   */\n  public addCapacityProvider(provider: string) {\n    if (!(provider === 'FARGATE' || provider === 'FARGATE_SPOT')) {\n      throw new Error('CapacityProvider not supported');\n    }\n\n    if (!this._capacityProviderNames.includes(provider)) {\n      this._capacityProviderNames.push(provider);\n    }\n  }\n\n  private configureWindowsAutoScalingGroup(autoScalingGroup: autoscaling.AutoScalingGroup, options: AddAutoScalingGroupCapacityOptions = {}) {\n    // clear the cache of the agent\n    autoScalingGroup.addUserData('Remove-Item -Recurse C:\\\\ProgramData\\\\Amazon\\\\ECS\\\\Cache');\n\n    // pull the latest ECS Tools\n    autoScalingGroup.addUserData('Import-Module ECSTools');\n\n    // set the cluster name environment variable\n    autoScalingGroup.addUserData(`[Environment]::SetEnvironmentVariable(\"ECS_CLUSTER\", \"${this.clusterName}\", \"Machine\")`);\n    autoScalingGroup.addUserData('[Environment]::SetEnvironmentVariable(\"ECS_ENABLE_AWSLOGS_EXECUTIONROLE_OVERRIDE\", \"true\", \"Machine\")');\n    // tslint:disable-next-line: max-line-length\n    autoScalingGroup.addUserData('[Environment]::SetEnvironmentVariable(\"ECS_AVAILABLE_LOGGING_DRIVERS\", \\'[\"json-file\",\"awslogs\"]\\', \"Machine\")');\n\n    // enable instance draining\n    if (autoScalingGroup.spotPrice && options.spotInstanceDraining) {\n      autoScalingGroup.addUserData('[Environment]::SetEnvironmentVariable(\"ECS_ENABLE_SPOT_INSTANCE_DRAINING\", \"true\", \"Machine\")');\n    }\n\n    // enable task iam role\n    if (!options.canContainersAccessInstanceRole) {\n      autoScalingGroup.addUserData('[Environment]::SetEnvironmentVariable(\"ECS_ENABLE_TASK_IAM_ROLE\", \"true\", \"Machine\")');\n      autoScalingGroup.addUserData(`Initialize-ECSAgent -Cluster '${this.clusterName}' -EnableTaskIAMRole`);\n    } else {\n      autoScalingGroup.addUserData(`Initialize-ECSAgent -Cluster '${this.clusterName}'`);\n    }\n  }\n\n  /**\n   * Getter for autoscaling group added to cluster\n   */\n  public get autoscalingGroup(): autoscaling.IAutoScalingGroup | undefined {\n    return this._autoscalingGroup;\n  }\n\n  /**\n   * Whether the cluster has EC2 capacity associated with it\n   */\n  public get hasEc2Capacity(): boolean {\n    return this._hasEc2Capacity;\n  }\n\n  /**\n   * Getter for execute command configuration associated with the cluster.\n   */\n  public get executeCommandConfiguration(): ExecuteCommandConfiguration | undefined {\n    return this._executeCommandConfiguration;\n  }\n\n  /**\n   * This method returns the CloudWatch metric for this clusters CPU reservation.\n   *\n   * @default average over 5 minutes\n   */\n  public metricCpuReservation(props?: cloudwatch.MetricOptions): cloudwatch.Metric {\n    return this.cannedMetric(ECSMetrics.cpuReservationAverage, props);\n  }\n\n  /**\n   * This method returns the CloudWatch metric for this clusters CPU utilization.\n   *\n   * @default average over 5 minutes\n   */\n  public metricCpuUtilization(props?: cloudwatch.MetricOptions): cloudwatch.Metric {\n    return this.cannedMetric(ECSMetrics.cpuUtilizationAverage, props);\n  }\n\n  /**\n   * This method returns the CloudWatch metric for this clusters memory reservation.\n   *\n   * @default average over 5 minutes\n   */\n  public metricMemoryReservation(props?: cloudwatch.MetricOptions): cloudwatch.Metric {\n    return this.cannedMetric(ECSMetrics.memoryReservationAverage, props);\n  }\n\n  /**\n   * This method returns the CloudWatch metric for this clusters memory utilization.\n   *\n   * @default average over 5 minutes\n   */\n  public metricMemoryUtilization(props?: cloudwatch.MetricOptions): cloudwatch.Metric {\n    return this.cannedMetric(ECSMetrics.memoryUtilizationAverage, props);\n  }\n\n  /**\n   * This method returns the specifed CloudWatch metric for this cluster.\n   */\n  public metric(metricName: string, props?: cloudwatch.MetricOptions): cloudwatch.Metric {\n    return new cloudwatch.Metric({\n      namespace: 'AWS/ECS',\n      metricName,\n      dimensionsMap: { ClusterName: this.clusterName },\n      ...props,\n    }).attachTo(this);\n  }\n\n  private cannedMetric(\n    fn: (dims: { ClusterName: string }) => cloudwatch.MetricProps,\n    props?: cloudwatch.MetricOptions): cloudwatch.Metric {\n    return new cloudwatch.Metric({\n      ...fn({ ClusterName: this.clusterName }),\n      ...props,\n    }).attachTo(this);\n  }\n}\n\n/**\n * A regional grouping of one or more container instances on which you can run tasks and services.\n */\nexport interface ICluster extends IResource {\n  /**\n   * The name of the cluster.\n   * @attribute\n   */\n  readonly clusterName: string;\n\n  /**\n   * The Amazon Resource Name (ARN) that identifies the cluster.\n   * @attribute\n   */\n  readonly clusterArn: string;\n\n  /**\n   * The VPC associated with the cluster.\n   */\n  readonly vpc: ec2.IVpc;\n\n  /**\n   * Manage the allowed network connections for the cluster with Security Groups.\n   */\n  readonly connections: ec2.Connections;\n\n  /**\n   * Specifies whether the cluster has EC2 instance capacity.\n   */\n  readonly hasEc2Capacity: boolean;\n\n  /**\n   * The AWS Cloud Map namespace to associate with the cluster.\n   */\n  readonly defaultCloudMapNamespace?: cloudmap.INamespace;\n\n  /**\n   * The autoscaling group added to the cluster if capacity is associated to the cluster\n   */\n  readonly autoscalingGroup?: autoscaling.IAutoScalingGroup;\n\n  /**\n   * The execute command configuration for the cluster\n   */\n  readonly executeCommandConfiguration?: ExecuteCommandConfiguration;\n}\n\n/**\n * The properties to import from the ECS cluster.\n */\nexport interface ClusterAttributes {\n  /**\n   * The name of the cluster.\n   */\n  readonly clusterName: string;\n\n  /**\n   * The Amazon Resource Name (ARN) that identifies the cluster.\n   *\n   * @default Derived from clusterName\n   */\n  readonly clusterArn?: string;\n\n  /**\n   * The VPC associated with the cluster.\n   */\n  readonly vpc: ec2.IVpc;\n\n  /**\n   * The security groups associated with the container instances registered to the cluster.\n   */\n  readonly securityGroups: ec2.ISecurityGroup[];\n\n  /**\n   * Specifies whether the cluster has EC2 instance capacity.\n   *\n   * @default true\n   */\n  readonly hasEc2Capacity?: boolean;\n\n  /**\n   * The AWS Cloud Map namespace to associate with the cluster.\n   *\n   * @default - No default namespace\n   */\n  readonly defaultCloudMapNamespace?: cloudmap.INamespace;\n\n  /**\n   * Autoscaling group added to the cluster if capacity is added\n   *\n   * @default - No default autoscaling group\n   */\n  readonly autoscalingGroup?: autoscaling.IAutoScalingGroup;\n\n  /**\n   * The execute command configuration for the cluster\n   *\n   * @default - none.\n   */\n  readonly executeCommandConfiguration?: ExecuteCommandConfiguration;\n}\n\n/**\n * An Cluster that has been imported\n */\nclass ImportedCluster extends Resource implements ICluster {\n  /**\n   * Name of the cluster\n   */\n  public readonly clusterName: string;\n\n  /**\n   * ARN of the cluster\n   */\n  public readonly clusterArn: string;\n\n  /**\n   * VPC that the cluster instances are running in\n   */\n  public readonly vpc: ec2.IVpc;\n\n  /**\n   * Security group of the cluster instances\n   */\n  public readonly connections = new ec2.Connections();\n\n  /**\n   * Whether the cluster has EC2 capacity\n   */\n  public readonly hasEc2Capacity: boolean;\n\n  /**\n   * Cloudmap namespace created in the cluster\n   */\n  private _defaultCloudMapNamespace?: cloudmap.INamespace;\n\n  /**\n   * The execute command configuration for the cluster\n   */\n  private _executeCommandConfiguration?: ExecuteCommandConfiguration;\n\n  /**\n   * Constructs a new instance of the ImportedCluster class.\n   */\n  constructor(scope: Construct, id: string, props: ClusterAttributes) {\n    super(scope, id);\n    this.clusterName = props.clusterName;\n    this.vpc = props.vpc;\n    this.hasEc2Capacity = props.hasEc2Capacity !== false;\n    this._defaultCloudMapNamespace = props.defaultCloudMapNamespace;\n    this._executeCommandConfiguration = props.executeCommandConfiguration;\n\n    this.clusterArn = props.clusterArn ?? Stack.of(this).formatArn({\n      service: 'ecs',\n      resource: 'cluster',\n      resourceName: props.clusterName,\n    });\n\n    this.connections = new ec2.Connections({\n      securityGroups: props.securityGroups,\n    });\n  }\n\n  public get defaultCloudMapNamespace(): cloudmap.INamespace | undefined {\n    return this._defaultCloudMapNamespace;\n  }\n\n  public get executeCommandConfiguration(): ExecuteCommandConfiguration | undefined {\n    return this._executeCommandConfiguration;\n  }\n}\n\n/**\n * The properties for adding an AutoScalingGroup.\n */\nexport interface AddAutoScalingGroupCapacityOptions {\n  /**\n   * Specifies whether the containers can access the container instance role.\n   *\n   * @default false\n   */\n  readonly canContainersAccessInstanceRole?: boolean;\n\n  /**\n   * The time period to wait before force terminating an instance that is draining.\n   *\n   * This creates a Lambda function that is used by a lifecycle hook for the\n   * AutoScalingGroup that will delay instance termination until all ECS tasks\n   * have drained from the instance. Set to 0 to disable task draining.\n   *\n   * Set to 0 to disable task draining.\n   *\n   * @deprecated The lifecycle draining hook is not configured if using the EC2 Capacity Provider. Enable managed termination protection instead.\n   * @default Duration.minutes(5)\n   */\n  readonly taskDrainTime?: Duration;\n\n  /**\n   * Specify whether to enable Automated Draining for Spot Instances running Amazon ECS Services.\n   * For more information, see [Using Spot Instances](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/container-instance-spot.html).\n   *\n   * @default false\n   */\n  readonly spotInstanceDraining?: boolean\n\n  /**\n   * If {@link AddAutoScalingGroupCapacityOptions.taskDrainTime} is non-zero, then the ECS cluster creates an\n   * SNS Topic to as part of a system to drain instances of tasks when the instance is being shut down.\n   * If this property is provided, then this key will be used to encrypt the contents of that SNS Topic.\n   * See [SNS Data Encryption](https://docs.aws.amazon.com/sns/latest/dg/sns-data-encryption.html) for more information.\n   *\n   * @default The SNS Topic will not be encrypted.\n   */\n  readonly topicEncryptionKey?: kms.IKey;\n\n  /**\n   * What type of machine image this is\n   *\n   * Depending on the setting, different UserData will automatically be added\n   * to the `AutoScalingGroup` to configure it properly for use with ECS.\n   *\n   * If you create an `AutoScalingGroup` yourself and are adding it via\n   * `addAutoScalingGroup()`, you must specify this value. If you are adding an\n   * `autoScalingGroup` via `addCapacity`, this value will be determined\n   * from the `machineImage` you pass.\n   *\n   * @default - Automatically determined from `machineImage`, if available, otherwise `MachineImageType.AMAZON_LINUX_2`.\n   */\n  readonly machineImageType?: MachineImageType;\n}\n\n/**\n * The properties for adding instance capacity to an AutoScalingGroup.\n */\nexport interface AddCapacityOptions extends AddAutoScalingGroupCapacityOptions, autoscaling.CommonAutoScalingGroupProps {\n  /**\n   * The EC2 instance type to use when launching instances into the AutoScalingGroup.\n   */\n  readonly instanceType: ec2.InstanceType;\n\n  /**\n   * The ECS-optimized AMI variant to use\n   *\n   * The default is to use an ECS-optimized AMI of Amazon Linux 2 which is\n   * automatically updated to the latest version on every deployment. This will\n   * replace the instances in the AutoScalingGroup. Make sure you have not disabled\n   * task draining, to avoid downtime when the AMI updates.\n   *\n   * To use an image that does not update on every deployment, pass:\n   *\n   * ```ts\n   * const machineImage = ecs.EcsOptimizedImage.amazonLinux2(ecs.AmiHardwareType.STANDARD, {\n   *   cachedInContext: true,\n   * });\n   * ```\n   *\n   * For more information, see [Amazon ECS-optimized\n   * AMIs](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-optimized_AMI.html).\n   *\n   * You must define either `machineImage` or `machineImageType`, not both.\n   *\n   * @default - Automatically updated, ECS-optimized Amazon Linux 2\n   */\n  readonly machineImage?: ec2.IMachineImage;\n}\n\n/**\n * The options for creating an AWS Cloud Map namespace.\n */\nexport interface CloudMapNamespaceOptions {\n  /**\n   * The name of the namespace, such as example.com.\n   */\n  readonly name: string;\n\n  /**\n   * The type of CloudMap Namespace to create.\n   *\n   * @default PrivateDns\n   */\n  readonly type?: cloudmap.NamespaceType;\n\n  /**\n   * The VPC to associate the namespace with. This property is required for private DNS namespaces.\n   *\n   * @default VPC of the cluster for Private DNS Namespace, otherwise none\n   */\n  readonly vpc?: ec2.IVpc;\n}\n\nenum ContainerInsights {\n  /**\n   * Enable CloudWatch Container Insights for the cluster\n   */\n\n  ENABLED = 'enabled',\n\n  /**\n   * Disable CloudWatch Container Insights for the cluster\n   */\n  DISABLED = 'disabled',\n}\n\n/**\n * A Capacity Provider strategy to use for the service.\n *\n * NOTE: defaultCapacityProviderStrategy on cluster not currently supported.\n */\nexport interface CapacityProviderStrategy {\n  /**\n   * The name of the capacity provider.\n   */\n  readonly capacityProvider: string;\n\n  /**\n   * The base value designates how many tasks, at a minimum, to run on the specified capacity provider. Only one\n   * capacity provider in a capacity provider strategy can have a base defined. If no value is specified, the default\n   * value of 0 is used.\n   *\n   * @default - none\n   */\n  readonly base?: number;\n\n  /**\n   * The weight value designates the relative percentage of the total number of tasks launched that should use the\n   * specified\ncapacity provider. The weight value is taken into consideration after the base value, if defined, is satisfied.\n   *\n   * @default - 0\n   */\n  readonly weight?: number;\n}\n\n/**\n * The details of the execute command configuration. For more information, see\n * [ExecuteCommandConfiguration] https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ecs-cluster-executecommandconfiguration.html\n */\nexport interface ExecuteCommandConfiguration {\n  /**\n   * The AWS Key Management Service key ID to encrypt the data between the local client and the container.\n   *\n   * @default - none\n   */\n  readonly kmsKey?: kms.IKey,\n\n  /**\n   * The log configuration for the results of the execute command actions. The logs can be sent to CloudWatch Logs or an Amazon S3 bucket.\n   *\n   * @default - none\n   */\n  readonly logConfiguration?: ExecuteCommandLogConfiguration,\n\n  /**\n   * The log settings to use for logging the execute command session.\n   *\n   * @default - none\n   */\n  readonly logging?: ExecuteCommandLogging,\n}\n\n/**\n * The log settings to use to for logging the execute command session. For more information, see\n * [Logging] https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ecs-cluster-executecommandconfiguration.html#cfn-ecs-cluster-executecommandconfiguration-logging\n */\nexport enum ExecuteCommandLogging {\n  /**\n   * The execute command session is not logged.\n   */\n  NONE = 'NONE',\n\n  /**\n   * The awslogs configuration in the task definition is used. If no logging parameter is specified, it defaults to this value. If no awslogs log driver is configured in the task definition, the output won't be logged.\n   */\n  DEFAULT = 'DEFAULT',\n\n  /**\n   * Specify the logging details as a part of logConfiguration.\n   */\n  OVERRIDE = 'OVERRIDE',\n}\n\n/**\n * The log configuration for the results of the execute command actions. The logs can be sent to CloudWatch Logs and/ or an Amazon S3 bucket.\n * For more information, see [ExecuteCommandLogConfiguration] https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ecs-cluster-executecommandlogconfiguration.html\n */\nexport interface ExecuteCommandLogConfiguration {\n  /**\n   * Whether or not to enable encryption on the CloudWatch logs.\n   *\n   * @default - encryption will be disabled.\n   */\n  readonly cloudWatchEncryptionEnabled?: boolean,\n\n  /**\n   * The name of the CloudWatch log group to send logs to. The CloudWatch log group must already be created.\n   * @default - none\n   */\n  readonly cloudWatchLogGroup?: logs.ILogGroup,\n\n  /**\n   * The name of the S3 bucket to send logs to. The S3 bucket must already be created.\n   *\n   * @default - none\n   */\n  readonly s3Bucket?: s3.IBucket,\n\n  /**\n   * Whether or not to enable encryption on the CloudWatch logs.\n   *\n   * @default - encryption will be disabled.\n   */\n  readonly s3EncryptionEnabled?: boolean,\n\n  /**\n   * An optional folder in the S3 bucket to place logs in.\n   *\n   * @default - none\n   */\n  readonly s3KeyPrefix?: string\n}\n\n/**\n * The options for creating an Auto Scaling Group Capacity Provider.\n */\nexport interface AsgCapacityProviderProps extends AddAutoScalingGroupCapacityOptions {\n  /**\n   * The name of the capacity provider. If a name is specified,\n   * it cannot start with `aws`, `ecs`, or `fargate`. If no name is specified,\n   * a default name in the CFNStackName-CFNResourceName-RandomString format is used.\n   *\n   * @default CloudFormation-generated name\n   */\n  readonly capacityProviderName?: string;\n\n  /**\n   * The autoscaling group to add as a Capacity Provider.\n   */\n  readonly autoScalingGroup: autoscaling.IAutoScalingGroup;\n\n  /**\n   * Whether to enable managed scaling\n   *\n   * @default true\n   */\n  readonly enableManagedScaling?: boolean;\n\n  /**\n   * Whether to enable managed termination protection\n   *\n   * @default true\n   */\n  readonly enableManagedTerminationProtection?: boolean;\n\n  /**\n   * Maximum scaling step size. In most cases this should be left alone.\n   *\n   * @default 1000\n   */\n  readonly maximumScalingStepSize?: number;\n\n  /**\n   * Minimum scaling step size. In most cases this should be left alone.\n   *\n   * @default 1\n   */\n  readonly minimumScalingStepSize?: number;\n\n  /**\n   * Target capacity percent. In most cases this should be left alone.\n   *\n   * @default 100\n   */\n  readonly targetCapacityPercent?: number;\n}\n\n/**\n * An Auto Scaling Group Capacity Provider. This allows an ECS cluster to target\n * a specific EC2 Auto Scaling Group for the placement of tasks. Optionally (and\n * recommended), ECS can manage the number of instances in the ASG to fit the\n * tasks, and can ensure that instances are not prematurely terminated while\n * there are still tasks running on them.\n */\nexport class AsgCapacityProvider extends Construct {\n  /**\n   * Capacity provider name\n   * @default Chosen by CloudFormation\n   */\n  readonly capacityProviderName: string;\n\n  /**\n   * Auto Scaling Group\n   */\n  readonly autoScalingGroup: autoscaling.AutoScalingGroup;\n\n  /**\n   * Auto Scaling Group machineImageType.\n   */\n  readonly machineImageType: MachineImageType;\n\n  /**\n   * Whether managed termination protection is enabled\n   */\n  readonly enableManagedTerminationProtection?: boolean;\n\n  constructor(scope: Construct, id: string, props: AsgCapacityProviderProps) {\n    super(scope, id);\n\n    this.autoScalingGroup = props.autoScalingGroup as autoscaling.AutoScalingGroup;\n\n    this.machineImageType = props.machineImageType ?? MachineImageType.AMAZON_LINUX_2;\n\n    this.enableManagedTerminationProtection =\n      props.enableManagedTerminationProtection === undefined ? true : props.enableManagedTerminationProtection;\n\n    if (this.enableManagedTerminationProtection) {\n      this.autoScalingGroup.protectNewInstancesFromScaleIn();\n    }\n    if (props.capacityProviderName) {\n      if (!(/^(?!aws|ecs|fargate).+/gm.test(props.capacityProviderName))) {\n        throw new Error(`Invalid Capacity Provider Name: ${props.capacityProviderName}, If a name is specified, it cannot start with aws, ecs, or fargate.`);\n      }\n    }\n    const capacityProvider = new CfnCapacityProvider(this, id, {\n      name: props.capacityProviderName,\n      autoScalingGroupProvider: {\n        autoScalingGroupArn: this.autoScalingGroup.autoScalingGroupName,\n        managedScaling: props.enableManagedScaling === false ? undefined : {\n          status: 'ENABLED',\n          targetCapacity: props.targetCapacityPercent || 100,\n          maximumScalingStepSize: props.maximumScalingStepSize,\n          minimumScalingStepSize: props.minimumScalingStepSize,\n        },\n        managedTerminationProtection: this.enableManagedTerminationProtection ? 'ENABLED' : 'DISABLED',\n      },\n    });\n\n    this.capacityProviderName = capacityProvider.ref;\n  }\n}\n\n/**\n * A visitor that adds a capacity provider association to a Cluster only if\n * the caller created any EC2 Capacity Providers.\n */\nclass MaybeCreateCapacityProviderAssociations implements IAspect {\n  private scope: Construct;\n  private id: string;\n  private capacityProviders: string[]\n  private resource?: CfnClusterCapacityProviderAssociations\n\n  constructor(scope: Construct, id: string, capacityProviders: string[] ) {\n    this.scope = scope;\n    this.id = id;\n    this.capacityProviders = capacityProviders;\n  }\n\n  public visit(node: IConstruct): void {\n    if (node instanceof Cluster) {\n      if (this.capacityProviders.length > 0 && !this.resource) {\n        const resource = new CfnClusterCapacityProviderAssociations(this.scope, this.id, {\n          cluster: node.clusterName,\n          defaultCapacityProviderStrategy: [],\n          capacityProviders: Lazy.list({ produce: () => this.capacityProviders }),\n        });\n        this.resource = resource;\n      }\n    }\n  }\n}\n\n\nfunction isBottleRocketImage(image: ec2.IMachineImage) {\n  return image instanceof BottleRocketImage;\n}\n"],
  "mappings": "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",
  "names": []
}
