"use strict";var _a,_b;Object.defineProperty(exports,"__esModule",{value:!0}),exports.SelfManagedKafkaEventSource=exports.ManagedKafkaEventSource=exports.AuthenticationMethod=void 0;const jsiiDeprecationWarnings=require("../../.warnings.jsii.js"),JSII_RTTI_SYMBOL_1=Symbol.for("jsii.rtti"),crypto=require("crypto"),iam=require("../../aws-iam"),lambda=require("../../aws-lambda"),core_1=require("../../core"),stream_1=require("./stream"),constructs_1=require("constructs");var AuthenticationMethod;(function(AuthenticationMethod2){AuthenticationMethod2.SASL_SCRAM_512_AUTH="SASL_SCRAM_512_AUTH",AuthenticationMethod2.SASL_SCRAM_256_AUTH="SASL_SCRAM_256_AUTH",AuthenticationMethod2.BASIC_AUTH="BASIC_AUTH",AuthenticationMethod2.CLIENT_CERTIFICATE_TLS_AUTH="CLIENT_CERTIFICATE_TLS_AUTH"})(AuthenticationMethod=exports.AuthenticationMethod||(exports.AuthenticationMethod={}));class ManagedKafkaEventSource extends stream_1.StreamEventSource{constructor(props){super(props);this._eventSourceMappingId=void 0,jsiiDeprecationWarnings.aws_cdk_lib_aws_lambda_event_sources_ManagedKafkaEventSourceProps(props),this.innerProps=props}bind(target){var _c;jsiiDeprecationWarnings.aws_cdk_lib_aws_lambda_IFunction(target);const eventSourceMapping=target.addEventSourceMapping(`KafkaEventSource:${core_1.Names.nodeUniqueId(target.node)}${this.innerProps.topic}`,this.enrichMappingOptions({eventSourceArn:this.innerProps.clusterArn,startingPosition:this.innerProps.startingPosition,sourceAccessConfigurations:this.sourceAccessConfigurations(),kafkaTopic:this.innerProps.topic}));this._eventSourceMappingId=eventSourceMapping.eventSourceMappingId,this.innerProps.secret!==void 0&&this.innerProps.secret.grantRead(target),target.addToRolePolicy(new iam.PolicyStatement({actions:["kafka:DescribeCluster","kafka:GetBootstrapBrokers","kafka:ListScramSecrets"],resources:[this.innerProps.clusterArn]})),(_c=target.role)===null||_c===void 0||_c.addManagedPolicy(iam.ManagedPolicy.fromAwsManagedPolicyName("service-role/AWSLambdaMSKExecutionRole"))}sourceAccessConfigurations(){const sourceAccessConfigurations=[];return this.innerProps.secret!==void 0&&sourceAccessConfigurations.push({type:lambda.SourceAccessConfigurationType.SASL_SCRAM_512_AUTH,uri:this.innerProps.secret.secretArn}),sourceAccessConfigurations.length===0?void 0:sourceAccessConfigurations}get eventSourceMappingId(){if(!this._eventSourceMappingId)throw new Error("KafkaEventSource is not yet bound to an event source mapping");return this._eventSourceMappingId}}exports.ManagedKafkaEventSource=ManagedKafkaEventSource,_a=JSII_RTTI_SYMBOL_1,ManagedKafkaEventSource[_a]={fqn:"aws-cdk-lib.aws_lambda_event_sources.ManagedKafkaEventSource",version:"2.20.0"};class SelfManagedKafkaEventSource extends stream_1.StreamEventSource{constructor(props){super(props);if(jsiiDeprecationWarnings.aws_cdk_lib_aws_lambda_event_sources_SelfManagedKafkaEventSourceProps(props),props.vpc){if(!props.securityGroup)throw new Error("securityGroup must be set when providing vpc");if(!props.vpcSubnets)throw new Error("vpcSubnets must be set when providing vpc")}else if(!props.secret)throw new Error("secret must be set if Kafka brokers accessed over Internet");this.innerProps=props}bind(target){if(jsiiDeprecationWarnings.aws_cdk_lib_aws_lambda_IFunction(target),!(target instanceof constructs_1.Construct))throw new Error("Function is not a construct. Unexpected error.");target.addEventSourceMapping(this.mappingId(target),this.enrichMappingOptions({kafkaBootstrapServers:this.innerProps.bootstrapServers,kafkaTopic:this.innerProps.topic,startingPosition:this.innerProps.startingPosition,sourceAccessConfigurations:this.sourceAccessConfigurations()})),this.innerProps.secret!==void 0&&this.innerProps.secret.grantRead(target)}mappingId(target){let hash=crypto.createHash("md5");return hash.update(JSON.stringify(core_1.Stack.of(target).resolve(this.innerProps.bootstrapServers))),`KafkaEventSource:${hash.digest("hex")}:${this.innerProps.topic}`}sourceAccessConfigurations(){var _c;let authType;switch(this.innerProps.authenticationMethod){case AuthenticationMethod.BASIC_AUTH:authType=lambda.SourceAccessConfigurationType.BASIC_AUTH;break;case AuthenticationMethod.CLIENT_CERTIFICATE_TLS_AUTH:authType=lambda.SourceAccessConfigurationType.CLIENT_CERTIFICATE_TLS_AUTH;break;case AuthenticationMethod.SASL_SCRAM_256_AUTH:authType=lambda.SourceAccessConfigurationType.SASL_SCRAM_256_AUTH;break;case AuthenticationMethod.SASL_SCRAM_512_AUTH:default:authType=lambda.SourceAccessConfigurationType.SASL_SCRAM_512_AUTH;break}const sourceAccessConfigurations=[];return this.innerProps.secret!==void 0&&sourceAccessConfigurations.push({type:authType,uri:this.innerProps.secret.secretArn}),this.innerProps.vpcSubnets!==void 0&&this.innerProps.securityGroup!==void 0&&(sourceAccessConfigurations.push({type:lambda.SourceAccessConfigurationType.VPC_SECURITY_GROUP,uri:this.innerProps.securityGroup.securityGroupId}),(_c=this.innerProps.vpc)===null||_c===void 0||_c.selectSubnets(this.innerProps.vpcSubnets).subnetIds.forEach(id=>{sourceAccessConfigurations.push({type:lambda.SourceAccessConfigurationType.VPC_SUBNET,uri:id})})),sourceAccessConfigurations.length===0?void 0:sourceAccessConfigurations}}exports.SelfManagedKafkaEventSource=SelfManagedKafkaEventSource,_b=JSII_RTTI_SYMBOL_1,SelfManagedKafkaEventSource[_b]={fqn:"aws-cdk-lib.aws_lambda_event_sources.SelfManagedKafkaEventSource",version:"2.20.0"};
//# sourceMappingURL=kafka.js.map
