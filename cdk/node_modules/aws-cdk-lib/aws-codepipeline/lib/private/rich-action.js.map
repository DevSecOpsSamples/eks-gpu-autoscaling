{
  "version": 3,
  "sources": ["rich-action.ts"],
  "sourcesContent": ["import * as events from '../../../aws-events';\nimport { ResourceEnvironment, Stack, Token, TokenComparison } from '../../../core';\nimport { ActionBindOptions, ActionConfig, ActionProperties, IAction, IPipeline, IStage } from '../action';\n\n// keep this import separate from other imports to reduce chance for merge conflicts with v2-main\n// eslint-disable-next-line no-duplicate-imports, import/order\nimport { Construct } from 'constructs';\n\n/**\n * Helper routines to work with Actions\n *\n * Can't put these on Action themselves since we only have an interface\n * and every library would need to reimplement everything (there is no\n * `ActionBase`).\n *\n * So here go the members that should have gone onto the Action class\n * but can't.\n *\n * It was probably my own idea but I don't want it anymore:\n * https://github.com/aws/aws-cdk/issues/10393\n */\nexport class RichAction implements IAction {\n  public readonly actionProperties: ActionProperties;\n\n  constructor(private readonly action: IAction, private readonly pipeline: IPipeline) {\n    this.actionProperties = action.actionProperties;\n  }\n\n  public bind(scope: Construct, stage: IStage, options: ActionBindOptions): ActionConfig {\n    return this.action.bind(scope, stage, options);\n  }\n\n  public onStateChange(name: string, target?: events.IRuleTarget, options?: events.RuleProps): events.Rule {\n    return this.action.onStateChange(name, target, options);\n  }\n\n  public get isCrossRegion(): boolean {\n    return !actionDimensionSameAsPipelineDimension(this.effectiveRegion, this.pipeline.env.region);\n  }\n\n  public get isCrossAccount(): boolean {\n    return !actionDimensionSameAsPipelineDimension(this.effectiveAccount, this.pipeline.env.account);\n  }\n\n  /**\n   * Returns the Stack of the resource backing this action\n   * if they belong to the same environment.\n   * Returns `undefined` if either this action is not backed by a resource,\n   * or if the resource does not belong to the same env as its Stack\n   * (which can happen for imported resources).\n   */\n  public get resourceStack(): Stack | undefined {\n    const actionResource = this.actionProperties.resource;\n    if (!actionResource) {\n      return undefined;\n    }\n\n    const actionResourceStack = Stack.of(actionResource);\n    const actionResourceStackEnv: ResourceEnvironment = {\n      region: actionResourceStack.region,\n      account: actionResourceStack.account,\n    };\n\n    return sameEnv(actionResource.env, actionResourceStackEnv) ? actionResourceStack : undefined;\n  }\n\n  /**\n   * The region this action wants to execute in.\n   * `undefined` means it wants to execute in the same region as the pipeline.\n   */\n  public get effectiveRegion(): string | undefined {\n    return this.action.actionProperties.resource?.env.region\n      ?? this.action.actionProperties.region;\n  }\n\n  /**\n   * The account this action wants to execute in.\n   * `undefined` means it wants to execute in the same account as the pipeline.\n   */\n  public get effectiveAccount(): string | undefined {\n    return this.action.actionProperties.role?.env.account\n      ?? this.action.actionProperties?.resource?.env.account\n      ?? this.action.actionProperties.account;\n  }\n}\n\nfunction actionDimensionSameAsPipelineDimension(actionDim: string | undefined, pipelineDim: string) {\n  // if the action's dimension is `undefined`,\n  // it means it is in the same region/account as the pipeline\n  if (!actionDim) {\n    return true;\n  }\n  // if the action's region/account is AWS::Region/AWS::AccountId,\n  // we assume it's also in the same region/account as the pipeline\n  if (Token.isUnresolved(actionDim)) {\n    return true;\n  }\n  // here, we know the action's dimension is explicitly set;\n  // in this case, it must be equal to the pipeline's dimension\n  // for the action to be considered in the same region/account\n  return Token.compareStrings(actionDim, pipelineDim) === TokenComparison.SAME;\n}\n\n/**\n * Whether the two envs represent the same environment\n */\nfunction sameEnv(env1: ResourceEnvironment, env2: ResourceEnvironment) {\n  return sameEnvDimension(env1.region, env2.region)\n    && sameEnvDimension(env1.account, env2.account);\n}\n\n/**\n * Whether two string probably contain the same environment dimension (region or account)\n *\n * Used to compare either accounts or regions, and also returns true if both\n * are unresolved (in which case both are expted to be \"current region\" or \"current account\").\n */\nfunction sameEnvDimension(dim1: string, dim2: string) {\n  return [TokenComparison.SAME, TokenComparison.BOTH_UNRESOLVED].includes(Token.compareStrings(dim1, dim2));\n}\n"],
  "mappings": "8FACA,KAAA,QAAA,QAAA,eAAA,EAoBA,MAAa,UAAU,CAGrB,YAA6B,OAAkC,SAAmB,CAArD,KAAA,OAAA,OAAkC,KAAA,SAAA,SAC7D,KAAK,iBAAmB,OAAO,iBAG1B,KAAK,MAAkB,MAAe,QAA0B,CACrE,MAAO,MAAK,OAAO,KAAK,MAAO,MAAO,OAAO,EAGxC,cAAc,KAAc,OAA6B,QAA0B,CACxF,MAAO,MAAK,OAAO,cAAc,KAAM,OAAQ,OAAO,KAG7C,gBAAa,CACtB,MAAO,CAAC,uCAAuC,KAAK,gBAAiB,KAAK,SAAS,IAAI,MAAM,KAGpF,iBAAc,CACvB,MAAO,CAAC,uCAAuC,KAAK,iBAAkB,KAAK,SAAS,IAAI,OAAO,KAUtF,gBAAa,CACtB,KAAM,gBAAiB,KAAK,iBAAiB,SAC7C,GAAI,CAAC,eACH,OAGF,KAAM,qBAAsB,OAAA,MAAM,GAAG,cAAc,EAC7C,uBAA8C,CAClD,OAAQ,oBAAoB,OAC5B,QAAS,oBAAoB,SAG/B,MAAO,SAAQ,eAAe,IAAK,sBAAsB,EAAI,oBAAsB,UAO1E,kBAAe,WACxB,MAAA,IAAA,IAAO,KAAK,OAAO,iBAAiB,YAAQ,MAAA,KAAA,OAAA,OAAA,GAAE,IAAI,UAAM,MAAA,KAAA,OAAA,GACnD,KAAK,OAAO,iBAAiB,UAOzB,mBAAgB,oBACzB,MAAA,IAAA,IAAA,IAAO,KAAK,OAAO,iBAAiB,QAAI,MAAA,KAAA,OAAA,OAAA,GAAE,IAAI,WAAO,MAAA,KAAA,OAAA,GAAA,IAAA,IAChD,KAAK,OAAO,oBAAgB,MAAA,KAAA,OAAA,OAAA,GAAE,YAAQ,MAAA,KAAA,OAAA,OAAA,GAAE,IAAI,WAAO,MAAA,KAAA,OAAA,GACnD,KAAK,OAAO,iBAAiB,SA7DtC,QAAA,WAAA,WAiEA,gDAAgD,UAA+B,YAAmB,CAQhG,MALI,CAAC,WAKD,OAAA,MAAM,aAAa,SAAS,EACvB,GAKF,OAAA,MAAM,eAAe,UAAW,WAAW,IAAM,OAAA,gBAAgB,IAC1E,CAKA,iBAAiB,KAA2B,KAAyB,CACnE,MAAO,kBAAiB,KAAK,OAAQ,KAAK,MAAM,GAC3C,iBAAiB,KAAK,QAAS,KAAK,OAAO,CAClD,CAQA,0BAA0B,KAAc,KAAY,CAClD,MAAO,CAAC,OAAA,gBAAgB,KAAM,OAAA,gBAAgB,eAAe,EAAE,SAAS,OAAA,MAAM,eAAe,KAAM,IAAI,CAAC,CAC1G",
  "names": []
}
