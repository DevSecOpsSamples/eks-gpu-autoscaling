{
  "version": 3,
  "sources": ["run-ecs-task-base.ts"],
  "sourcesContent": ["import * as ec2 from '../../../aws-ec2';\nimport * as ecs from '../../../aws-ecs';\nimport * as iam from '../../../aws-iam';\nimport * as sfn from '../../../aws-stepfunctions';\nimport * as cdk from '../../../core';\nimport { getResourceArn } from '../resource-arn-suffix';\nimport { ContainerOverride } from './run-ecs-task-base-types';\n\n/**\n * Basic properties for ECS Tasks\n */\nexport interface CommonEcsRunTaskProps {\n  /**\n   * The topic to run the task on\n   */\n  readonly cluster: ecs.ICluster;\n\n  /**\n   * Task Definition used for running tasks in the service.\n   *\n   * Note: this must be TaskDefinition, and not ITaskDefinition,\n   * as it requires properties that are not known for imported task definitions\n   */\n  readonly taskDefinition: ecs.TaskDefinition;\n\n  /**\n   * Container setting overrides\n   *\n   * Key is the name of the container to override, value is the\n   * values you want to override.\n   *\n   * @default - No overrides\n   */\n  readonly containerOverrides?: ContainerOverride[];\n\n  /**\n   * The service integration pattern indicates different ways to call RunTask in ECS.\n   *\n   * The valid value for Lambda is FIRE_AND_FORGET, SYNC and WAIT_FOR_TASK_TOKEN.\n   *\n   * @default FIRE_AND_FORGET\n   */\n  readonly integrationPattern?: sfn.ServiceIntegrationPattern;\n}\n\n/**\n * Construction properties for the BaseRunTaskProps\n * @deprecated No replacement\n */\nexport interface EcsRunTaskBaseProps extends CommonEcsRunTaskProps {\n  /**\n   * Additional parameters to pass to the base task\n   *\n   * @default - No additional parameters passed\n   */\n  readonly parameters?: {[key: string]: any};\n}\n\n/**\n * A StepFunctions Task to run a Task on ECS or Fargate\n * @deprecated No replacement\n */\nexport class EcsRunTaskBase implements ec2.IConnectable, sfn.IStepFunctionsTask {\n  /**\n   * Manage allowed network traffic for this service\n   */\n  public readonly connections: ec2.Connections = new ec2.Connections();\n\n  private securityGroup?: ec2.ISecurityGroup;\n  private networkConfiguration?: any;\n  private readonly integrationPattern: sfn.ServiceIntegrationPattern;\n\n  constructor(private readonly props: EcsRunTaskBaseProps) {\n    this.integrationPattern = props.integrationPattern || sfn.ServiceIntegrationPattern.FIRE_AND_FORGET;\n\n    const supportedPatterns = [\n      sfn.ServiceIntegrationPattern.FIRE_AND_FORGET,\n      sfn.ServiceIntegrationPattern.WAIT_FOR_TASK_TOKEN,\n      sfn.ServiceIntegrationPattern.SYNC,\n    ];\n\n    if (!supportedPatterns.includes(this.integrationPattern)) {\n      throw new Error(`Invalid Service Integration Pattern: ${this.integrationPattern} is not supported to call ECS.`);\n    }\n\n    if (this.integrationPattern === sfn.ServiceIntegrationPattern.WAIT_FOR_TASK_TOKEN\n      && !sfn.FieldUtils.containsTaskToken(props.containerOverrides?.map(override => override.environment))) {\n      throw new Error('Task Token is required in at least one `containerOverrides.environment` for callback. Use JsonPath.taskToken to set the token.');\n    }\n\n    for (const override of this.props.containerOverrides || []) {\n      const name = override.containerDefinition.containerName;\n      if (!cdk.Token.isUnresolved(name)) {\n        const cont = this.props.taskDefinition.node.tryFindChild(name);\n        if (!cont) {\n          throw new Error(`Overrides mention container with name '${name}', but no such container in task definition`);\n        }\n      }\n    }\n  }\n\n  public bind(task: sfn.Task): sfn.StepFunctionsTaskConfig {\n    if (this.networkConfiguration !== undefined) {\n      // Make sure we have a security group if we're using AWSVPC networking\n      if (this.securityGroup === undefined) {\n        this.securityGroup = new ec2.SecurityGroup(task, 'SecurityGroup', { vpc: this.props.cluster.vpc });\n      }\n      this.connections.addSecurityGroup(this.securityGroup);\n    }\n\n    return {\n      resourceArn: getResourceArn('ecs', 'runTask', this.integrationPattern),\n      parameters: {\n        Cluster: this.props.cluster.clusterArn,\n        TaskDefinition: this.props.taskDefinition.taskDefinitionArn,\n        NetworkConfiguration: this.networkConfiguration,\n        Overrides: renderOverrides(this.props.containerOverrides),\n        ...this.props.parameters,\n      },\n      policyStatements: this.makePolicyStatements(task),\n    };\n  }\n\n  protected configureAwsVpcNetworking(\n    vpc: ec2.IVpc,\n    assignPublicIp?: boolean,\n    subnetSelection?: ec2.SubnetSelection,\n    securityGroup?: ec2.ISecurityGroup) {\n\n    if (subnetSelection === undefined) {\n      subnetSelection = { subnetType: assignPublicIp ? ec2.SubnetType.PUBLIC : ec2.SubnetType.PRIVATE };\n    }\n\n    // If none is given here, one will be created later on during bind()\n    this.securityGroup = securityGroup;\n\n    this.networkConfiguration = {\n      AwsvpcConfiguration: {\n        AssignPublicIp: assignPublicIp !== undefined ? (assignPublicIp ? 'ENABLED' : 'DISABLED') : undefined,\n        Subnets: vpc.selectSubnets(subnetSelection).subnetIds,\n        SecurityGroups: cdk.Lazy.list({ produce: () => [this.securityGroup!.securityGroupId] }),\n      },\n    };\n  }\n\n  private makePolicyStatements(task: sfn.Task): iam.PolicyStatement[] {\n    const stack = cdk.Stack.of(task);\n\n    // https://docs.aws.amazon.com/step-functions/latest/dg/ecs-iam.html\n    const policyStatements = [\n      new iam.PolicyStatement({\n        actions: ['ecs:RunTask'],\n        resources: [this.props.taskDefinition.taskDefinitionArn],\n      }),\n      new iam.PolicyStatement({\n        actions: ['ecs:StopTask', 'ecs:DescribeTasks'],\n        resources: ['*'],\n      }),\n      new iam.PolicyStatement({\n        actions: ['iam:PassRole'],\n        resources: cdk.Lazy.list({ produce: () => this.taskExecutionRoles().map(r => r.roleArn) }),\n      }),\n    ];\n\n    if (this.integrationPattern === sfn.ServiceIntegrationPattern.SYNC) {\n      policyStatements.push(new iam.PolicyStatement({\n        actions: ['events:PutTargets', 'events:PutRule', 'events:DescribeRule'],\n        resources: [stack.formatArn({\n          service: 'events',\n          resource: 'rule',\n          resourceName: 'StepFunctionsGetEventsForECSTaskRule',\n        })],\n      }));\n    }\n\n    return policyStatements;\n  }\n\n  private taskExecutionRoles(): iam.IRole[] {\n    // Need to be able to pass both Task and Execution role, apparently\n    const ret = new Array<iam.IRole>();\n    ret.push(this.props.taskDefinition.taskRole);\n    if (this.props.taskDefinition.executionRole) {\n      ret.push(this.props.taskDefinition.executionRole);\n    }\n    return ret;\n  }\n}\n\nfunction renderOverrides(containerOverrides?: ContainerOverride[]) {\n  if (!containerOverrides) { return undefined; }\n\n  const ret = new Array<any>();\n  for (const override of containerOverrides) {\n    ret.push({\n      Name: override.containerDefinition.containerName,\n      Command: override.command,\n      Cpu: override.cpu,\n      Memory: override.memoryLimit,\n      MemoryReservation: override.memoryReservation,\n      Environment: override.environment && override.environment.map(e => ({\n        Name: e.name,\n        Value: e.value,\n      })),\n    });\n  }\n\n  return { ContainerOverrides: ret };\n}\n"],
  "mappings": "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",
  "names": []
}
