{
  "version": 3,
  "sources": ["start-execution.ts"],
  "sourcesContent": ["import * as iam from '../../aws-iam';\nimport * as sfn from '../../aws-stepfunctions';\nimport { ArnFormat, Stack } from '../../core';\nimport { getResourceArn } from './resource-arn-suffix';\n\n/**\n * Properties for StartExecution\n *\n * @deprecated - use 'StepFunctionsStartExecution'\n */\nexport interface StartExecutionProps {\n  /**\n   * The JSON input for the execution, same as that of StartExecution.\n   *\n   * @see https://docs.aws.amazon.com/step-functions/latest/apireference/API_StartExecution.html\n   *\n   * @default - No input\n   */\n  readonly input?: { [key: string]: any };\n\n  /**\n   * The name of the execution, same as that of StartExecution.\n   *\n   * @see https://docs.aws.amazon.com/step-functions/latest/apireference/API_StartExecution.html\n   *\n   * @default - None\n   */\n  readonly name?: string;\n\n  /**\n   * The service integration pattern indicates different ways to call StartExecution to Step Functions.\n   *\n   * @default FIRE_AND_FORGET\n   *\n   * @see https://docs.aws.amazon.com/step-functions/latest/dg/connect-to-resource.html\n   */\n  readonly integrationPattern?: sfn.ServiceIntegrationPattern;\n}\n\n/**\n * A Step Functions Task to call StartExecution on another state machine.\n *\n * It supports three service integration patterns: FIRE_AND_FORGET, SYNC and WAIT_FOR_TASK_TOKEN.\n *\n * @deprecated - use 'StepFunctionsStartExecution'\n */\nexport class StartExecution implements sfn.IStepFunctionsTask {\n  private readonly integrationPattern: sfn.ServiceIntegrationPattern;\n\n  constructor(private readonly stateMachine: sfn.IStateMachine, private readonly props: StartExecutionProps = {}) {\n    this.integrationPattern = props.integrationPattern || sfn.ServiceIntegrationPattern.FIRE_AND_FORGET;\n\n    const supportedPatterns = [\n      sfn.ServiceIntegrationPattern.FIRE_AND_FORGET,\n      sfn.ServiceIntegrationPattern.SYNC,\n      sfn.ServiceIntegrationPattern.WAIT_FOR_TASK_TOKEN,\n    ];\n\n    if (!supportedPatterns.includes(this.integrationPattern)) {\n      throw new Error(`Invalid Service Integration Pattern: ${this.integrationPattern} is not supported to call Step Functions.`);\n    }\n\n    if (this.integrationPattern === sfn.ServiceIntegrationPattern.WAIT_FOR_TASK_TOKEN\n      && !sfn.FieldUtils.containsTaskToken(props.input)) {\n      throw new Error('Task Token is missing in input (pass JsonPath.taskToken somewhere in input)');\n    }\n  }\n\n  public bind(task: sfn.Task): sfn.StepFunctionsTaskConfig {\n    return {\n      resourceArn: getResourceArn('states', 'startExecution', this.integrationPattern),\n      policyStatements: this.createScopedAccessPolicy(task),\n      parameters: {\n        Input: this.props.input,\n        StateMachineArn: this.stateMachine.stateMachineArn,\n        Name: this.props.name,\n      },\n    };\n  }\n\n  /**\n   * As StateMachineArn is extracted automatically from the state machine object included in the constructor,\n   *\n   * the scoped access policy should be generated accordingly.\n   *\n   * This means the action of StartExecution should be restricted on the given state machine, instead of being granted to all the resources (*).\n   */\n  private createScopedAccessPolicy(task: sfn.Task): iam.PolicyStatement[] {\n    const stack = Stack.of(task);\n\n    const policyStatements = [\n      new iam.PolicyStatement({\n        actions: ['states:StartExecution'],\n        resources: [this.stateMachine.stateMachineArn],\n      }),\n    ];\n\n    // Step Functions use Cloud Watch managed rules to deal with synchronous tasks.\n    if (this.integrationPattern === sfn.ServiceIntegrationPattern.SYNC) {\n      policyStatements.push(new iam.PolicyStatement({\n        actions: ['states:DescribeExecution', 'states:StopExecution'],\n        // https://docs.aws.amazon.com/step-functions/latest/dg/concept-create-iam-advanced.html#concept-create-iam-advanced-execution\n        resources: [stack.formatArn({\n          service: 'states',\n          resource: 'execution',\n          arnFormat: ArnFormat.COLON_RESOURCE_NAME,\n          resourceName: `${stack.splitArn(this.stateMachine.stateMachineArn, ArnFormat.COLON_RESOURCE_NAME).resourceName}*`,\n        })],\n      }));\n\n      policyStatements.push(new iam.PolicyStatement({\n        actions: ['events:PutTargets', 'events:PutRule', 'events:DescribeRule'],\n        resources: [stack.formatArn({\n          service: 'events',\n          resource: 'rule',\n          resourceName: 'StepFunctionsGetEventsForStepFunctionsExecutionRule',\n        })],\n      }));\n    }\n\n    return policyStatements;\n  }\n}\n"],
  "mappings": "0JAAA,IAAA,QAAA,eAAA,EACA,IAAA,QAAA,yBAAA,EACA,OAAA,QAAA,YAAA,EACA,sBAAA,QAAA,uBAAA,EA2CA,MAAa,cAAc,CAGzB,YAA6B,aAAkD,MAA6B,CAAA,EAAE,CAS5G,GAT2B,KAAA,aAAA,aAAkD,KAAA,MAAA,MAC7E,KAAK,mBAAqB,MAAM,oBAAsB,IAAI,0BAA0B,gBAQhF,CAAC,AANqB,CACxB,IAAI,0BAA0B,gBAC9B,IAAI,0BAA0B,KAC9B,IAAI,0BAA0B,qBAGT,SAAS,KAAK,kBAAkB,EACrD,KAAM,IAAI,OAAM,wCAAwC,KAAK,6DAA6D,EAG5H,GAAI,KAAK,qBAAuB,IAAI,0BAA0B,qBACzD,CAAC,IAAI,WAAW,kBAAkB,MAAM,KAAK,EAChD,KAAM,IAAI,OAAM,6EAA6E,EAI1F,KAAK,KAAc,CACxB,MAAO,CACL,YAAa,sBAAA,eAAe,SAAU,iBAAkB,KAAK,kBAAkB,EAC/E,iBAAkB,KAAK,yBAAyB,IAAI,EACpD,WAAY,CACV,MAAO,KAAK,MAAM,MAClB,gBAAiB,KAAK,aAAa,gBACnC,KAAM,KAAK,MAAM,OAYf,yBAAyB,KAAc,CAC7C,KAAM,OAAQ,OAAA,MAAM,GAAG,IAAI,EAErB,iBAAmB,CACvB,GAAI,KAAI,gBAAgB,CACtB,QAAS,CAAC,uBAAuB,EACjC,UAAW,CAAC,KAAK,aAAa,eAAe,EAC9C,GAIH,MAAI,MAAK,qBAAuB,IAAI,0BAA0B,MAC5D,kBAAiB,KAAK,GAAI,KAAI,gBAAgB,CAC5C,QAAS,CAAC,2BAA4B,sBAAsB,EAE5D,UAAW,CAAC,MAAM,UAAU,CAC1B,QAAS,SACT,SAAU,YACV,UAAW,OAAA,UAAU,oBACrB,aAAc,GAAG,MAAM,SAAS,KAAK,aAAa,gBAAiB,OAAA,UAAU,mBAAmB,EAAE,gBACnG,CAAC,EACH,CAAC,EAEF,iBAAiB,KAAK,GAAI,KAAI,gBAAgB,CAC5C,QAAS,CAAC,oBAAqB,iBAAkB,qBAAqB,EACtE,UAAW,CAAC,MAAM,UAAU,CAC1B,QAAS,SACT,SAAU,OACV,aAAc,sDACf,CAAC,EACH,CAAC,GAGG,kBA1EX,QAAA,eAAA",
  "names": []
}
