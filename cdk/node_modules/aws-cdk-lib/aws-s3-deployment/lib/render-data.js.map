{
  "version": 3,
  "sources": ["render-data.ts"],
  "sourcesContent": ["import { Stack } from '../../core';\n\n// keep this import separate from other imports to reduce chance for merge conflicts with v2-main\n// eslint-disable-next-line no-duplicate-imports, import/order\nimport { Construct } from 'constructs';\n\nexport interface Content {\n  readonly text: string;\n  readonly markers: Record<string, any>;\n}\n\n/**\n * Renders the given string data as deployable content with markers substituted\n * for all \"Ref\" and \"Fn::GetAtt\" objects.\n *\n * @param scope Construct scope\n * @param data The input data\n * @returns The markered text (`text`) and a map that maps marker names to their\n * values (`markers`).\n */\nexport function renderData(scope: Construct, data: string): Content {\n  const obj = Stack.of(scope).resolve(data);\n  if (typeof(obj) === 'string') {\n    return { text: obj, markers: {} };\n  }\n\n  if (typeof(obj) !== 'object') {\n    throw new Error(`Unexpected: after resolve() data must either be a string or a CloudFormation intrinsic. Got: ${JSON.stringify(obj)}`);\n  }\n\n  let markerIndex = 0;\n  const markers: Record<string, FnJoinPart> = {};\n  const result = new Array<string>();\n  const fnJoin: FnJoin | undefined = obj['Fn::Join'];\n\n  if (fnJoin) {\n    const sep = fnJoin[0];\n    const parts = fnJoin[1];\n\n    if (sep !== '') {\n      throw new Error(`Unexpected \"Fn::Join\", expecting separator to be an empty string but got \"${sep}\"`);\n    }\n\n    for (const part of parts) {\n      if (typeof (part) === 'string') {\n        result.push(part);\n        continue;\n      }\n\n      if (typeof (part) === 'object') {\n        addMarker(part);\n        continue;\n      }\n\n      throw new Error(`Unexpected \"Fn::Join\" part, expecting string or object but got ${typeof (part)}`);\n    }\n\n  } else if (obj.Ref || obj['Fn::GetAtt']) {\n    addMarker(obj);\n  } else {\n    throw new Error('Unexpected: Expecting `resolve()` to return \"Fn::Join\", \"Ref\" or \"Fn::GetAtt\"');\n  }\n\n  function addMarker(part: Ref | GetAtt) {\n    const keys = Object.keys(part);\n    if (keys.length !== 1 || (keys[0] != 'Ref' && keys[0] != 'Fn::GetAtt')) {\n      throw new Error(`Invalid CloudFormation reference. \"Ref\" or \"Fn::GetAtt\". Got ${JSON.stringify(part)}`);\n    }\n\n    const marker = `<<marker:0xbaba:${markerIndex++}>>`;\n    result.push(marker);\n    markers[marker] = part;\n  }\n\n  return { text: result.join(''), markers };\n}\n\ntype FnJoin = [string, FnJoinPart[]];\ntype FnJoinPart = string | Ref | GetAtt;\ntype Ref = { Ref: string };\ntype GetAtt = { 'Fn::GetAtt': [string, string] };"],
  "mappings": "8FAAA,KAAA,QAAA,QAAA,YAAA,EAoBA,oBAA2B,MAAkB,KAAY,CACvD,KAAM,KAAM,OAAA,MAAM,GAAG,KAAK,EAAE,QAAQ,IAAI,EACxC,GAAI,MAAO,MAAS,SAClB,MAAO,CAAE,KAAM,IAAK,QAAS,CAAA,CAAE,EAGjC,GAAI,MAAO,MAAS,SAClB,KAAM,IAAI,OAAM,gGAAgG,KAAK,UAAU,GAAG,GAAG,EAGvI,GAAI,aAAc,EAClB,KAAM,SAAsC,CAAA,EACtC,OAAS,GAAI,OACb,OAA6B,IAAI,YAEvC,GAAI,OAAQ,CACV,KAAM,KAAM,OAAO,GACb,MAAQ,OAAO,GAErB,GAAI,MAAQ,GACV,KAAM,IAAI,OAAM,6EAA6E,MAAM,EAGrG,SAAW,QAAQ,OAAO,CACxB,GAAI,MAAQ,OAAU,SAAU,CAC9B,OAAO,KAAK,IAAI,EAChB,SAGF,GAAI,MAAQ,OAAU,SAAU,CAC9B,UAAU,IAAI,EACd,SAGF,KAAM,IAAI,OAAM,kEAAkE,MAAQ,OAAO,WAG1F,IAAI,KAAO,IAAI,cACxB,UAAU,GAAG,MAEb,MAAM,IAAI,OAAM,+EAA+E,EAGjG,mBAAmB,KAAkB,CACnC,KAAM,MAAO,OAAO,KAAK,IAAI,EAC7B,GAAI,KAAK,SAAW,GAAM,KAAK,IAAM,OAAS,KAAK,IAAM,aACvD,KAAM,IAAI,OAAM,gEAAgE,KAAK,UAAU,IAAI,GAAG,EAGxG,KAAM,QAAS,mBAAmB,kBAClC,OAAO,KAAK,MAAM,EAClB,QAAQ,QAAU,IACpB,CAEA,MAAO,CAAE,KAAM,OAAO,KAAK,EAAE,EAAG,OAAO,CACzC,CAvDA,QAAA,WAAA",
  "names": []
}
