{
  "version": 3,
  "sources": ["base-scalable-attribute.ts"],
  "sourcesContent": ["import * as iam from '../../aws-iam';\nimport { Construct } from 'constructs';\nimport { ScalableTarget, ScalingSchedule, ServiceNamespace } from './scalable-target';\nimport { BasicStepScalingPolicyProps } from './step-scaling-policy';\nimport { BasicTargetTrackingScalingPolicyProps } from './target-tracking-scaling-policy';\n\n/**\n * Properties for a ScalableTableAttribute\n */\nexport interface BaseScalableAttributeProps extends EnableScalingProps {\n  /**\n   * Service namespace of the scalable attribute\n   */\n  readonly serviceNamespace: ServiceNamespace;\n\n  /**\n   * Resource ID of the attribute\n   */\n  readonly resourceId: string;\n\n  /**\n   * Scalable dimension of the attribute\n   */\n  readonly dimension: string;\n\n  /**\n   * Role to use for scaling\n   */\n  readonly role: iam.IRole;\n}\n\n/**\n * Represent an attribute for which autoscaling can be configured\n *\n * This class is basically a light wrapper around ScalableTarget, but with\n * all methods protected instead of public so they can be selectively\n * exposed and/or more specific versions of them can be exposed by derived\n * classes for individual services support autoscaling.\n *\n * Typical use cases:\n *\n * - Hide away the PredefinedMetric enum for target tracking policies.\n * - Don't expose all scaling methods (for example Dynamo tables don't support\n *   Step Scaling, so the Dynamo subclass won't expose this method).\n */\nexport abstract class BaseScalableAttribute extends Construct {\n  private target: ScalableTarget;\n\n  public constructor(scope: Construct, id: string, protected readonly props: BaseScalableAttributeProps) {\n    super(scope, id);\n\n    this.target = new ScalableTarget(this, 'Target', {\n      serviceNamespace: this.props.serviceNamespace,\n      scalableDimension: this.props.dimension,\n      resourceId: this.props.resourceId,\n      role: this.props.role,\n      minCapacity: props.minCapacity ?? 1,\n      maxCapacity: props.maxCapacity,\n    });\n  }\n\n  /**\n   * Scale out or in based on time\n   */\n  protected doScaleOnSchedule(id: string, props: ScalingSchedule) {\n    this.target.scaleOnSchedule(id, props);\n  }\n\n  /**\n   * Scale out or in based on a metric value\n   */\n  protected doScaleOnMetric(id: string, props: BasicStepScalingPolicyProps) {\n    this.target.scaleOnMetric(id, props);\n  }\n\n  /**\n   * Scale out or in in order to keep a metric around a target value\n   */\n  protected doScaleToTrackMetric(id: string, props: BasicTargetTrackingScalingPolicyProps) {\n    this.target.scaleToTrackMetric(id, props);\n  }\n}\n\n/**\n * Properties for enabling Application Auto Scaling\n */\nexport interface EnableScalingProps {\n  /**\n   * Minimum capacity to scale to\n   *\n   * @default 1\n   */\n  readonly minCapacity?: number;\n\n  /**\n   * Maximum capacity to scale to\n   */\n  readonly maxCapacity: number;\n}\n"],
  "mappings": "4NACA,aAAA,QAAA,YAAA,EACA,kBAAA,QAAA,mBAAA,EA2CA,MAAsB,6BAA8B,cAAA,SAAS,CAG3D,YAAmB,MAAkB,GAA+B,MAAiC,QACnG,MAAM,MAAO,EAAE,EADmD,KAAA,MAAA,uGAGlE,KAAK,OAAS,GAAI,mBAAA,eAAe,KAAM,SAAU,CAC/C,iBAAkB,KAAK,MAAM,iBAC7B,kBAAmB,KAAK,MAAM,UAC9B,WAAY,KAAK,MAAM,WACvB,KAAM,KAAK,MAAM,KACjB,YAAW,IAAE,MAAM,eAAW,MAAA,KAAA,OAAA,GAAI,EAClC,YAAa,MAAM,YACpB,EAMO,kBAAkB,GAAY,MAAsB,uFAC5D,KAAK,OAAO,gBAAgB,GAAI,KAAK,EAM7B,gBAAgB,GAAY,MAAkC,mGACtE,KAAK,OAAO,cAAc,GAAI,KAAK,EAM3B,qBAAqB,GAAY,MAA4C,6GACrF,KAAK,OAAO,mBAAmB,GAAI,KAAK,GAlC5C,QAAA,sBAAA",
  "names": []
}
