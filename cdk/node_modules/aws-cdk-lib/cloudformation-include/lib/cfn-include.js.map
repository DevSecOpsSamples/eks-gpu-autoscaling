{
  "version": 3,
  "sources": ["cfn-include.ts"],
  "sourcesContent": ["import * as core from '../../core';\nimport * as cfn_parse from '../../core/lib/cfn-parse';\nimport { Construct } from 'constructs';\nimport * as cfn_type_to_l1_mapping from './cfn-type-to-l1-mapping';\nimport * as futils from './file-utils';\n\n/**\n * Construction properties of {@link CfnInclude}.\n */\nexport interface CfnIncludeProps {\n  /**\n   * Path to the template file.\n   *\n   * Both JSON and YAML template formats are supported.\n   */\n  readonly templateFile: string;\n\n  /**\n   * Whether the resources should have the same logical IDs in the resulting CDK template\n   * as they did in the original CloudFormation template file.\n   * If you're vending a Construct using an existing CloudFormation template,\n   * make sure to pass this as `false`.\n   *\n   * **Note**: regardless of whether this option is true or false,\n   * the {@link CfnInclude.getResource} and related methods always uses the original logical ID of the resource/element,\n   * as specified in the template file.\n   *\n   * @default true\n   */\n  readonly preserveLogicalIds?: boolean;\n\n  /**\n   * Specifies the template files that define nested stacks that should be included.\n   *\n   * If your template specifies a stack that isn't included here, it won't be created as a NestedStack\n   * resource, and it won't be accessible from the {@link CfnInclude.getNestedStack} method\n   * (but will still be accessible from the {@link CfnInclude.getResource} method).\n   *\n   * If you include a stack here with an ID that isn't in the template,\n   * or is in the template but is not a nested stack,\n   * template creation will fail and an error will be thrown.\n   *\n   * @default - no nested stacks will be included\n   */\n  readonly loadNestedStacks?: { [stackName: string]: CfnIncludeProps };\n\n  /**\n   * Specifies parameters to be replaced by the values in this mapping.\n   * Any parameters in the template that aren't specified here will be left unmodified.\n   * If you include a parameter here with an ID that isn't in the template,\n   * template creation will fail and an error will be thrown.\n   *\n   * @default - no parameters will be replaced\n   */\n  readonly parameters?: { [parameterName: string]: any };\n}\n\n/**\n * The type returned from {@link CfnInclude.getNestedStack}.\n * Contains both the NestedStack object and\n * CfnInclude representations of the child stack.\n */\nexport interface IncludedNestedStack {\n  /**\n   * The NestedStack object which represents the scope of the template.\n   */\n  readonly stack: core.NestedStack;\n\n  /**\n   * The CfnInclude that represents the template, which can\n   * be used to access Resources and other template elements.\n   */\n  readonly includedTemplate: CfnInclude;\n}\n\n/**\n * Construct to import an existing CloudFormation template file into a CDK application.\n * All resources defined in the template file can be retrieved by calling the {@link getResource} method.\n * Any modifications made on the returned resource objects will be reflected in the resulting CDK template.\n */\nexport class CfnInclude extends core.CfnElement {\n  private readonly conditions: { [conditionName: string]: core.CfnCondition } = {};\n  private readonly conditionsScope: Construct;\n  private readonly resources: { [logicalId: string]: core.CfnResource } = {};\n  private readonly parameters: { [logicalId: string]: core.CfnParameter } = {};\n  private readonly parametersToReplace: { [parameterName: string]: any };\n  private readonly mappingsScope: Construct;\n  private readonly mappings: { [mappingName: string]: core.CfnMapping } = {};\n  private readonly rules: { [ruleName: string]: core.CfnRule } = {};\n  private readonly rulesScope: Construct;\n  private readonly hooks: { [hookName: string]: core.CfnHook } = {};\n  private readonly hooksScope: Construct;\n  private readonly outputs: { [logicalId: string]: core.CfnOutput } = {};\n  private readonly nestedStacks: { [logicalId: string]: IncludedNestedStack } = {};\n  private readonly nestedStacksToInclude: { [name: string]: CfnIncludeProps };\n  private readonly template: any;\n  private readonly preserveLogicalIds: boolean;\n\n  constructor(scope: Construct, id: string, props: CfnIncludeProps) {\n    super(scope, id);\n\n    this.parametersToReplace = props.parameters || {};\n\n    // read the template into a JS object\n    this.template = futils.readYamlSync(props.templateFile);\n\n    this.preserveLogicalIds = props.preserveLogicalIds ?? true;\n\n    // check if all user specified parameter values exist in the template\n    for (const logicalId of Object.keys(this.parametersToReplace)) {\n      if (!(logicalId in (this.template.Parameters || {}))) {\n        throw new Error(`Parameter with logical ID '${logicalId}' was not found in the template`);\n      }\n    }\n\n    // instantiate the Mappings\n    this.mappingsScope = new Construct(this, '$Mappings');\n    for (const mappingName of Object.keys(this.template.Mappings || {})) {\n      this.createMapping(mappingName);\n    }\n\n    // instantiate all parameters\n    for (const logicalId of Object.keys(this.template.Parameters || {})) {\n      this.createParameter(logicalId);\n    }\n\n    // instantiate the conditions\n    this.conditionsScope = new Construct(this, '$Conditions');\n    for (const conditionName of Object.keys(this.template.Conditions || {})) {\n      this.getOrCreateCondition(conditionName);\n    }\n\n    // instantiate the rules\n    this.rulesScope = new Construct(this, '$Rules');\n    for (const ruleName of Object.keys(this.template.Rules || {})) {\n      this.createRule(ruleName);\n    }\n\n    this.nestedStacksToInclude = props.loadNestedStacks || {};\n    // instantiate all resources as CDK L1 objects\n    for (const logicalId of Object.keys(this.template.Resources || {})) {\n      this.getOrCreateResource(logicalId);\n    }\n    // verify that all nestedStacks have been instantiated\n    for (const nestedStackId of Object.keys(props.loadNestedStacks || {})) {\n      if (!(nestedStackId in this.resources)) {\n        throw new Error(`Nested Stack with logical ID '${nestedStackId}' was not found in the template`);\n      }\n    }\n\n    // instantiate the Hooks\n    this.hooksScope = new Construct(this, '$Hooks');\n    for (const hookName of Object.keys(this.template.Hooks || {})) {\n      this.createHook(hookName);\n    }\n\n    const outputScope = new Construct(this, '$Ouputs');\n    for (const logicalId of Object.keys(this.template.Outputs || {})) {\n      this.createOutput(logicalId, outputScope);\n    }\n  }\n\n  /**\n   * Returns the low-level CfnResource from the template with the given logical ID.\n   * Any modifications performed on that resource will be reflected in the resulting CDK template.\n   *\n   * The returned object will be of the proper underlying class;\n   * you can always cast it to the correct type in your code:\n   *\n   *     // assume the template contains an AWS::S3::Bucket with logical ID 'Bucket'\n   *     const cfnBucket = cfnTemplate.getResource('Bucket') as s3.CfnBucket;\n   *     // cfnBucket is of type s3.CfnBucket\n   *\n   * If the template does not contain a resource with the given logical ID,\n   * an exception will be thrown.\n   *\n   * @param logicalId the logical ID of the resource in the CloudFormation template file\n   */\n  public getResource(logicalId: string): core.CfnResource {\n    const ret = this.resources[logicalId];\n    if (!ret) {\n      throw new Error(`Resource with logical ID '${logicalId}' was not found in the template`);\n    }\n    return ret;\n  }\n\n  /**\n   * Returns the CfnCondition object from the 'Conditions'\n   * section of the CloudFormation template with the given name.\n   * Any modifications performed on that object will be reflected in the resulting CDK template.\n   *\n   * If a Condition with the given name is not present in the template,\n   * throws an exception.\n   *\n   * @param conditionName the name of the Condition in the CloudFormation template file\n   */\n  public getCondition(conditionName: string): core.CfnCondition {\n    const ret = this.conditions[conditionName];\n    if (!ret) {\n      throw new Error(`Condition with name '${conditionName}' was not found in the template`);\n    }\n    return ret;\n  }\n\n  /**\n   * Returns the CfnParameter object from the 'Parameters'\n   * section of the included template.\n   * Any modifications performed on that object will be reflected in the resulting CDK template.\n   *\n   * If a Parameter with the given name is not present in the template,\n   * throws an exception.\n   *\n   * @param parameterName the name of the parameter to retrieve\n   */\n  public getParameter(parameterName: string): core.CfnParameter {\n    const ret = this.parameters[parameterName];\n    if (!ret) {\n      throw new Error(`Parameter with name '${parameterName}' was not found in the template`);\n    }\n    return ret;\n  }\n\n  /**\n   * Returns the CfnMapping object from the 'Mappings' section of the included template.\n   * Any modifications performed on that object will be reflected in the resulting CDK template.\n   *\n   * If a Mapping with the given name is not present in the template,\n   * an exception will be thrown.\n   *\n   * @param mappingName the name of the Mapping in the template to retrieve\n   */\n  public getMapping(mappingName: string): core.CfnMapping {\n    const ret = this.mappings[mappingName];\n    if (!ret) {\n      throw new Error(`Mapping with name '${mappingName}' was not found in the template`);\n    }\n    return ret;\n  }\n\n  /**\n   * Returns the CfnOutput object from the 'Outputs'\n   * section of the included template.\n   * Any modifications performed on that object will be reflected in the resulting CDK template.\n   *\n   * If an Output with the given name is not present in the template,\n   * throws an exception.\n   *\n   * @param logicalId the name of the output to retrieve\n   */\n  public getOutput(logicalId: string): core.CfnOutput {\n    const ret = this.outputs[logicalId];\n    if (!ret) {\n      throw new Error(`Output with logical ID '${logicalId}' was not found in the template`);\n    }\n    return ret;\n  }\n\n  /**\n   * Returns the CfnRule object from the 'Rules'\n   * section of the CloudFormation template with the given name.\n   * Any modifications performed on that object will be reflected in the resulting CDK template.\n   *\n   * If a Rule with the given name is not present in the template,\n   * an exception will be thrown.\n   *\n   * @param ruleName the name of the Rule in the CloudFormation template\n   */\n  public getRule(ruleName: string): core.CfnRule {\n    const ret = this.rules[ruleName];\n    if (!ret) {\n      throw new Error(`Rule with name '${ruleName}' was not found in the template`);\n    }\n    return ret;\n  }\n\n  /**\n   * Returns the CfnHook object from the 'Hooks'\n   * section of the included CloudFormation template with the given logical ID.\n   * Any modifications performed on the returned object will be reflected in the resulting CDK template.\n   *\n   * If a Hook with the given logical ID is not present in the template,\n   * an exception will be thrown.\n   *\n   * @param hookLogicalId the logical ID of the Hook in the included CloudFormation template's 'Hooks' section\n   */\n  public getHook(hookLogicalId: string): core.CfnHook {\n    const ret = this.hooks[hookLogicalId];\n    if (!ret) {\n      throw new Error(`Hook with logical ID '${hookLogicalId}' was not found in the template`);\n    }\n    return ret;\n  }\n\n  /**\n   * Returns a loaded NestedStack with name logicalId.\n   * For a nested stack to be returned by this method,\n   * it must be specified either in the {@link CfnIncludeProps.loadNestedStacks} property,\n   * or through the {@link loadNestedStack} method.\n   *\n   * @param logicalId the ID of the stack to retrieve, as it appears in the template\n   */\n  public getNestedStack(logicalId: string): IncludedNestedStack {\n    if (!this.nestedStacks[logicalId]) {\n      if (!this.template.Resources[logicalId]) {\n        throw new Error(`Nested Stack with logical ID '${logicalId}' was not found in the template`);\n      } else if (this.template.Resources[logicalId].Type !== 'AWS::CloudFormation::Stack') {\n        throw new Error(`Resource with logical ID '${logicalId}' is not a CloudFormation Stack`);\n      } else {\n        throw new Error(`Nested Stack '${logicalId}' was not included in the parent template. ` +\n          'To retrieve an included nested stack, it must be specified either in the `loadNestedStacks` property, or through the `loadNestedStack` method');\n      }\n    }\n    return this.nestedStacks[logicalId];\n  }\n\n  /**\n   * Includes a template for a child stack inside of this parent template.\n   * A child with this logical ID must exist in the template,\n   * and be of type AWS::CloudFormation::Stack.\n   * This is equivalent to specifying the value in the {@link CfnIncludeProps.loadNestedStacks}\n   * property on object construction.\n   *\n   * @param logicalId the ID of the stack to retrieve, as it appears in the template\n   * @param nestedStackProps the properties of the included child Stack\n   * @returns the same {@link IncludedNestedStack} object that {@link getNestedStack} returns for this logical ID\n   */\n  public loadNestedStack(logicalId: string, nestedStackProps: CfnIncludeProps): IncludedNestedStack {\n    if (logicalId in this.nestedStacks) {\n      throw new Error(`Nested Stack '${logicalId}' was already included in its parent template`);\n    }\n    const cfnStack = this.resources[logicalId];\n    if (!cfnStack) {\n      throw new Error(`Nested Stack with logical ID '${logicalId}' was not found in the template`);\n    }\n    if (cfnStack instanceof core.CfnStack) {\n      // delete the old CfnStack child - one will be created by the NestedStack object\n      this.node.tryRemoveChild(logicalId);\n      // remove the previously created CfnStack resource from the resources map\n      delete this.resources[logicalId];\n      // createNestedStack() (called by getOrCreateResource()) expects this to be filled\n      this.nestedStacksToInclude[logicalId] = nestedStackProps;\n\n      this.getOrCreateResource(logicalId);\n      return this.nestedStacks[logicalId];\n    } else {\n      throw new Error(`Nested Stack with logical ID '${logicalId}' is not an AWS::CloudFormation::Stack resource`);\n    }\n  }\n\n  /** @internal */\n  public _toCloudFormation(): object {\n    const ret: { [section: string]: any } = {};\n\n    for (const section of Object.keys(this.template)) {\n      const self = this;\n      const finder: cfn_parse.ICfnFinder = {\n        findResource(lId): core.CfnResource | undefined {\n          return self.resources[lId];\n        },\n        findRefTarget(elementName: string): core.CfnElement | undefined {\n          return self.resources[elementName] ?? self.parameters[elementName];\n        },\n        findCondition(conditionName: string): core.CfnCondition | undefined {\n          return self.conditions[conditionName];\n        },\n        findMapping(mappingName): core.CfnMapping | undefined {\n          return self.mappings[mappingName];\n        },\n      };\n      const cfnParser = new cfn_parse.CfnParser({\n        finder,\n        parameters: this.parametersToReplace,\n      });\n\n      switch (section) {\n        case 'Conditions':\n        case 'Mappings':\n        case 'Resources':\n        case 'Parameters':\n        case 'Rules':\n        case 'Hooks':\n        case 'Outputs':\n          // these are rendered as a side effect of instantiating the L1s\n          break;\n        default:\n          ret[section] = cfnParser.parseValue(this.template[section]);\n      }\n    }\n\n    return ret;\n  }\n\n  private createMapping(mappingName: string): void {\n    const cfnParser = new cfn_parse.CfnParser({\n      finder: {\n        findCondition() { throw new Error('Referring to Conditions in Mapping definitions is not allowed'); },\n        findMapping() { throw new Error('Referring to other Mappings in Mapping definitions is not allowed'); },\n        findRefTarget() { throw new Error('Using Ref expressions in Mapping definitions is not allowed'); },\n        findResource() { throw new Error('Using GetAtt expressions in Mapping definitions is not allowed'); },\n      },\n      parameters: {},\n    });\n    const cfnMapping = new core.CfnMapping(this.mappingsScope, mappingName, {\n      mapping: cfnParser.parseValue(this.template.Mappings[mappingName]),\n    });\n    this.mappings[mappingName] = cfnMapping;\n    this.overrideLogicalIdIfNeeded(cfnMapping, mappingName);\n  }\n\n  private createParameter(logicalId: string): void {\n    if (logicalId in this.parametersToReplace) {\n      return;\n    }\n\n    const expression = new cfn_parse.CfnParser({\n      finder: {\n        findResource() { throw new Error('Using GetAtt expressions in Parameter definitions is not allowed'); },\n        findRefTarget() { throw new Error('Using Ref expressions in Parameter definitions is not allowed'); },\n        findCondition() { throw new Error('Referring to Conditions in Parameter definitions is not allowed'); },\n        findMapping() { throw new Error('Referring to Mappings in Parameter definitions is not allowed'); },\n      },\n      parameters: {},\n    }).parseValue(this.template.Parameters[logicalId]);\n    const cfnParameter = new core.CfnParameter(this, logicalId, {\n      type: expression.Type,\n      default: expression.Default,\n      allowedPattern: expression.AllowedPattern,\n      allowedValues: expression.AllowedValues,\n      constraintDescription: expression.ConstraintDescription,\n      description: expression.Description,\n      maxLength: expression.MaxLength,\n      maxValue: expression.MaxValue,\n      minLength: expression.MinLength,\n      minValue: expression.MinValue,\n      noEcho: expression.NoEcho,\n    });\n\n    this.overrideLogicalIdIfNeeded(cfnParameter, logicalId);\n    this.parameters[logicalId] = cfnParameter;\n  }\n\n  private createRule(ruleName: string): void {\n    const self = this;\n    const cfnParser = new cfn_parse.CfnParser({\n      finder: {\n        findRefTarget(refTarget: string): core.CfnElement | undefined {\n          // only parameters can be referenced in Rules\n          return self.parameters[refTarget];\n        },\n        findResource() { throw new Error('Using GetAtt expressions in Rule definitions is not allowed'); },\n        findCondition(conditionName: string): core.CfnCondition | undefined {\n          return self.conditions[conditionName];\n        },\n        findMapping(mappingName: string): core.CfnMapping | undefined {\n          return self.mappings[mappingName];\n        },\n      },\n      parameters: this.parametersToReplace,\n      context: cfn_parse.CfnParsingContext.RULES,\n    });\n    const ruleProperties = cfnParser.parseValue(this.template.Rules[ruleName]);\n    const rule = new core.CfnRule(this.rulesScope, ruleName, {\n      ruleCondition: ruleProperties.RuleCondition,\n      assertions: ruleProperties.Assertions,\n    });\n    this.rules[ruleName] = rule;\n    this.overrideLogicalIdIfNeeded(rule, ruleName);\n  }\n\n  private createHook(hookName: string): void {\n    const self = this;\n    const cfnParser = new cfn_parse.CfnParser({\n      finder: {\n        findResource(lId): core.CfnResource | undefined {\n          return self.resources[lId];\n        },\n        findRefTarget(elementName: string): core.CfnElement | undefined {\n          return self.resources[elementName] ?? self.parameters[elementName];\n        },\n        findCondition(conditionName: string): core.CfnCondition | undefined {\n          return self.conditions[conditionName];\n        },\n        findMapping(mappingName): core.CfnMapping | undefined {\n          return self.mappings[mappingName];\n        },\n      },\n      parameters: this.parametersToReplace,\n    });\n    const hookAttributes = this.template.Hooks[hookName];\n\n    let hook: core.CfnHook;\n    switch (hookAttributes.Type) {\n      case 'AWS::CodeDeploy::BlueGreen':\n        hook = (core.CfnCodeDeployBlueGreenHook as any)._fromCloudFormation(this.hooksScope, hookName, hookAttributes, {\n          parser: cfnParser,\n        });\n        break;\n      default: {\n        const hookProperties = cfnParser.parseValue(hookAttributes.Properties) ?? {};\n        hook = new core.CfnHook(this.hooksScope, hookName, {\n          type: hookAttributes.Type,\n          properties: hookProperties,\n        });\n      }\n    }\n    this.hooks[hookName] = hook;\n    this.overrideLogicalIdIfNeeded(hook, hookName);\n  }\n\n  private createOutput(logicalId: string, scope: Construct): void {\n    const self = this;\n    const outputAttributes = new cfn_parse.CfnParser({\n      finder: {\n        findResource(lId): core.CfnResource | undefined {\n          return self.resources[lId];\n        },\n        findRefTarget(elementName: string): core.CfnElement | undefined {\n          return self.resources[elementName] ?? self.parameters[elementName];\n        },\n        findCondition(conditionName: string): core.CfnCondition | undefined {\n          return self.conditions[conditionName];\n        },\n        findMapping(mappingName): core.CfnMapping | undefined {\n          return self.mappings[mappingName];\n        },\n      },\n      parameters: this.parametersToReplace,\n    }).parseValue(this.template.Outputs[logicalId]);\n    const cfnOutput = new core.CfnOutput(scope, logicalId, {\n      value: outputAttributes.Value,\n      description: outputAttributes.Description,\n      exportName: outputAttributes.Export ? outputAttributes.Export.Name : undefined,\n      condition: (() => {\n        if (!outputAttributes.Condition) {\n          return undefined;\n        } else if (this.conditions[outputAttributes.Condition]) {\n          return self.getCondition(outputAttributes.Condition);\n        }\n\n        throw new Error(`Output with name '${logicalId}' refers to a Condition with name ` +\n          `'${outputAttributes.Condition}' which was not found in this template`);\n      })(),\n    });\n\n    this.overrideLogicalIdIfNeeded(cfnOutput, logicalId);\n    this.outputs[logicalId] = cfnOutput;\n  }\n\n  private getOrCreateCondition(conditionName: string): core.CfnCondition {\n    if (conditionName in this.conditions) {\n      return this.conditions[conditionName];\n    }\n\n    const self = this;\n    const cfnParser = new cfn_parse.CfnParser({\n      finder: {\n        findResource() { throw new Error('Using GetAtt in Condition definitions is not allowed'); },\n        findRefTarget(elementName: string): core.CfnElement | undefined {\n          // only Parameters can be referenced in the 'Conditions' section\n          return self.parameters[elementName];\n        },\n        findCondition(cName: string): core.CfnCondition | undefined {\n          return cName in (self.template.Conditions || {})\n            ? self.getOrCreateCondition(cName)\n            : undefined;\n        },\n        findMapping(mappingName: string): core.CfnMapping | undefined {\n          return self.mappings[mappingName];\n        },\n      },\n      context: cfn_parse.CfnParsingContext.CONDITIONS,\n      parameters: this.parametersToReplace,\n    });\n    const cfnCondition = new core.CfnCondition(this.conditionsScope, conditionName, {\n      expression: cfnParser.parseValue(this.template.Conditions[conditionName]),\n    });\n\n    this.overrideLogicalIdIfNeeded(cfnCondition, conditionName);\n    this.conditions[conditionName] = cfnCondition;\n    return cfnCondition;\n  }\n\n  private getOrCreateResource(logicalId: string): core.CfnResource {\n    const ret = this.resources[logicalId];\n    if (ret) {\n      return ret;\n    }\n\n    const resourceAttributes: any = this.template.Resources[logicalId];\n\n    // fail early for resource attributes we don't support yet\n    const knownAttributes = [\n      'Condition', 'DependsOn', 'Description', 'Metadata', 'Properties', 'Type', 'Version',\n      'CreationPolicy', 'DeletionPolicy', 'UpdatePolicy', 'UpdateReplacePolicy',\n    ];\n    for (const attribute of Object.keys(resourceAttributes)) {\n      if (!knownAttributes.includes(attribute)) {\n        throw new Error(`The '${attribute}' resource attribute is not supported by cloudformation-include yet. ` +\n          'Either remove it from the template, or use the CdkInclude class from the core package instead.');\n      }\n    }\n\n    const self = this;\n    const finder: cfn_parse.ICfnFinder = {\n      findCondition(conditionName: string): core.CfnCondition | undefined {\n        return self.conditions[conditionName];\n      },\n\n      findMapping(mappingName): core.CfnMapping | undefined {\n        return self.mappings[mappingName];\n      },\n\n      findResource(lId: string): core.CfnResource | undefined {\n        if (!(lId in (self.template.Resources || {}))) {\n          return undefined;\n        }\n        return self.getOrCreateResource(lId);\n      },\n\n      findRefTarget(elementName: string): core.CfnElement | undefined {\n        if (elementName in self.parameters) {\n          return self.parameters[elementName];\n        }\n\n        return this.findResource(elementName);\n      },\n    };\n    const cfnParser = new cfn_parse.CfnParser({\n      finder,\n      parameters: this.parametersToReplace,\n    });\n\n    let l1Instance: core.CfnResource;\n    if (this.nestedStacksToInclude[logicalId]) {\n      l1Instance = this.createNestedStack(logicalId, cfnParser);\n    } else {\n      const l1ClassFqn = cfn_type_to_l1_mapping.lookup(resourceAttributes.Type);\n      // The AWS::CloudFormation::CustomResource type corresponds to the CfnCustomResource class.\n      // Unfortunately, it's quite useless; it only has a single property, ServiceToken.\n      // For that reason, even the CustomResource class from @core doesn't use it!\n      // So, special-case the handling of this one resource type\n      if (l1ClassFqn && resourceAttributes.Type !== 'AWS::CloudFormation::CustomResource') {\n        const options: cfn_parse.FromCloudFormationOptions = {\n          parser: cfnParser,\n        };\n        const [moduleName, ...className] = l1ClassFqn.split('.');\n        const module = require(moduleName); // eslint-disable-line @typescript-eslint/no-require-imports\n        const jsClassFromModule = module[className.join('.')];\n        l1Instance = jsClassFromModule._fromCloudFormation(this, logicalId, resourceAttributes, options);\n      } else {\n        l1Instance = new core.CfnResource(this, logicalId, {\n          type: resourceAttributes.Type,\n          properties: cfnParser.parseValue(resourceAttributes.Properties),\n        });\n        cfnParser.handleAttributes(l1Instance, resourceAttributes, logicalId);\n      }\n    }\n\n    this.overrideLogicalIdIfNeeded(l1Instance, logicalId);\n    this.resources[logicalId] = l1Instance;\n    return l1Instance;\n  }\n\n  private createNestedStack(nestedStackId: string, cfnParser: cfn_parse.CfnParser): core.CfnResource {\n    const templateResources = this.template.Resources || {};\n    const nestedStackAttributes = templateResources[nestedStackId] || {};\n\n    if (nestedStackAttributes.Type !== 'AWS::CloudFormation::Stack') {\n      throw new Error(`Nested Stack with logical ID '${nestedStackId}' is not an AWS::CloudFormation::Stack resource`);\n    }\n    if (nestedStackAttributes.CreationPolicy) {\n      throw new Error('CreationPolicy is not supported by the AWS::CloudFormation::Stack resource');\n    }\n    if (nestedStackAttributes.UpdatePolicy) {\n      throw new Error('UpdatePolicy is not supported by the AWS::CloudFormation::Stack resource');\n    }\n\n    const nestedStackProps = cfnParser.parseValue(nestedStackAttributes.Properties);\n    const nestedStack = new core.NestedStack(this, nestedStackId, {\n      parameters: this.parametersForNestedStack(nestedStackProps.Parameters, nestedStackId),\n      notificationArns: cfn_parse.FromCloudFormation.getStringArray(nestedStackProps.NotificationARNs).value,\n      timeout: this.timeoutForNestedStack(nestedStackProps.TimeoutInMinutes),\n    });\n    const template = new CfnInclude(nestedStack, nestedStackId, this.nestedStacksToInclude[nestedStackId]);\n    this.nestedStacks[nestedStackId] = { stack: nestedStack, includedTemplate: template };\n\n    // we know this is never undefined for nested stacks\n    const nestedStackResource: core.CfnResource = nestedStack.nestedStackResource!;\n    cfnParser.handleAttributes(nestedStackResource, nestedStackAttributes, nestedStackId);\n    return nestedStackResource;\n  }\n\n  private parametersForNestedStack(parameters: any, nestedStackId: string): { [key: string]: string } | undefined {\n    if (parameters == null) {\n      return undefined;\n    }\n\n    const parametersToReplace = this.nestedStacksToInclude[nestedStackId].parameters ?? {};\n    const ret: { [key: string]: string } = {};\n    for (const paramName of Object.keys(parameters)) {\n      if (!(paramName in parametersToReplace)) {\n        ret[paramName] = cfn_parse.FromCloudFormation.getString(parameters[paramName]).value;\n      }\n    }\n    return ret;\n  }\n\n  private timeoutForNestedStack(value: any): core.Duration | undefined {\n    if (value == null) {\n      return undefined;\n    }\n\n    return core.Duration.minutes(cfn_parse.FromCloudFormation.getNumber(value).value);\n  }\n\n  private overrideLogicalIdIfNeeded(element: core.CfnElement, id: string): void {\n    if (this.preserveLogicalIds) {\n      element.overrideLogicalId(id);\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
