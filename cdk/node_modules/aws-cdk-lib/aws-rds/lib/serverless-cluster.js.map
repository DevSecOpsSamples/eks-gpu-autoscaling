{
  "version": 3,
  "sources": ["serverless-cluster.ts"],
  "sourcesContent": ["import * as ec2 from '../../aws-ec2';\nimport * as iam from '../../aws-iam';\nimport * as kms from '../../aws-kms';\nimport * as secretsmanager from '../../aws-secretsmanager';\nimport { Resource, Duration, Token, Annotations, RemovalPolicy, IResource, Stack, Lazy, FeatureFlags, ArnFormat } from '../../core';\nimport * as cxapi from '../../cx-api';\nimport { Construct } from 'constructs';\nimport { IClusterEngine } from './cluster-engine';\nimport { DatabaseSecret } from './database-secret';\nimport { Endpoint } from './endpoint';\nimport { IParameterGroup } from './parameter-group';\nimport { DATA_API_ACTIONS } from './perms';\nimport { applyDefaultRotationOptions, defaultDeletionProtection, renderCredentials } from './private/util';\nimport { Credentials, RotationMultiUserOptions, RotationSingleUserOptions, SnapshotCredentials } from './props';\nimport { CfnDBCluster, CfnDBClusterProps } from './rds.generated';\nimport { ISubnetGroup, SubnetGroup } from './subnet-group';\n\n/**\n  * Interface representing a serverless database cluster.\n  *\n */\nexport interface IServerlessCluster extends IResource, ec2.IConnectable, secretsmanager.ISecretAttachmentTarget {\n  /**\n   * Identifier of the cluster\n   */\n  readonly clusterIdentifier: string;\n\n  /**\n   * The ARN of the cluster\n   */\n  readonly clusterArn: string;\n\n  /**\n   * The endpoint to use for read/write operations\n   * @attribute EndpointAddress,EndpointPort\n   */\n  readonly clusterEndpoint: Endpoint;\n\n  /**\n   * Endpoint to use for load-balanced read-only operations.\n   * @attribute ReadEndpointAddress\n   */\n  readonly clusterReadEndpoint: Endpoint;\n\n  /**\n   * Grant the given identity to access to the Data API.\n   *\n   * @param grantee The principal to grant access to\n   */\n  grantDataApiAccess(grantee: iam.IGrantable): iam.Grant\n}\n/**\n *  Common Properties to configure new Aurora Serverless Cluster or Aurora Serverless Cluster from snapshot\n */\ninterface ServerlessClusterNewProps {\n  /**\n   * What kind of database to start\n   */\n  readonly engine: IClusterEngine;\n\n  /**\n   * An optional identifier for the cluster\n   *\n   * @default - A name is automatically generated.\n   */\n  readonly clusterIdentifier?: string;\n\n  /**\n   * The number of days during which automatic DB snapshots are retained.\n   * Automatic backup retention cannot be disabled on serverless clusters.\n   * Must be a value from 1 day to 35 days.\n   *\n   * @default Duration.days(1)\n   */\n  readonly backupRetention?: Duration;\n\n  /**\n   * Name of a database which is automatically created inside the cluster\n   *\n   * @default - Database is not created in cluster.\n   */\n  readonly defaultDatabaseName?: string;\n\n  /**\n   * Indicates whether the DB cluster should have deletion protection enabled.\n   *\n   * @default - true if removalPolicy is RETAIN, false otherwise\n   */\n  readonly deletionProtection?: boolean;\n\n  /**\n   * Whether to enable the Data API.\n   *\n   * @see https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/data-api.html\n    *\n   * @default false\n   */\n  readonly enableDataApi?: boolean;\n\n  /**\n   * The VPC that this Aurora Serverless cluster has been created in.\n   *\n   * @default - the default VPC in the account and region will be used\n   */\n  readonly vpc?: ec2.IVpc;\n\n  /**\n   * Where to place the instances within the VPC.\n   * If provided, the `vpc` property must also be specified.\n   *\n   * @default - the VPC default strategy if not specified.\n   */\n  readonly vpcSubnets?: ec2.SubnetSelection;\n\n  /**\n   * Scaling configuration of an Aurora Serverless database cluster.\n   *\n   * @default - Serverless cluster is automatically paused after 5 minutes of being idle.\n   *   minimum capacity: 2 ACU\n   *   maximum capacity: 16 ACU\n   */\n  readonly scaling?: ServerlessScalingOptions;\n\n  /**\n   * The removal policy to apply when the cluster and its instances are removed\n   * from the stack or replaced during an update.\n   *\n   * @default - RemovalPolicy.SNAPSHOT (remove the cluster and instances, but retain a snapshot of the data)\n   */\n  readonly removalPolicy?: RemovalPolicy;\n\n  /**\n   * Security group.\n   *\n   * @default - a new security group is created if `vpc` was provided.\n   *   If the `vpc` property was not provided, no VPC security groups will be associated with the DB cluster.\n   */\n  readonly securityGroups?: ec2.ISecurityGroup[];\n\n  /**\n   * Additional parameters to pass to the database engine\n   *\n   * @default - no parameter group.\n   */\n  readonly parameterGroup?: IParameterGroup;\n\n  /**\n   * Existing subnet group for the cluster.\n   *\n   * @default - a new subnet group is created if `vpc` was provided.\n   *   If the `vpc` property was not provided, no subnet group will be associated with the DB cluster\n   */\n  readonly subnetGroup?: ISubnetGroup;\n}\n\n/**\n * Properties that describe an existing cluster instance\n *\n */\nexport interface ServerlessClusterAttributes {\n  /**\n   * Identifier for the cluster\n   */\n  readonly clusterIdentifier: string;\n\n  /**\n   * The database port\n   *\n   * @default - none\n   */\n  readonly port?: number;\n\n  /**\n   * The security groups of the database cluster\n   *\n   * @default - no security groups\n   */\n  readonly securityGroups?: ec2.ISecurityGroup[];\n\n  /**\n   * Cluster endpoint address\n   *\n   * @default - no endpoint address\n   */\n  readonly clusterEndpointAddress?: string;\n\n  /**\n   * Reader endpoint address\n   *\n   * @default - no reader address\n   */\n  readonly readerEndpointAddress?: string;\n\n  /**\n   * The secret attached to the database cluster\n   *\n   * @default - no secret\n   */\n  readonly secret?: secretsmanager.ISecret;\n}\n\n/**\n * Aurora capacity units (ACUs).\n * Each ACU is a combination of processing and memory capacity.\n *\n * @see https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-serverless.setting-capacity.html\n * @see https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-serverless.how-it-works.html#aurora-serverless.architecture\n *\n */\nexport enum AuroraCapacityUnit {\n  /** 1 Aurora Capacity Unit */\n  ACU_1 = 1,\n  /** 2 Aurora Capacity Units */\n  ACU_2 = 2,\n  /** 4 Aurora Capacity Units */\n  ACU_4 = 4,\n  /** 8 Aurora Capacity Units */\n  ACU_8 = 8,\n  /** 16 Aurora Capacity Units */\n  ACU_16 = 16,\n  /** 32 Aurora Capacity Units */\n  ACU_32 = 32,\n  /** 64 Aurora Capacity Units */\n  ACU_64 = 64,\n  /** 128 Aurora Capacity Units */\n  ACU_128 = 128,\n  /** 192 Aurora Capacity Units */\n  ACU_192 = 192,\n  /** 256 Aurora Capacity Units */\n  ACU_256 = 256,\n  /** 384 Aurora Capacity Units */\n  ACU_384 = 384\n}\n\n/**\n * Options for configuring scaling on an Aurora Serverless cluster\n *\n */\nexport interface ServerlessScalingOptions {\n  /**\n   * The minimum capacity for an Aurora Serverless database cluster.\n   *\n   * @default - determined by Aurora based on database engine\n   */\n  readonly minCapacity?: AuroraCapacityUnit;\n\n  /**\n   * The maximum capacity for an Aurora Serverless database cluster.\n   *\n   * @default - determined by Aurora based on database engine\n   */\n  readonly maxCapacity?: AuroraCapacityUnit;\n\n  /**\n   * The time before an Aurora Serverless database cluster is paused.\n   * A database cluster can be paused only when it is idle (it has no connections).\n   * Auto pause time must be between 5 minutes and 1 day.\n   *\n   * If a DB cluster is paused for more than seven days, the DB cluster might be\n   * backed up with a snapshot. In this case, the DB cluster is restored when there\n   * is a request to connect to it.\n   *\n   * Set to 0 to disable\n   *\n   * @default - automatic pause enabled after 5 minutes\n   */\n  readonly autoPause?: Duration;\n}\n\n/**\n * New or imported Serverless Cluster\n */\nabstract class ServerlessClusterBase extends Resource implements IServerlessCluster {\n  /**\n   * Identifier of the cluster\n   */\n  public abstract readonly clusterIdentifier: string;\n\n  /**\n   * The endpoint to use for read/write operations\n   */\n  public abstract readonly clusterEndpoint: Endpoint;\n\n  /**\n   * The endpoint to use for read/write operations\n   */\n  public abstract readonly clusterReadEndpoint: Endpoint;\n\n  /**\n   * Access to the network connections\n   */\n  public abstract readonly connections: ec2.Connections;\n\n  /**\n   * The secret attached to this cluster\n   */\n  public abstract readonly secret?: secretsmanager.ISecret\n\n  protected abstract enableDataApi?: boolean;\n\n  /**\n   * The ARN of the cluster\n   */\n  public get clusterArn(): string {\n    return Stack.of(this).formatArn({\n      service: 'rds',\n      resource: 'cluster',\n      arnFormat: ArnFormat.COLON_RESOURCE_NAME,\n      resourceName: this.clusterIdentifier,\n    });\n  }\n\n  /**\n   * Grant the given identity to access to the Data API, including read access to the secret attached to the cluster if present\n   *\n   * @param grantee The principal to grant access to\n   */\n  public grantDataApiAccess(grantee: iam.IGrantable): iam.Grant {\n    if (this.enableDataApi === false) {\n      throw new Error('Cannot grant Data API access when the Data API is disabled');\n    }\n\n    this.enableDataApi = true;\n    const ret = iam.Grant.addToPrincipal({\n      grantee,\n      actions: DATA_API_ACTIONS,\n      resourceArns: ['*'],\n      scope: this,\n    });\n    this.secret?.grantRead(grantee);\n    return ret;\n  }\n\n  /**\n   * Renders the secret attachment target specifications.\n   */\n  public asSecretAttachmentTarget(): secretsmanager.SecretAttachmentTargetProps {\n    return {\n      targetId: this.clusterIdentifier,\n      targetType: secretsmanager.AttachmentTargetType.RDS_DB_CLUSTER,\n    };\n  }\n}\n\n/**\n * Create an Aurora Serverless Cluster\n *\n * @resource AWS::RDS::DBCluster\n */\nabstract class ServerlessClusterNew extends ServerlessClusterBase {\n  public readonly connections: ec2.Connections;\n  protected readonly newCfnProps: CfnDBClusterProps;\n  protected readonly securityGroups: ec2.ISecurityGroup[];\n  protected enableDataApi?: boolean;\n\n  constructor(scope: Construct, id: string, props: ServerlessClusterNewProps) {\n    super(scope, id);\n\n    if (props.vpc === undefined) {\n      if (props.vpcSubnets !== undefined) {\n        throw new Error('A VPC is required to use vpcSubnets in ServerlessCluster. Please add a VPC or remove vpcSubnets');\n      }\n      if (props.subnetGroup !== undefined) {\n        throw new Error('A VPC is required to use subnetGroup in ServerlessCluster. Please add a VPC or remove subnetGroup');\n      }\n      if (props.securityGroups !== undefined) {\n        throw new Error('A VPC is required to use securityGroups in ServerlessCluster. Please add a VPC or remove securityGroups');\n      }\n    }\n\n    let subnetGroup: ISubnetGroup | undefined = props.subnetGroup;\n    this.securityGroups = props.securityGroups ?? [];\n    if (props.vpc !== undefined) {\n      const { subnetIds } = props.vpc.selectSubnets(props.vpcSubnets);\n\n      // Cannot test whether the subnets are in different AZs, but at least we can test the amount.\n      if (subnetIds.length < 2) {\n        Annotations.of(this).addError(`Cluster requires at least 2 subnets, got ${subnetIds.length}`);\n      }\n\n      subnetGroup = props.subnetGroup ?? new SubnetGroup(this, 'Subnets', {\n        description: `Subnets for ${id} database`,\n        vpc: props.vpc,\n        vpcSubnets: props.vpcSubnets,\n        removalPolicy: props.removalPolicy === RemovalPolicy.RETAIN ? props.removalPolicy : undefined,\n      });\n\n      this.securityGroups = props.securityGroups ?? [\n        new ec2.SecurityGroup(this, 'SecurityGroup', {\n          description: 'RDS security group',\n          vpc: props.vpc,\n        }),\n      ];\n    }\n\n    if (props.backupRetention) {\n      const backupRetentionDays = props.backupRetention.toDays();\n      if (backupRetentionDays < 1 || backupRetentionDays > 35) {\n        throw new Error(`backup retention period must be between 1 and 35 days. received: ${backupRetentionDays}`);\n      }\n    }\n\n    // bind the engine to the Cluster\n    const clusterEngineBindConfig = props.engine.bindToCluster(this, {\n      parameterGroup: props.parameterGroup,\n    });\n    const clusterParameterGroup = props.parameterGroup ?? clusterEngineBindConfig.parameterGroup;\n    const clusterParameterGroupConfig = clusterParameterGroup?.bindToCluster({});\n\n\n    const clusterIdentifier = FeatureFlags.of(this).isEnabled(cxapi.RDS_LOWERCASE_DB_IDENTIFIER)\n      ? props.clusterIdentifier?.toLowerCase()\n      : props.clusterIdentifier;\n\n    this.newCfnProps = {\n      backupRetentionPeriod: props.backupRetention?.toDays(),\n      databaseName: props.defaultDatabaseName,\n      dbClusterIdentifier: clusterIdentifier,\n      dbClusterParameterGroupName: clusterParameterGroupConfig?.parameterGroupName,\n      dbSubnetGroupName: subnetGroup?.subnetGroupName,\n      deletionProtection: defaultDeletionProtection(props.deletionProtection, props.removalPolicy),\n      engine: props.engine.engineType,\n      engineVersion: props.engine.engineVersion?.fullVersion,\n      engineMode: 'serverless',\n      enableHttpEndpoint: Lazy.any({ produce: () => this.enableDataApi }),\n      scalingConfiguration: props.scaling ? this.renderScalingConfiguration(props.scaling) : undefined,\n      storageEncrypted: true,\n      vpcSecurityGroupIds: this.securityGroups.map(sg => sg.securityGroupId),\n    };\n\n    this.connections = new ec2.Connections({\n      securityGroups: this.securityGroups,\n      defaultPort: ec2.Port.tcp(Lazy.number({ produce: () => this.clusterEndpoint.port })),\n    });\n  }\n\n  private renderScalingConfiguration(options: ServerlessScalingOptions): CfnDBCluster.ScalingConfigurationProperty {\n    const minCapacity = options.minCapacity;\n    const maxCapacity = options.maxCapacity;\n\n    if (minCapacity && maxCapacity && minCapacity > maxCapacity) {\n      throw new Error('maximum capacity must be greater than or equal to minimum capacity.');\n    }\n\n    const secondsToAutoPause = options.autoPause?.toSeconds();\n    if (secondsToAutoPause && (secondsToAutoPause < 300 || secondsToAutoPause > 86400)) {\n      throw new Error('auto pause time must be between 5 minutes and 1 day.');\n    }\n\n    return {\n      autoPause: (secondsToAutoPause === 0) ? false : true,\n      minCapacity: options.minCapacity,\n      maxCapacity: options.maxCapacity,\n      secondsUntilAutoPause: (secondsToAutoPause === 0) ? undefined : secondsToAutoPause,\n    };\n  }\n}\n\n/**\n * Properties for a new Aurora Serverless Cluster\n */\nexport interface ServerlessClusterProps extends ServerlessClusterNewProps {\n  /**\n   * Credentials for the administrative user\n   *\n   * @default - A username of 'admin' and SecretsManager-generated password\n   */\n  readonly credentials?: Credentials;\n\n  /**\n   * The KMS key for storage encryption.\n   *\n   * @default - the default master key will be used for storage encryption\n   */\n  readonly storageEncryptionKey?: kms.IKey;\n}\n\n/**\n * Create an Aurora Serverless Cluster\n *\n * @resource AWS::RDS::DBCluster\n *\n */\nexport class ServerlessCluster extends ServerlessClusterNew {\n  /**\n   * Import an existing DatabaseCluster from properties\n   */\n  public static fromServerlessClusterAttributes(\n    scope: Construct, id: string, attrs: ServerlessClusterAttributes,\n  ): IServerlessCluster {\n\n    return new ImportedServerlessCluster(scope, id, attrs);\n  }\n\n  public readonly clusterIdentifier: string;\n  public readonly clusterEndpoint: Endpoint;\n  public readonly clusterReadEndpoint: Endpoint;\n\n  public readonly secret?: secretsmanager.ISecret;\n\n  private readonly vpc?: ec2.IVpc;\n  private readonly vpcSubnets?: ec2.SubnetSelection;\n\n  private readonly singleUserRotationApplication: secretsmanager.SecretRotationApplication;\n  private readonly multiUserRotationApplication: secretsmanager.SecretRotationApplication;\n\n  constructor(scope: Construct, id: string, props: ServerlessClusterProps) {\n    super(scope, id, props);\n\n    this.vpc = props.vpc;\n    this.vpcSubnets = props.vpcSubnets;\n\n    this.singleUserRotationApplication = props.engine.singleUserRotationApplication;\n    this.multiUserRotationApplication = props.engine.multiUserRotationApplication;\n\n    this.enableDataApi = props.enableDataApi;\n\n    const credentials = renderCredentials(this, props.engine, props.credentials);\n    const secret = credentials.secret;\n\n    const cluster = new CfnDBCluster(this, 'Resource', {\n      ...this.newCfnProps,\n      masterUsername: credentials.username,\n      masterUserPassword: credentials.password?.toString(),\n      kmsKeyId: props.storageEncryptionKey?.keyArn,\n    });\n\n    this.clusterIdentifier = cluster.ref;\n\n    // create a number token that represents the port of the cluster\n    const portAttribute = Token.asNumber(cluster.attrEndpointPort);\n    this.clusterEndpoint = new Endpoint(cluster.attrEndpointAddress, portAttribute);\n    this.clusterReadEndpoint = new Endpoint(cluster.attrReadEndpointAddress, portAttribute);\n\n    cluster.applyRemovalPolicy(props.removalPolicy ?? RemovalPolicy.SNAPSHOT);\n\n    if (secret) {\n      this.secret = secret.attach(this);\n    }\n  }\n\n  /**\n   * Adds the single user rotation of the master password to this cluster.\n   */\n  public addRotationSingleUser(options: RotationSingleUserOptions = {}): secretsmanager.SecretRotation {\n    if (!this.secret) {\n      throw new Error('Cannot add single user rotation for a cluster without secret.');\n    }\n\n    if (this.vpc === undefined) {\n      throw new Error('Cannot add single user rotation for a cluster without VPC.');\n    }\n\n    const id = 'RotationSingleUser';\n    const existing = this.node.tryFindChild(id);\n    if (existing) {\n      throw new Error('A single user rotation was already added to this cluster.');\n    }\n\n    return new secretsmanager.SecretRotation(this, id, {\n      ...applyDefaultRotationOptions(options, this.vpcSubnets),\n      secret: this.secret,\n      application: this.singleUserRotationApplication,\n      vpc: this.vpc,\n      target: this,\n    });\n  }\n\n  /**\n   * Adds the multi user rotation to this cluster.\n   */\n  public addRotationMultiUser(id: string, options: RotationMultiUserOptions): secretsmanager.SecretRotation {\n    if (!this.secret) {\n      throw new Error('Cannot add multi user rotation for a cluster without secret.');\n    }\n\n    if (this.vpc === undefined) {\n      throw new Error('Cannot add multi user rotation for a cluster without VPC.');\n    }\n\n    return new secretsmanager.SecretRotation(this, id, {\n      ...applyDefaultRotationOptions(options, this.vpcSubnets),\n      secret: options.secret,\n      masterSecret: this.secret,\n      application: this.multiUserRotationApplication,\n      vpc: this.vpc,\n      target: this,\n    });\n  }\n}\n\n/**\n * Represents an imported database cluster.\n */\nclass ImportedServerlessCluster extends ServerlessClusterBase implements IServerlessCluster {\n  public readonly clusterIdentifier: string;\n  public readonly connections: ec2.Connections;\n\n  public readonly secret?: secretsmanager.ISecret;\n\n  protected readonly enableDataApi = true\n\n  private readonly _clusterEndpoint?: Endpoint;\n  private readonly _clusterReadEndpoint?: Endpoint;\n\n  constructor(scope: Construct, id: string, attrs: ServerlessClusterAttributes) {\n    super(scope, id);\n\n    this.clusterIdentifier = attrs.clusterIdentifier;\n\n    const defaultPort = attrs.port ? ec2.Port.tcp(attrs.port) : undefined;\n    this.connections = new ec2.Connections({\n      securityGroups: attrs.securityGroups,\n      defaultPort,\n    });\n\n    this.secret = attrs.secret;\n\n    this._clusterEndpoint = (attrs.clusterEndpointAddress && attrs.port) ? new Endpoint(attrs.clusterEndpointAddress, attrs.port) : undefined;\n    this._clusterReadEndpoint = (attrs.readerEndpointAddress && attrs.port) ? new Endpoint(attrs.readerEndpointAddress, attrs.port) : undefined;\n  }\n\n  public get clusterEndpoint() {\n    if (!this._clusterEndpoint) {\n      throw new Error('Cannot access `clusterEndpoint` of an imported cluster without an endpoint address and port');\n    }\n    return this._clusterEndpoint;\n  }\n\n  public get clusterReadEndpoint() {\n    if (!this._clusterReadEndpoint) {\n      throw new Error('Cannot access `clusterReadEndpoint` of an imported cluster without a readerEndpointAddress and port');\n    }\n    return this._clusterReadEndpoint;\n  }\n}\n\n/**\n * Properties for ``ServerlessClusterFromSnapshot``\n */\nexport interface ServerlessClusterFromSnapshotProps extends ServerlessClusterNewProps {\n  /**\n   * The identifier for the DB instance snapshot or DB cluster snapshot to restore from.\n   * You can use either the name or the Amazon Resource Name (ARN) to specify a DB cluster snapshot.\n   * However, you can use only the ARN to specify a DB instance snapshot.\n   */\n  readonly snapshotIdentifier: string;\n\n  /**\n   * Master user credentials.\n   *\n   * Note - It is not possible to change the master username for a snapshot;\n   * however, it is possible to provide (or generate) a new password.\n   *\n   * @default - The existing username and password from the snapshot will be used.\n   */\n  readonly credentials?: SnapshotCredentials;\n}\n\n/**\n * A Aurora Serverless Cluster restored from a snapshot.\n *\n * @resource AWS::RDS::DBCluster\n */\nexport class ServerlessClusterFromSnapshot extends ServerlessClusterNew {\n  public readonly clusterIdentifier: string;\n  public readonly clusterEndpoint: Endpoint;\n  public readonly clusterReadEndpoint: Endpoint;\n  public readonly secret?: secretsmanager.ISecret;\n\n  constructor(scope: Construct, id: string, props: ServerlessClusterFromSnapshotProps) {\n    super(scope, id, props);\n\n    this.enableDataApi = props.enableDataApi;\n\n    let credentials = props.credentials;\n    let secret = credentials?.secret;\n    if (!secret && credentials?.generatePassword) {\n      if (!credentials.username) {\n        throw new Error('`credentials` `username` must be specified when `generatePassword` is set to true');\n      }\n\n      secret = new DatabaseSecret(this, 'Secret', {\n        username: credentials.username,\n        encryptionKey: credentials.encryptionKey,\n        excludeCharacters: credentials.excludeCharacters,\n        replaceOnPasswordCriteriaChanges: credentials.replaceOnPasswordCriteriaChanges,\n        replicaRegions: credentials.replicaRegions,\n      });\n    }\n\n    const cluster = new CfnDBCluster(this, 'Resource', {\n      ...this.newCfnProps,\n      snapshotIdentifier: props.snapshotIdentifier,\n      masterUserPassword: secret?.secretValueFromJson('password')?.toString() ?? credentials?.password?.toString(),\n    });\n\n    this.clusterIdentifier = cluster.ref;\n\n    // create a number token that represents the port of the cluster\n    const portAttribute = Token.asNumber(cluster.attrEndpointPort);\n    this.clusterEndpoint = new Endpoint(cluster.attrEndpointAddress, portAttribute);\n    this.clusterReadEndpoint = new Endpoint(cluster.attrReadEndpointAddress, portAttribute);\n\n    cluster.applyRemovalPolicy(props.removalPolicy ?? RemovalPolicy.SNAPSHOT);\n\n    if (secret) {\n      this.secret = secret.attach(this);\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
