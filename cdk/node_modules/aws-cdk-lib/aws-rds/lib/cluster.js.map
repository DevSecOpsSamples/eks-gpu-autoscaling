{
  "version": 3,
  "sources": ["cluster.ts"],
  "sourcesContent": ["import * as ec2 from '../../aws-ec2';\nimport { IRole, ManagedPolicy, Role, ServicePrincipal } from '../../aws-iam';\nimport * as kms from '../../aws-kms';\nimport * as logs from '../../aws-logs';\nimport * as s3 from '../../aws-s3';\nimport * as secretsmanager from '../../aws-secretsmanager';\nimport { Annotations, Duration, FeatureFlags, RemovalPolicy, Resource, Token } from '../../core';\nimport * as cxapi from '../../cx-api';\nimport { Construct } from 'constructs';\nimport { IClusterEngine } from './cluster-engine';\nimport { DatabaseClusterAttributes, IDatabaseCluster } from './cluster-ref';\nimport { Endpoint } from './endpoint';\nimport { IParameterGroup, ParameterGroup } from './parameter-group';\nimport { applyDefaultRotationOptions, defaultDeletionProtection, renderCredentials, setupS3ImportExport, helperRemovalPolicy, renderUnless } from './private/util';\nimport { BackupProps, Credentials, InstanceProps, PerformanceInsightRetention, RotationSingleUserOptions, RotationMultiUserOptions } from './props';\nimport { DatabaseProxy, DatabaseProxyOptions, ProxyTarget } from './proxy';\nimport { CfnDBCluster, CfnDBClusterProps, CfnDBInstance } from './rds.generated';\nimport { ISubnetGroup, SubnetGroup } from './subnet-group';\n\n/**\n * Common properties for a new database cluster or cluster from snapshot.\n */\ninterface DatabaseClusterBaseProps {\n  /**\n   * What kind of database to start\n   */\n  readonly engine: IClusterEngine;\n\n  /**\n   * How many replicas/instances to create\n   *\n   * Has to be at least 1.\n   *\n   * @default 2\n   */\n  readonly instances?: number;\n\n  /**\n   * Settings for the individual instances that are launched\n   */\n  readonly instanceProps: InstanceProps;\n\n  /**\n   * The number of seconds to set a cluster's target backtrack window to.\n   * This feature is only supported by the Aurora MySQL database engine and\n   * cannot be enabled on existing clusters.\n   *\n   * @see https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/AuroraMySQL.Managing.Backtrack.html\n   * @default 0 seconds (no backtrack)\n   */\n  readonly backtrackWindow?: Duration\n\n  /**\n   * Backup settings\n   *\n   * @default - Backup retention period for automated backups is 1 day.\n   * Backup preferred window is set to a 30-minute window selected at random from an\n   * 8-hour block of time for each AWS Region, occurring on a random day of the week.\n   * @see https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_WorkingWithAutomatedBackups.html#USER_WorkingWithAutomatedBackups.BackupWindow\n   */\n  readonly backup?: BackupProps;\n\n  /**\n   * What port to listen on\n   *\n   * @default - The default for the engine is used.\n   */\n  readonly port?: number;\n\n  /**\n   * An optional identifier for the cluster\n   *\n   * @default - A name is automatically generated.\n   */\n  readonly clusterIdentifier?: string;\n\n  /**\n   * Base identifier for instances\n   *\n   * Every replica is named by appending the replica number to this string, 1-based.\n   *\n   * @default - clusterIdentifier is used with the word \"Instance\" appended.\n   * If clusterIdentifier is not provided, the identifier is automatically generated.\n   */\n  readonly instanceIdentifierBase?: string;\n\n  /**\n   * Name of a database which is automatically created inside the cluster\n   *\n   * @default - Database is not created in cluster.\n   */\n  readonly defaultDatabaseName?: string;\n\n  /**\n   * Indicates whether the DB cluster should have deletion protection enabled.\n   *\n   * @default - true if ``removalPolicy`` is RETAIN, false otherwise\n   */\n  readonly deletionProtection?: boolean;\n\n  /**\n   * A preferred maintenance window day/time range. Should be specified as a range ddd:hh24:mi-ddd:hh24:mi (24H Clock UTC).\n   *\n   * Example: 'Sun:23:45-Mon:00:15'\n   *\n   * @default - 30-minute window selected at random from an 8-hour block of time for\n   * each AWS Region, occurring on a random day of the week.\n   * @see https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/USER_UpgradeDBInstance.Maintenance.html#Concepts.DBMaintenance\n   */\n  readonly preferredMaintenanceWindow?: string;\n\n  /**\n   * Additional parameters to pass to the database engine\n   *\n   * @default - No parameter group.\n   */\n  readonly parameterGroup?: IParameterGroup;\n\n  /**\n   * The parameters in the DBClusterParameterGroup to create automatically\n   *\n   * You can only specify parameterGroup or parameters but not both.\n   * You need to use a versioned engine to auto-generate a DBClusterParameterGroup.\n   *\n   * @default - None\n   */\n  readonly parameters?: { [key: string]: string };\n\n  /**\n   * The removal policy to apply when the cluster and its instances are removed\n   * from the stack or replaced during an update.\n   *\n   * @default - RemovalPolicy.SNAPSHOT (remove the cluster and instances, but retain a snapshot of the data)\n   */\n  readonly removalPolicy?: RemovalPolicy;\n\n  /**\n   * The list of log types that need to be enabled for exporting to\n   * CloudWatch Logs.\n   *\n   * @default - no log exports\n   */\n  readonly cloudwatchLogsExports?: string[];\n\n  /**\n   * The number of days log events are kept in CloudWatch Logs. When updating\n   * this property, unsetting it doesn't remove the log retention policy. To\n   * remove the retention policy, set the value to `Infinity`.\n   *\n   * @default - logs never expire\n   */\n  readonly cloudwatchLogsRetention?: logs.RetentionDays;\n\n  /**\n   * The IAM role for the Lambda function associated with the custom resource\n   * that sets the retention policy.\n   *\n   * @default - a new role is created.\n   */\n  readonly cloudwatchLogsRetentionRole?: IRole;\n\n  /**\n   * The interval, in seconds, between points when Amazon RDS collects enhanced\n   * monitoring metrics for the DB instances.\n   *\n   * @default no enhanced monitoring\n   */\n  readonly monitoringInterval?: Duration;\n\n  /**\n   * Role that will be used to manage DB instances monitoring.\n   *\n   * @default - A role is automatically created for you\n   */\n  readonly monitoringRole?: IRole;\n\n  /**\n   * Role that will be associated with this DB cluster to enable S3 import.\n   * This feature is only supported by the Aurora database engine.\n   *\n   * This property must not be used if `s3ImportBuckets` is used.\n   *\n   * For MySQL:\n   * @see https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/AuroraMySQL.Integrating.LoadFromS3.html\n   *\n   * For PostgreSQL:\n   * @see https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/AuroraPostgreSQL.Migrating.html\n   *\n   * @default - New role is created if `s3ImportBuckets` is set, no role is defined otherwise\n   */\n  readonly s3ImportRole?: IRole;\n\n  /**\n   * S3 buckets that you want to load data from. This feature is only supported by the Aurora database engine.\n   *\n   * This property must not be used if `s3ImportRole` is used.\n   *\n   * For MySQL:\n   * @see https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/AuroraMySQL.Integrating.LoadFromS3.html\n   *\n   * For PostgreSQL:\n   * @see https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/AuroraPostgreSQL.Migrating.html\n   *\n   * @default - None\n   */\n  readonly s3ImportBuckets?: s3.IBucket[];\n\n  /**\n   * Role that will be associated with this DB cluster to enable S3 export.\n   * This feature is only supported by the Aurora database engine.\n   *\n   * This property must not be used if `s3ExportBuckets` is used.\n   *\n   * For MySQL:\n   * @see https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/AuroraMySQL.Integrating.SaveIntoS3.html\n   *\n   * For PostgreSQL:\n   * @see https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/postgresql-s3-export.html\n   *\n   * @default - New role is created if `s3ExportBuckets` is set, no role is defined otherwise\n   */\n  readonly s3ExportRole?: IRole;\n\n  /**\n   * S3 buckets that you want to load data into. This feature is only supported by the Aurora database engine.\n   *\n   * This property must not be used if `s3ExportRole` is used.\n   *\n   * For MySQL:\n   * @see https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/AuroraMySQL.Integrating.SaveIntoS3.html\n   *\n   * For PostgreSQL:\n   * @see https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/postgresql-s3-export.html\n   *\n   * @default - None\n   */\n  readonly s3ExportBuckets?: s3.IBucket[];\n\n  /**\n   * Existing subnet group for the cluster.\n   *\n   * @default - a new subnet group will be created.\n   */\n  readonly subnetGroup?: ISubnetGroup;\n\n  /**\n   * Whether to enable mapping of AWS Identity and Access Management (IAM) accounts\n   * to database accounts.\n   *\n   * @default false\n   */\n  readonly iamAuthentication?: boolean;\n\n  /**\n   * Whether to enable storage encryption.\n   *\n   * @default - true if storageEncryptionKey is provided, false otherwise\n   */\n  readonly storageEncrypted?: boolean\n\n  /**\n  * The KMS key for storage encryption.\n  * If specified, {@link storageEncrypted} will be set to `true`.\n  *\n  * @default - if storageEncrypted is true then the default master key, no key otherwise\n  */\n  readonly storageEncryptionKey?: kms.IKey;\n}\n\n/**\n * A new or imported clustered database.\n */\nexport abstract class DatabaseClusterBase extends Resource implements IDatabaseCluster {\n  // only required because of JSII bug: https://github.com/aws/jsii/issues/2040\n  public abstract readonly engine?: IClusterEngine;\n\n  /**\n   * Identifier of the cluster\n   */\n  public abstract readonly clusterIdentifier: string;\n  /**\n   * Identifiers of the replicas\n   */\n  public abstract readonly instanceIdentifiers: string[];\n\n  /**\n   * The endpoint to use for read/write operations\n   */\n  public abstract readonly clusterEndpoint: Endpoint;\n\n  /**\n   * Endpoint to use for load-balanced read-only operations.\n   */\n  public abstract readonly clusterReadEndpoint: Endpoint;\n\n  /**\n   * Endpoints which address each individual replica.\n   */\n  public abstract readonly instanceEndpoints: Endpoint[];\n\n  /**\n   * Access to the network connections\n   */\n  public abstract readonly connections: ec2.Connections;\n\n  /**\n   * Add a new db proxy to this cluster.\n   */\n  public addProxy(id: string, options: DatabaseProxyOptions): DatabaseProxy {\n    return new DatabaseProxy(this, id, {\n      proxyTarget: ProxyTarget.fromCluster(this),\n      ...options,\n    });\n  }\n\n  /**\n   * Renders the secret attachment target specifications.\n   */\n  public asSecretAttachmentTarget(): secretsmanager.SecretAttachmentTargetProps {\n    return {\n      targetId: this.clusterIdentifier,\n      targetType: secretsmanager.AttachmentTargetType.RDS_DB_CLUSTER,\n    };\n  }\n}\n\n/**\n * Abstract base for ``DatabaseCluster`` and ``DatabaseClusterFromSnapshot``\n */\nabstract class DatabaseClusterNew extends DatabaseClusterBase {\n  /**\n   * The engine for this Cluster.\n   * Never undefined.\n   */\n  public readonly engine?: IClusterEngine;\n\n  protected readonly newCfnProps: CfnDBClusterProps;\n  protected readonly securityGroups: ec2.ISecurityGroup[];\n  protected readonly subnetGroup: ISubnetGroup;\n\n  constructor(scope: Construct, id: string, props: DatabaseClusterBaseProps) {\n    super(scope, id);\n\n    const { subnetIds } = props.instanceProps.vpc.selectSubnets(props.instanceProps.vpcSubnets);\n\n    // Cannot test whether the subnets are in different AZs, but at least we can test the amount.\n    if (subnetIds.length < 2) {\n      Annotations.of(this).addError(`Cluster requires at least 2 subnets, got ${subnetIds.length}`);\n    }\n\n    this.subnetGroup = props.subnetGroup ?? new SubnetGroup(this, 'Subnets', {\n      description: `Subnets for ${id} database`,\n      vpc: props.instanceProps.vpc,\n      vpcSubnets: props.instanceProps.vpcSubnets,\n      removalPolicy: renderUnless(helperRemovalPolicy(props.removalPolicy), RemovalPolicy.DESTROY),\n    });\n\n    this.securityGroups = props.instanceProps.securityGroups ?? [\n      new ec2.SecurityGroup(this, 'SecurityGroup', {\n        description: 'RDS security group',\n        vpc: props.instanceProps.vpc,\n      }),\n    ];\n\n    let { s3ImportRole, s3ExportRole } = setupS3ImportExport(this, props, /* combineRoles */ false);\n\n    if (props.parameterGroup && props.parameters) {\n      throw new Error('You cannot specify both parameterGroup and parameters');\n    }\n    const parameterGroup = props.parameterGroup ?? (\n      props.parameters\n        ? new ParameterGroup(this, 'ParameterGroup', {\n          engine: props.engine,\n          parameters: props.parameters,\n        })\n        : undefined\n    );\n    // bind the engine to the Cluster\n    const clusterEngineBindConfig = props.engine.bindToCluster(this, {\n      s3ImportRole,\n      s3ExportRole,\n      parameterGroup,\n    });\n\n    const clusterAssociatedRoles: CfnDBCluster.DBClusterRoleProperty[] = [];\n    if (s3ImportRole) {\n      clusterAssociatedRoles.push({ roleArn: s3ImportRole.roleArn, featureName: clusterEngineBindConfig.features?.s3Import });\n    }\n    if (s3ExportRole) {\n      clusterAssociatedRoles.push({ roleArn: s3ExportRole.roleArn, featureName: clusterEngineBindConfig.features?.s3Export });\n    }\n\n    const clusterParameterGroup = props.parameterGroup ?? clusterEngineBindConfig.parameterGroup;\n    const clusterParameterGroupConfig = clusterParameterGroup?.bindToCluster({});\n    this.engine = props.engine;\n\n    const clusterIdentifier = FeatureFlags.of(this).isEnabled(cxapi.RDS_LOWERCASE_DB_IDENTIFIER)\n      ? props.clusterIdentifier?.toLowerCase()\n      : props.clusterIdentifier;\n\n    this.newCfnProps = {\n      // Basic\n      engine: props.engine.engineType,\n      engineVersion: props.engine.engineVersion?.fullVersion,\n      dbClusterIdentifier: clusterIdentifier,\n      dbSubnetGroupName: this.subnetGroup.subnetGroupName,\n      vpcSecurityGroupIds: this.securityGroups.map(sg => sg.securityGroupId),\n      port: props.port ?? clusterEngineBindConfig.port,\n      dbClusterParameterGroupName: clusterParameterGroupConfig?.parameterGroupName,\n      associatedRoles: clusterAssociatedRoles.length > 0 ? clusterAssociatedRoles : undefined,\n      deletionProtection: defaultDeletionProtection(props.deletionProtection, props.removalPolicy),\n      enableIamDatabaseAuthentication: props.iamAuthentication,\n      // Admin\n      backtrackWindow: props.backtrackWindow?.toSeconds(),\n      backupRetentionPeriod: props.backup?.retention?.toDays(),\n      preferredBackupWindow: props.backup?.preferredWindow,\n      preferredMaintenanceWindow: props.preferredMaintenanceWindow,\n      databaseName: props.defaultDatabaseName,\n      enableCloudwatchLogsExports: props.cloudwatchLogsExports,\n      // Encryption\n      kmsKeyId: props.storageEncryptionKey?.keyArn,\n      storageEncrypted: props.storageEncryptionKey ? true : props.storageEncrypted,\n    };\n  }\n}\n\n/**\n * Represents an imported database cluster.\n */\nclass ImportedDatabaseCluster extends DatabaseClusterBase implements IDatabaseCluster {\n  public readonly clusterIdentifier: string;\n  public readonly connections: ec2.Connections;\n  public readonly engine?: IClusterEngine;\n\n  private readonly _clusterEndpoint?: Endpoint;\n  private readonly _clusterReadEndpoint?: Endpoint;\n  private readonly _instanceIdentifiers?: string[];\n  private readonly _instanceEndpoints?: Endpoint[];\n\n  constructor(scope: Construct, id: string, attrs: DatabaseClusterAttributes) {\n    super(scope, id);\n\n    this.clusterIdentifier = attrs.clusterIdentifier;\n\n    const defaultPort = attrs.port ? ec2.Port.tcp(attrs.port) : undefined;\n    this.connections = new ec2.Connections({\n      securityGroups: attrs.securityGroups,\n      defaultPort,\n    });\n    this.engine = attrs.engine;\n\n    this._clusterEndpoint = (attrs.clusterEndpointAddress && attrs.port) ? new Endpoint(attrs.clusterEndpointAddress, attrs.port) : undefined;\n    this._clusterReadEndpoint = (attrs.readerEndpointAddress && attrs.port) ? new Endpoint(attrs.readerEndpointAddress, attrs.port) : undefined;\n    this._instanceIdentifiers = attrs.instanceIdentifiers;\n    this._instanceEndpoints = (attrs.instanceEndpointAddresses && attrs.port)\n      ? attrs.instanceEndpointAddresses.map(addr => new Endpoint(addr, attrs.port!))\n      : undefined;\n  }\n\n  public get clusterEndpoint() {\n    if (!this._clusterEndpoint) {\n      throw new Error('Cannot access `clusterEndpoint` of an imported cluster without an endpoint address and port');\n    }\n    return this._clusterEndpoint;\n  }\n\n  public get clusterReadEndpoint() {\n    if (!this._clusterReadEndpoint) {\n      throw new Error('Cannot access `clusterReadEndpoint` of an imported cluster without a readerEndpointAddress and port');\n    }\n    return this._clusterReadEndpoint;\n  }\n\n  public get instanceIdentifiers() {\n    if (!this._instanceIdentifiers) {\n      throw new Error('Cannot access `instanceIdentifiers` of an imported cluster without provided instanceIdentifiers');\n    }\n    return this._instanceIdentifiers;\n  }\n\n  public get instanceEndpoints() {\n    if (!this._instanceEndpoints) {\n      throw new Error('Cannot access `instanceEndpoints` of an imported cluster without instanceEndpointAddresses and port');\n    }\n    return this._instanceEndpoints;\n  }\n}\n\n/**\n * Properties for a new database cluster\n */\nexport interface DatabaseClusterProps extends DatabaseClusterBaseProps {\n  /**\n   * Credentials for the administrative user\n   *\n   * @default - A username of 'admin' (or 'postgres' for PostgreSQL) and SecretsManager-generated password\n   */\n  readonly credentials?: Credentials;\n\n  /**\n   * Whether to copy tags to the snapshot when a snapshot is created.\n   *\n   * @default: true\n   */\n  readonly copyTagsToSnapshot?: boolean;\n}\n\n/**\n * Create a clustered database with a given number of instances.\n *\n * @resource AWS::RDS::DBCluster\n */\nexport class DatabaseCluster extends DatabaseClusterNew {\n  /**\n   * Import an existing DatabaseCluster from properties\n   */\n  public static fromDatabaseClusterAttributes(scope: Construct, id: string, attrs: DatabaseClusterAttributes): IDatabaseCluster {\n    return new ImportedDatabaseCluster(scope, id, attrs);\n  }\n\n  public readonly clusterIdentifier: string;\n  public readonly clusterEndpoint: Endpoint;\n  public readonly clusterReadEndpoint: Endpoint;\n  public readonly connections: ec2.Connections;\n  public readonly instanceIdentifiers: string[];\n  public readonly instanceEndpoints: Endpoint[];\n\n  /**\n   * The secret attached to this cluster\n   */\n  public readonly secret?: secretsmanager.ISecret;\n\n  private readonly vpc: ec2.IVpc;\n  private readonly vpcSubnets?: ec2.SubnetSelection;\n\n  private readonly singleUserRotationApplication: secretsmanager.SecretRotationApplication;\n  private readonly multiUserRotationApplication: secretsmanager.SecretRotationApplication;\n\n  constructor(scope: Construct, id: string, props: DatabaseClusterProps) {\n    super(scope, id, props);\n\n    this.vpc = props.instanceProps.vpc;\n    this.vpcSubnets = props.instanceProps.vpcSubnets;\n\n    this.singleUserRotationApplication = props.engine.singleUserRotationApplication;\n    this.multiUserRotationApplication = props.engine.multiUserRotationApplication;\n\n    const credentials = renderCredentials(this, props.engine, props.credentials);\n    const secret = credentials.secret;\n\n    const cluster = new CfnDBCluster(this, 'Resource', {\n      ...this.newCfnProps,\n      // Admin\n      masterUsername: credentials.username,\n      masterUserPassword: credentials.password?.toString(),\n      // Tags\n      copyTagsToSnapshot: props.copyTagsToSnapshot ?? true,\n    });\n\n    this.clusterIdentifier = cluster.ref;\n\n    // create a number token that represents the port of the cluster\n    const portAttribute = Token.asNumber(cluster.attrEndpointPort);\n    this.clusterEndpoint = new Endpoint(cluster.attrEndpointAddress, portAttribute);\n    this.clusterReadEndpoint = new Endpoint(cluster.attrReadEndpointAddress, portAttribute);\n    this.connections = new ec2.Connections({\n      securityGroups: this.securityGroups,\n      defaultPort: ec2.Port.tcp(this.clusterEndpoint.port),\n    });\n\n    cluster.applyRemovalPolicy(props.removalPolicy ?? RemovalPolicy.SNAPSHOT);\n\n    if (secret) {\n      this.secret = secret.attach(this);\n    }\n\n    setLogRetention(this, props);\n    const createdInstances = createInstances(this, props, this.subnetGroup);\n    this.instanceIdentifiers = createdInstances.instanceIdentifiers;\n    this.instanceEndpoints = createdInstances.instanceEndpoints;\n  }\n\n  /**\n   * Adds the single user rotation of the master password to this cluster.\n   */\n  public addRotationSingleUser(options: RotationSingleUserOptions = {}): secretsmanager.SecretRotation {\n    if (!this.secret) {\n      throw new Error('Cannot add single user rotation for a cluster without secret.');\n    }\n\n    const id = 'RotationSingleUser';\n    const existing = this.node.tryFindChild(id);\n    if (existing) {\n      throw new Error('A single user rotation was already added to this cluster.');\n    }\n\n    return new secretsmanager.SecretRotation(this, id, {\n      ...applyDefaultRotationOptions(options, this.vpcSubnets),\n      secret: this.secret,\n      application: this.singleUserRotationApplication,\n      vpc: this.vpc,\n      target: this,\n    });\n  }\n\n  /**\n   * Adds the multi user rotation to this cluster.\n   */\n  public addRotationMultiUser(id: string, options: RotationMultiUserOptions): secretsmanager.SecretRotation {\n    if (!this.secret) {\n      throw new Error('Cannot add multi user rotation for a cluster without secret.');\n    }\n\n    return new secretsmanager.SecretRotation(this, id, {\n      ...applyDefaultRotationOptions(options, this.vpcSubnets),\n      secret: options.secret,\n      masterSecret: this.secret,\n      application: this.multiUserRotationApplication,\n      vpc: this.vpc,\n      target: this,\n    });\n  }\n}\n\n/**\n * Properties for ``DatabaseClusterFromSnapshot``\n */\nexport interface DatabaseClusterFromSnapshotProps extends DatabaseClusterBaseProps {\n  /**\n   * The identifier for the DB instance snapshot or DB cluster snapshot to restore from.\n   * You can use either the name or the Amazon Resource Name (ARN) to specify a DB cluster snapshot.\n   * However, you can use only the ARN to specify a DB instance snapshot.\n   */\n  readonly snapshotIdentifier: string;\n}\n\n/**\n * A database cluster restored from a snapshot.\n *\n * @resource AWS::RDS::DBInstance\n */\nexport class DatabaseClusterFromSnapshot extends DatabaseClusterNew {\n  public readonly clusterIdentifier: string;\n  public readonly clusterEndpoint: Endpoint;\n  public readonly clusterReadEndpoint: Endpoint;\n  public readonly connections: ec2.Connections;\n  public readonly instanceIdentifiers: string[];\n  public readonly instanceEndpoints: Endpoint[];\n\n  constructor(scope: Construct, id: string, props: DatabaseClusterFromSnapshotProps) {\n    super(scope, id, props);\n\n    const cluster = new CfnDBCluster(this, 'Resource', {\n      ...this.newCfnProps,\n      snapshotIdentifier: props.snapshotIdentifier,\n    });\n\n    this.clusterIdentifier = cluster.ref;\n\n    // create a number token that represents the port of the cluster\n    const portAttribute = Token.asNumber(cluster.attrEndpointPort);\n    this.clusterEndpoint = new Endpoint(cluster.attrEndpointAddress, portAttribute);\n    this.clusterReadEndpoint = new Endpoint(cluster.attrReadEndpointAddress, portAttribute);\n    this.connections = new ec2.Connections({\n      securityGroups: this.securityGroups,\n      defaultPort: ec2.Port.tcp(this.clusterEndpoint.port),\n    });\n\n    cluster.applyRemovalPolicy(props.removalPolicy ?? RemovalPolicy.SNAPSHOT);\n\n    setLogRetention(this, props);\n    const createdInstances = createInstances(this, props, this.subnetGroup);\n    this.instanceIdentifiers = createdInstances.instanceIdentifiers;\n    this.instanceEndpoints = createdInstances.instanceEndpoints;\n  }\n}\n\n/**\n * Sets up CloudWatch log retention if configured.\n * A function rather than protected member to prevent exposing ``DatabaseClusterBaseProps``.\n */\nfunction setLogRetention(cluster: DatabaseClusterNew, props: DatabaseClusterBaseProps) {\n  if (props.cloudwatchLogsExports) {\n    const unsupportedLogTypes = props.cloudwatchLogsExports.filter(logType => !props.engine.supportedLogTypes.includes(logType));\n    if (unsupportedLogTypes.length > 0) {\n      throw new Error(`Unsupported logs for the current engine type: ${unsupportedLogTypes.join(',')}`);\n    }\n\n    if (props.cloudwatchLogsRetention) {\n      for (const log of props.cloudwatchLogsExports) {\n        new logs.LogRetention(cluster, `LogRetention${log}`, {\n          logGroupName: `/aws/rds/cluster/${cluster.clusterIdentifier}/${log}`,\n          retention: props.cloudwatchLogsRetention,\n          role: props.cloudwatchLogsRetentionRole,\n        });\n      }\n    }\n  }\n}\n\n/** Output from the createInstances method; used to set instance identifiers and endpoints */\ninterface InstanceConfig {\n  readonly instanceIdentifiers: string[];\n  readonly instanceEndpoints: Endpoint[];\n}\n\n/**\n * Creates the instances for the cluster.\n * A function rather than a protected method on ``DatabaseClusterNew`` to avoid exposing\n * ``DatabaseClusterNew`` and ``DatabaseClusterBaseProps`` in the API.\n */\nfunction createInstances(cluster: DatabaseClusterNew, props: DatabaseClusterBaseProps, subnetGroup: ISubnetGroup): InstanceConfig {\n  const instanceCount = props.instances != null ? props.instances : 2;\n  if (Token.isUnresolved(instanceCount)) {\n    throw new Error('The number of instances an RDS Cluster consists of cannot be provided as a deploy-time only value!');\n  }\n  if (instanceCount < 1) {\n    throw new Error('At least one instance is required');\n  }\n\n  const instanceIdentifiers: string[] = [];\n  const instanceEndpoints: Endpoint[] = [];\n  const portAttribute = cluster.clusterEndpoint.port;\n  const instanceProps = props.instanceProps;\n\n  // Get the actual subnet objects so we can depend on internet connectivity.\n  const internetConnected = instanceProps.vpc.selectSubnets(instanceProps.vpcSubnets).internetConnectivityEstablished;\n\n  let monitoringRole;\n  if (props.monitoringInterval && props.monitoringInterval.toSeconds()) {\n    monitoringRole = props.monitoringRole || new Role(cluster, 'MonitoringRole', {\n      assumedBy: new ServicePrincipal('monitoring.rds.amazonaws.com'),\n      managedPolicies: [\n        ManagedPolicy.fromAwsManagedPolicyName('service-role/AmazonRDSEnhancedMonitoringRole'),\n      ],\n    });\n  }\n\n  const enablePerformanceInsights = instanceProps.enablePerformanceInsights\n    || instanceProps.performanceInsightRetention !== undefined || instanceProps.performanceInsightEncryptionKey !== undefined;\n  if (enablePerformanceInsights && instanceProps.enablePerformanceInsights === false) {\n    throw new Error('`enablePerformanceInsights` disabled, but `performanceInsightRetention` or `performanceInsightEncryptionKey` was set');\n  }\n\n  const instanceType = instanceProps.instanceType ?? ec2.InstanceType.of(ec2.InstanceClass.T3, ec2.InstanceSize.MEDIUM);\n\n  if (instanceProps.parameterGroup && instanceProps.parameters) {\n    throw new Error('You cannot specify both parameterGroup and parameters');\n  }\n\n  const instanceParameterGroup = instanceProps.parameterGroup ?? (\n    instanceProps.parameters\n      ? new ParameterGroup(cluster, 'InstanceParameterGroup', {\n        engine: props.engine,\n        parameters: instanceProps.parameters,\n      })\n      : undefined\n  );\n  const instanceParameterGroupConfig = instanceParameterGroup?.bindToInstance({});\n\n  for (let i = 0; i < instanceCount; i++) {\n    const instanceIndex = i + 1;\n    const instanceIdentifier = props.instanceIdentifierBase != null ? `${props.instanceIdentifierBase}${instanceIndex}` :\n      props.clusterIdentifier != null ? `${props.clusterIdentifier}instance${instanceIndex}` :\n        undefined;\n\n    const instance = new CfnDBInstance(cluster, `Instance${instanceIndex}`, {\n      // Link to cluster\n      engine: props.engine.engineType,\n      engineVersion: props.engine.engineVersion?.fullVersion,\n      dbClusterIdentifier: cluster.clusterIdentifier,\n      dbInstanceIdentifier: instanceIdentifier,\n      // Instance properties\n      dbInstanceClass: databaseInstanceType(instanceType),\n      publiclyAccessible: instanceProps.publiclyAccessible ??\n        (instanceProps.vpcSubnets && instanceProps.vpcSubnets.subnetType === ec2.SubnetType.PUBLIC),\n      enablePerformanceInsights: enablePerformanceInsights || instanceProps.enablePerformanceInsights, // fall back to undefined if not set\n      performanceInsightsKmsKeyId: instanceProps.performanceInsightEncryptionKey?.keyArn,\n      performanceInsightsRetentionPeriod: enablePerformanceInsights\n        ? (instanceProps.performanceInsightRetention || PerformanceInsightRetention.DEFAULT)\n        : undefined,\n      // This is already set on the Cluster. Unclear to me whether it should be repeated or not. Better yes.\n      dbSubnetGroupName: subnetGroup.subnetGroupName,\n      dbParameterGroupName: instanceParameterGroupConfig?.parameterGroupName,\n      monitoringInterval: props.monitoringInterval && props.monitoringInterval.toSeconds(),\n      monitoringRoleArn: monitoringRole && monitoringRole.roleArn,\n      autoMinorVersionUpgrade: props.instanceProps.autoMinorVersionUpgrade,\n      allowMajorVersionUpgrade: props.instanceProps.allowMajorVersionUpgrade,\n      deleteAutomatedBackups: props.instanceProps.deleteAutomatedBackups,\n    });\n\n    // For instances that are part of a cluster:\n    //\n    //  Cluster DESTROY or SNAPSHOT -> DESTROY (snapshot is good enough to recreate)\n    //  Cluster RETAIN              -> RETAIN (otherwise cluster state will disappear)\n    instance.applyRemovalPolicy(helperRemovalPolicy(props.removalPolicy));\n\n    // We must have a dependency on the NAT gateway provider here to create\n    // things in the right order.\n    instance.node.addDependency(internetConnected);\n\n    instanceIdentifiers.push(instance.ref);\n    instanceEndpoints.push(new Endpoint(instance.attrEndpointAddress, portAttribute));\n  }\n\n  return { instanceEndpoints, instanceIdentifiers };\n}\n\n/**\n * Turn a regular instance type into a database instance type\n */\nfunction databaseInstanceType(instanceType: ec2.InstanceType) {\n  return 'db.' + instanceType.toString();\n}\n"],
  "mappings": "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",
  "names": []
}
