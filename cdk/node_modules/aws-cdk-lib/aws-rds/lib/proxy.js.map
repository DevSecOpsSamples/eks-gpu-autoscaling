{
  "version": 3,
  "sources": ["proxy.ts"],
  "sourcesContent": ["import * as ec2 from '../../aws-ec2';\nimport * as iam from '../../aws-iam';\nimport * as secretsmanager from '../../aws-secretsmanager';\nimport * as cdk from '../../core';\nimport { Construct } from 'constructs';\nimport { IDatabaseCluster } from './cluster-ref';\nimport { IEngine } from './engine';\nimport { IDatabaseInstance } from './instance';\nimport { engineDescription } from './private/util';\nimport { CfnDBProxy, CfnDBProxyTargetGroup } from './rds.generated';\n\n/**\n * SessionPinningFilter\n *\n * @see https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/rds-proxy.html#rds-proxy-pinning\n */\nexport class SessionPinningFilter {\n  /**\n   * You can opt out of session pinning for the following kinds of application statements:\n   *\n   * - Setting session variables and configuration settings.\n   */\n  public static readonly EXCLUDE_VARIABLE_SETS = new SessionPinningFilter('EXCLUDE_VARIABLE_SETS');\n\n  /**\n   * custom filter\n   */\n  public static of(filterName: string): SessionPinningFilter {\n    return new SessionPinningFilter(filterName);\n  }\n\n  private constructor(\n    /**\n     * Filter name\n     */\n    public readonly filterName: string,\n  ) {}\n}\n\n/**\n * Proxy target: Instance or Cluster\n *\n * A target group is a collection of databases that the proxy can connect to.\n * Currently, you can specify only one RDS DB instance or Aurora DB cluster.\n */\nexport class ProxyTarget {\n  /**\n   * From instance\n   *\n   * @param instance RDS database instance\n   */\n  public static fromInstance(instance: IDatabaseInstance): ProxyTarget {\n    return new ProxyTarget(instance, undefined);\n  }\n\n  /**\n   * From cluster\n   *\n   * @param cluster RDS database cluster\n   */\n  public static fromCluster(cluster: IDatabaseCluster): ProxyTarget {\n    return new ProxyTarget(undefined, cluster);\n  }\n\n  private constructor(\n    private readonly dbInstance: IDatabaseInstance | undefined,\n    private readonly dbCluster: IDatabaseCluster | undefined) {\n  }\n\n  /**\n   * Bind this target to the specified database proxy.\n   */\n  public bind(proxy: DatabaseProxy): ProxyTargetConfig {\n    const engine: IEngine | undefined = this.dbInstance?.engine ?? this.dbCluster?.engine;\n\n    if (!engine) {\n      const errorResource = this.dbCluster ?? this.dbInstance;\n      throw new Error(`Could not determine engine for proxy target '${errorResource?.node.path}'. ` +\n        'Please provide it explicitly when importing the resource');\n    }\n\n    const engineFamily = engine.engineFamily;\n    if (!engineFamily) {\n      throw new Error(`Engine '${engineDescription(engine)}' does not support proxies`);\n    }\n\n    // allow connecting to the Cluster/Instance from the Proxy\n    this.dbCluster?.connections.allowDefaultPortFrom(proxy, 'Allow connections to the database Cluster from the Proxy');\n    this.dbInstance?.connections.allowDefaultPortFrom(proxy, 'Allow connections to the database Instance from the Proxy');\n\n    return {\n      engineFamily,\n      dbClusters: this.dbCluster ? [this.dbCluster] : undefined,\n      dbInstances: this.dbInstance ? [this.dbInstance] : undefined,\n    };\n  }\n}\n\n/**\n * The result of binding a `ProxyTarget` to a `DatabaseProxy`.\n */\nexport interface ProxyTargetConfig {\n  /**\n   * The engine family of the database instance or cluster this proxy connects with.\n   */\n  readonly engineFamily: string;\n\n  /**\n   * The database instances to which this proxy connects.\n   * Either this or `dbClusters` will be set and the other `undefined`.\n   * @default - `undefined` if `dbClusters` is set.\n   */\n  readonly dbInstances?: IDatabaseInstance[];\n\n  /**\n   * The database clusters to which this proxy connects.\n   * Either this or `dbInstances` will be set and the other `undefined`.\n   * @default - `undefined` if `dbInstances` is set.\n   */\n  readonly dbClusters?: IDatabaseCluster[];\n}\n\n/**\n * Options for a new DatabaseProxy\n */\nexport interface DatabaseProxyOptions {\n  /**\n   * The identifier for the proxy.\n   * This name must be unique for all proxies owned by your AWS account in the specified AWS Region.\n   * An identifier must begin with a letter and must contain only ASCII letters, digits, and hyphens;\n   * it can't end with a hyphen or contain two consecutive hyphens.\n   *\n   * @default - Generated by CloudFormation (recommended)\n   */\n  readonly dbProxyName?: string;\n\n  /**\n   * The duration for a proxy to wait for a connection to become available in the connection pool.\n   * Only applies when the proxy has opened its maximum number of connections and all connections are busy with client\n   * sessions.\n   *\n   * Value must be between 1 second and 1 hour, or `Duration.seconds(0)` to represent unlimited.\n   *\n   * @default cdk.Duration.seconds(120)\n   */\n  readonly borrowTimeout?: cdk.Duration;\n\n  /**\n   * One or more SQL statements for the proxy to run when opening each new database connection.\n   * Typically used with SET statements to make sure that each connection has identical settings such as time zone\n   * and character set.\n   * For multiple statements, use semicolons as the separator.\n   * You can also include multiple variables in a single SET statement, such as SET x=1, y=2.\n   *\n   * not currently supported for PostgreSQL.\n   *\n   * @default - no initialization query\n   */\n  readonly initQuery?: string;\n\n  /**\n   * The maximum size of the connection pool for each target in a target group.\n   * For Aurora MySQL, it is expressed as a percentage of the max_connections setting for the RDS DB instance or Aurora DB\n   * cluster used by the target group.\n   *\n   * 1-100\n   *\n   * @default 100\n   */\n  readonly maxConnectionsPercent?: number;\n\n  /**\n   * Controls how actively the proxy closes idle database connections in the connection pool.\n   * A high value enables the proxy to leave a high percentage of idle connections open.\n   * A low value causes the proxy to close idle client connections and return the underlying database connections\n   * to the connection pool.\n   * For Aurora MySQL, it is expressed as a percentage of the max_connections setting for the RDS DB instance\n   * or Aurora DB cluster used by the target group.\n   *\n   * between 0 and MaxConnectionsPercent\n   *\n   * @default 50\n   */\n  readonly maxIdleConnectionsPercent?: number;\n\n  /**\n   * Each item in the list represents a class of SQL operations that normally cause all later statements in a session\n   * using a proxy to be pinned to the same underlying database connection.\n   * Including an item in the list exempts that class of SQL operations from the pinning behavior.\n   *\n   * @default - no session pinning filters\n   */\n  readonly sessionPinningFilters?: SessionPinningFilter[];\n\n  /**\n   * Whether the proxy includes detailed information about SQL statements in its logs.\n   * This information helps you to debug issues involving SQL behavior or the performance and scalability of the proxy connections.\n   * The debug information includes the text of SQL statements that you submit through the proxy.\n   * Thus, only enable this setting when needed for debugging, and only when you have security measures in place to safeguard any sensitive\n   * information that appears in the logs.\n   *\n   * @default false\n   */\n  readonly debugLogging?: boolean;\n\n  /**\n   * Whether to require or disallow AWS Identity and Access Management (IAM) authentication for connections to the proxy.\n   *\n   * @default false\n   */\n  readonly iamAuth?: boolean;\n\n  /**\n   * The number of seconds that a connection to the proxy can be inactive before the proxy disconnects it.\n   * You can set this value higher or lower than the connection timeout limit for the associated database.\n   *\n   * @default cdk.Duration.minutes(30)\n   */\n  readonly idleClientTimeout?: cdk.Duration;\n\n  /**\n   * A Boolean parameter that specifies whether Transport Layer Security (TLS) encryption is required for connections to the proxy.\n   * By enabling this setting, you can enforce encrypted TLS connections to the proxy.\n   *\n   * @default true\n   */\n  readonly requireTLS?: boolean;\n\n  /**\n   * IAM role that the proxy uses to access secrets in AWS Secrets Manager.\n   *\n   * @default - A role will automatically be created\n   */\n  readonly role?: iam.IRole;\n\n  /**\n   * The secret that the proxy uses to authenticate to the RDS DB instance or Aurora DB cluster.\n   * These secrets are stored within Amazon Secrets Manager.\n   * One or more secrets are required.\n   */\n  readonly secrets: secretsmanager.ISecret[];\n\n  /**\n   * One or more VPC security groups to associate with the new proxy.\n   *\n   * @default - No security groups\n   */\n  readonly securityGroups?: ec2.ISecurityGroup[];\n\n  /**\n   * The subnets used by the proxy.\n   *\n   * @default - the VPC default strategy if not specified.\n   */\n  readonly vpcSubnets?: ec2.SubnetSelection;\n\n  /**\n   * The VPC to associate with the new proxy.\n   */\n  readonly vpc: ec2.IVpc;\n}\n\n/**\n * Construction properties for a DatabaseProxy\n */\nexport interface DatabaseProxyProps extends DatabaseProxyOptions {\n  /**\n   * DB proxy target: Instance or Cluster\n   */\n  readonly proxyTarget: ProxyTarget\n}\n\n/**\n * Properties that describe an existing DB Proxy\n */\nexport interface DatabaseProxyAttributes {\n  /**\n   * DB Proxy Name\n   */\n  readonly dbProxyName: string;\n\n  /**\n   * DB Proxy ARN\n   */\n  readonly dbProxyArn: string;\n\n  /**\n   * Endpoint\n   */\n  readonly endpoint: string;\n\n  /**\n   * The security groups of the instance.\n   */\n  readonly securityGroups: ec2.ISecurityGroup[];\n}\n\n/**\n * DB Proxy\n */\nexport interface IDatabaseProxy extends cdk.IResource {\n  /**\n   * DB Proxy Name\n   *\n   * @attribute\n   */\n  readonly dbProxyName: string;\n\n  /**\n   * DB Proxy ARN\n   *\n   * @attribute\n   */\n  readonly dbProxyArn: string;\n\n  /**\n   * Endpoint\n   *\n   * @attribute\n   */\n  readonly endpoint: string;\n\n  /**\n   * Grant the given identity connection access to the proxy.\n   *\n   * @param grantee the Principal to grant the permissions to\n   * @param dbUser the name of the database user to allow connecting as to the proxy\n   *\n   * @default - if the Proxy had been provided a single Secret value,\n   *   the user will be taken from that Secret\n   */\n  grantConnect(grantee: iam.IGrantable, dbUser?: string): iam.Grant;\n}\n\n/**\n * Represents an RDS Database Proxy.\n *\n */\nabstract class DatabaseProxyBase extends cdk.Resource implements IDatabaseProxy {\n  public abstract readonly dbProxyName: string;\n  public abstract readonly dbProxyArn: string;\n  public abstract readonly endpoint: string;\n\n  public grantConnect(grantee: iam.IGrantable, dbUser?: string): iam.Grant {\n    if (!dbUser) {\n      throw new Error('For imported Database Proxies, the dbUser is required in grantConnect()');\n    }\n    const scopeStack = cdk.Stack.of(this);\n    const proxyGeneratedId = scopeStack.splitArn(this.dbProxyArn, cdk.ArnFormat.COLON_RESOURCE_NAME).resourceName;\n    const userArn = scopeStack.formatArn({\n      service: 'rds-db',\n      resource: 'dbuser',\n      resourceName: `${proxyGeneratedId}/${dbUser}`,\n      arnFormat: cdk.ArnFormat.COLON_RESOURCE_NAME,\n    });\n    return iam.Grant.addToPrincipal({\n      grantee,\n      actions: ['rds-db:connect'],\n      resourceArns: [userArn],\n    });\n  }\n}\n\n/**\n * RDS Database Proxy\n *\n * @resource AWS::RDS::DBProxy\n */\nexport class DatabaseProxy extends DatabaseProxyBase\n  implements ec2.IConnectable, secretsmanager.ISecretAttachmentTarget {\n  /**\n   * Import an existing database proxy.\n   */\n  public static fromDatabaseProxyAttributes(\n    scope: Construct,\n    id: string,\n    attrs: DatabaseProxyAttributes,\n  ): IDatabaseProxy {\n    class Import extends DatabaseProxyBase {\n      public readonly dbProxyName = attrs.dbProxyName;\n      public readonly dbProxyArn = attrs.dbProxyArn;\n      public readonly endpoint = attrs.endpoint;\n    }\n    return new Import(scope, id);\n  }\n\n  /**\n   * DB Proxy Name\n   *\n   * @attribute\n   */\n  public readonly dbProxyName: string;\n\n  /**\n   * DB Proxy ARN\n   *\n   * @attribute\n   */\n  public readonly dbProxyArn: string;\n\n  /**\n   * Endpoint\n   *\n   * @attribute\n   */\n  public readonly endpoint: string;\n\n  /**\n   * Access to network connections.\n   */\n  public readonly connections: ec2.Connections;\n\n  private readonly secrets: secretsmanager.ISecret[];\n  private readonly resource: CfnDBProxy;\n\n  constructor(scope: Construct, id: string, props: DatabaseProxyProps) {\n    super(scope, id, { physicalName: props.dbProxyName || id });\n\n    const role = props.role || new iam.Role(this, 'IAMRole', {\n      assumedBy: new iam.ServicePrincipal('rds.amazonaws.com'),\n    });\n\n    for (const secret of props.secrets) {\n      secret.grantRead(role);\n    }\n\n    const securityGroups = props.securityGroups ?? [\n      new ec2.SecurityGroup(this, 'ProxySecurityGroup', {\n        description: 'SecurityGroup for Database Proxy',\n        vpc: props.vpc,\n      }),\n    ];\n    this.connections = new ec2.Connections({ securityGroups });\n\n    const bindResult = props.proxyTarget.bind(this);\n\n    if (props.secrets.length < 1) {\n      throw new Error('One or more secrets are required.');\n    }\n    this.secrets = props.secrets;\n\n    this.resource = new CfnDBProxy(this, 'Resource', {\n      auth: props.secrets.map(_ => {\n        return {\n          authScheme: 'SECRETS',\n          iamAuth: props.iamAuth ? 'REQUIRED' : 'DISABLED',\n          secretArn: _.secretArn,\n        };\n      }),\n      dbProxyName: this.physicalName,\n      debugLogging: props.debugLogging,\n      engineFamily: bindResult.engineFamily,\n      idleClientTimeout: props.idleClientTimeout?.toSeconds(),\n      requireTls: props.requireTLS ?? true,\n      roleArn: role.roleArn,\n      vpcSecurityGroupIds: cdk.Lazy.list({ produce: () => this.connections.securityGroups.map(_ => _.securityGroupId) }),\n      vpcSubnetIds: props.vpc.selectSubnets(props.vpcSubnets).subnetIds,\n    });\n\n    this.dbProxyName = this.resource.ref;\n    this.dbProxyArn = this.resource.attrDbProxyArn;\n    this.endpoint = this.resource.attrEndpoint;\n\n    let dbInstanceIdentifiers: string[] | undefined;\n    if (bindResult.dbInstances) {\n      // support for only single instance\n      dbInstanceIdentifiers = [bindResult.dbInstances[0].instanceIdentifier];\n    }\n\n    let dbClusterIdentifiers: string[] | undefined;\n    if (bindResult.dbClusters) {\n      dbClusterIdentifiers = bindResult.dbClusters.map((c) => c.clusterIdentifier);\n    }\n\n    if (!!dbInstanceIdentifiers && !!dbClusterIdentifiers) {\n      throw new Error('Cannot specify both dbInstanceIdentifiers and dbClusterIdentifiers');\n    }\n\n    const proxyTargetGroup = new CfnDBProxyTargetGroup(this, 'ProxyTargetGroup', {\n      targetGroupName: 'default',\n      dbProxyName: this.dbProxyName,\n      dbInstanceIdentifiers,\n      dbClusterIdentifiers,\n      connectionPoolConfigurationInfo: toConnectionPoolConfigurationInfo(props),\n    });\n\n    bindResult.dbClusters?.forEach((c) => proxyTargetGroup.node.addDependency(c));\n  }\n\n  /**\n   * Renders the secret attachment target specifications.\n   */\n  public asSecretAttachmentTarget(): secretsmanager.SecretAttachmentTargetProps {\n    return {\n      targetId: this.dbProxyName,\n      targetType: secretsmanager.AttachmentTargetType.RDS_DB_PROXY,\n    };\n  }\n\n  public grantConnect(grantee: iam.IGrantable, dbUser?: string): iam.Grant {\n    if (!dbUser) {\n      if (this.secrets.length > 1) {\n        throw new Error('When the Proxy contains multiple Secrets, you must pass a dbUser explicitly to grantConnect()');\n      }\n      // 'username' is the field RDS uses here,\n      // see https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/rds-proxy.html#rds-proxy-secrets-arns\n      dbUser = this.secrets[0].secretValueFromJson('username').toString();\n    }\n    return super.grantConnect(grantee, dbUser);\n  }\n}\n\n/**\n * ConnectionPoolConfiguration (L2 => L1)\n */\nfunction toConnectionPoolConfigurationInfo(\n  props: DatabaseProxyProps,\n): CfnDBProxyTargetGroup.ConnectionPoolConfigurationInfoFormatProperty {\n  return {\n    connectionBorrowTimeout: props.borrowTimeout?.toSeconds(),\n    initQuery: props.initQuery,\n    maxConnectionsPercent: props.maxConnectionsPercent,\n    maxIdleConnectionsPercent: props.maxIdleConnectionsPercent,\n    sessionPinningFilters: props.sessionPinningFilters?.map(_ => _.filterName),\n  };\n}\n"],
  "mappings": "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",
  "names": []
}
