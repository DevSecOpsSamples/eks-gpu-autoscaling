{
  "version": 3,
  "sources": ["rendering.ts"],
  "sourcesContent": ["import { IMetric } from '../metric-types';\nimport { DropEmptyObjectAtTheEndOfAnArray } from './drop-empty-object-at-the-end-of-an-array-token';\nimport { accountIfDifferentFromStack, regionIfDifferentFromStack } from './env-tokens';\nimport { dispatchMetric, metricKey } from './metric-util';\nimport { dropUndefined } from './object';\n\n/**\n * Return the JSON structure which represents these metrics in a graph.\n *\n * Depending on the metric type (stat or expression), one `Metric` object\n * can render to multiple time series.\n *\n * - Top-level metrics will be rendered visibly, additionally added metrics will\n *   be rendered invisibly.\n * - IDs used in math expressions need to be either globally unique, or refer to the same\n *   metric object.\n *\n * This will be called by GraphWidget, no need for clients to call this.\n */\nexport function allMetricsGraphJson(left: IMetric[], right: IMetric[]): any[] {\n  // Add metrics to a set which will automatically expand them recursively,\n  // making sure to retain conflicting the visible one on conflicting metrics objects.\n  const mset = new MetricSet<string>();\n  mset.addTopLevel('left', ...left);\n  mset.addTopLevel('right', ...right);\n\n  // Render all metrics from the set.\n  return mset.entries.map(entry => new DropEmptyObjectAtTheEndOfAnArray(metricGraphJson(entry.metric, entry.tag, entry.id)));\n}\n\nfunction metricGraphJson(metric: IMetric, yAxis?: string, id?: string) {\n  const config = metric.toMetricConfig();\n\n  const ret: any[] = [];\n  const options: any = { ...config.renderingProperties };\n\n  dispatchMetric(metric, {\n    withStat(stat) {\n      ret.push(\n        stat.namespace,\n        stat.metricName,\n      );\n\n      // Dimensions\n      for (const dim of (stat.dimensions || [])) {\n        ret.push(dim.name, dim.value);\n      }\n\n      // Metric attributes that are rendered to graph options\n      if (stat.account) { options.accountId = accountIfDifferentFromStack(stat.account); }\n      if (stat.region) { options.region = regionIfDifferentFromStack(stat.region); }\n      if (stat.period && stat.period.toSeconds() !== 300) { options.period = stat.period.toSeconds(); }\n      if (stat.statistic && stat.statistic !== 'Average') { options.stat = stat.statistic; }\n    },\n\n    withExpression(expr) {\n      options.expression = expr.expression;\n      if (expr.searchAccount) { options.accountId = accountIfDifferentFromStack(expr.searchAccount); }\n      if (expr.searchRegion) { options.region = regionIfDifferentFromStack(expr.searchRegion); }\n      if (expr.period && expr.period !== 300) { options.period = expr.period; }\n    },\n  });\n\n  // Options\n  if (!yAxis) { options.visible = false; }\n  if (yAxis !== 'left') { options.yAxis = yAxis; }\n  if (id) { options.id = id; }\n\n  if (options.visible !== false && options.expression && !options.label) {\n    // Label may be '' or undefined.\n    //\n    // If undefined, we'll render the expression as the label, to suppress\n    // the default behavior of CW where it would render the metric\n    // id as label, which we (inelegantly) generate to be something like \"metric_alias0\".\n    //\n    // For array expressions (returning more than 1 TS) users may sometimes want to\n    // suppress the label completely. For those cases, we'll accept the empty string,\n    // and not render a label at all.\n    options.label = options.label === '' ? undefined : metric.toString();\n  }\n\n  const renderedOpts = dropUndefined(options);\n\n  if (Object.keys(renderedOpts).length !== 0) {\n    ret.push(renderedOpts);\n  }\n  return ret;\n}\n\n/**\n * A single metric in a MetricSet\n */\nexport interface MetricEntry<A> {\n  /**\n   * The metric object\n   */\n  readonly metric: IMetric;\n\n  /**\n   * The tag, added if the object is a primary metric\n   */\n  tag?: A;\n\n  /**\n   * ID for this metric object\n   */\n  id?: string;\n}\n\n/**\n * Contain a set of metrics, expanding math expressions\n *\n * \"Primary\" metrics (added via a top-level call) can be tagged with an additional value.\n */\nexport class MetricSet<A> {\n  private readonly metrics = new Array<MetricEntry<A>>();\n  private readonly metricById = new Map<string, MetricEntry<A>>();\n  private readonly metricByKey = new Map<string, MetricEntry<A>>();\n\n  /**\n   * Add the given set of metrics to this set\n   */\n  public addTopLevel(tag: A, ...metrics: IMetric[]) {\n    for (const metric of metrics) {\n      this.addOne(metric, tag);\n    }\n  }\n\n  /**\n   * Access all the accumulated timeseries entries\n   */\n  public get entries(): ReadonlyArray<MetricEntry<A>> {\n    return this.metrics;\n  }\n\n  /**\n   * Add a metric into the set\n   *\n   * The id may not be the same as a previous metric added, unless it's the same metric.\n   *\n   * It can be made visible, in which case the new \"metric\" object replaces the old\n   * one (and the new ones \"renderingPropertieS\" will be honored instead of the old\n   * one's).\n   */\n  private addOne(metric: IMetric, tag?: A, id?: string) {\n    const key = metricKey(metric);\n\n    let existingEntry: MetricEntry<A> | undefined;\n\n    // Try lookup existing by id if we have one\n    if (id) {\n      existingEntry = this.metricById.get(id);\n      if (existingEntry && metricKey(existingEntry.metric) !== key) {\n        throw new Error(`Cannot have two different metrics share the same id ('${id}') in one Alarm or Graph. Rename one of them.`);\n      }\n    }\n\n    if (!existingEntry) {\n      // Try lookup by metric if we didn't find one by id\n      existingEntry = this.metricByKey.get(key);\n\n      // If the one we found already has an id, it must be different from the id\n      // we're trying to add and we want to add a new metric. Pretend we didn't\n      // find one.\n      if (existingEntry?.id && id) { existingEntry = undefined; }\n    }\n\n    // Create a new entry if we didn't find one so far\n    let entry;\n    if (existingEntry) {\n      entry = existingEntry;\n    } else {\n      entry = { metric };\n      this.metrics.push(entry);\n      this.metricByKey.set(key, entry);\n    }\n\n    // If it didn't have an id but now we do, add one\n    if (!entry.id && id) {\n      entry.id = id;\n      this.metricById.set(id, entry);\n    }\n\n    // If it didn't have a tag but now we do, add one\n    if (!entry.tag && tag) {\n      entry.tag = tag;\n    }\n\n    // Recurse and add children\n    const conf = metric.toMetricConfig();\n    if (conf.mathExpression) {\n      for (const [subId, subMetric] of Object.entries(conf.mathExpression.usingMetrics)) {\n        this.addOne(subMetric, undefined, subId);\n      }\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
