{
  "version": 3,
  "sources": ["metric-util.ts"],
  "sourcesContent": ["import { Duration } from '../../../core';\nimport { MathExpression } from '../metric';\nimport { IMetric, MetricConfig, MetricExpressionConfig, MetricStatConfig } from '../metric-types';\n\nconst METRICKEY_SYMBOL = Symbol('@aws-cdk/aws-cloudwatch.MetricKey');\n\n/**\n * Return a unique string representation for this metric.\n *\n * Can be used to determine as a hash key to determine if 2 Metric objects\n * represent the same metric. Excludes rendering properties.\n */\nexport function metricKey(metric: IMetric): string {\n  // Cache on the object itself. This is safe because Metric objects are immutable.\n  if (metric.hasOwnProperty(METRICKEY_SYMBOL)) {\n    return (metric as any)[METRICKEY_SYMBOL];\n  }\n\n  const parts = new Array<string>();\n\n  const conf = metric.toMetricConfig();\n  if (conf.mathExpression) {\n    parts.push(conf.mathExpression.expression);\n    for (const id of Object.keys(conf.mathExpression.usingMetrics).sort()) {\n      parts.push(id);\n      parts.push(metricKey(conf.mathExpression.usingMetrics[id]));\n    }\n    if (conf.mathExpression.searchRegion) {\n      parts.push(conf.mathExpression.searchRegion);\n    }\n    if (conf.mathExpression.searchAccount) {\n      parts.push(conf.mathExpression.searchAccount);\n    }\n  }\n  if (conf.metricStat) {\n    parts.push(conf.metricStat.namespace);\n    parts.push(conf.metricStat.metricName);\n    for (const dim of conf.metricStat.dimensions || []) {\n      parts.push(dim.name);\n      parts.push(dim.value);\n    }\n    if (conf.metricStat.statistic) {\n      parts.push(conf.metricStat.statistic);\n    }\n    if (conf.metricStat.period) {\n      parts.push(`${conf.metricStat.period.toSeconds()}`);\n    }\n    if (conf.metricStat.region) {\n      parts.push(conf.metricStat.region);\n    }\n    if (conf.metricStat.account) {\n      parts.push(conf.metricStat.account);\n    }\n  }\n\n  const ret = parts.join('|');\n  Object.defineProperty(metric, METRICKEY_SYMBOL, { value: ret });\n  return ret;\n}\n\n/**\n * Return the period of a metric\n *\n * For a stat metric, return the immediate period.\n *\n * For an expression metric, all metrics used in it have been made to have the\n * same period, so we return the period of the first inner metric.\n */\nexport function metricPeriod(metric: IMetric): Duration {\n  return dispatchMetric(metric, {\n    withStat(stat) {\n      return stat.period;\n    },\n    withExpression() {\n      return (metric as MathExpression).period || Duration.minutes(5);\n    },\n  });\n}\n\n/**\n * Given a metric object, inspect it and call the correct function for the type of output\n *\n * In addition to the metric object itself, takes a callback object with two\n * methods, to be invoked for the particular type of metric.\n *\n * If the metric represent a metric query (nominally generated through an\n * instantiation of `Metric` but can be generated by any class that implements\n * `IMetric`) a particular field in its `toMetricConfig()` output will be set\n * (to wit, `metricStat`) and the `withStat()` callback will be called with\n * that object.\n *\n * If the metric represents an expression (usually by instantiating `MathExpression`\n * but users can implement `IMetric` arbitrarily) the `mathExpression` field\n * will be set in the object returned from `toMetricConfig` and the callback\n * called `withExpression` will be applied to that object.\n *\n * Will return the values returned by the callbacks.\n *\n * To be used as such:\n *\n * ```ts\n * const ret = dispatchMetric(someMetric, {\n *   withStat(stat) {\n *     // do something with stat\n *     return 1;\n *   },\n *   withExpression(expr) {\n *     // do something with expr\n *     return 2;\n *   },\n * });\n * ```\n *\n * This function encapsulates some type analysis that would otherwise have to be\n * repeated in all places where code needs to make a distinction on the type\n * of metric object that is being passed.\n */\n// eslint-disable-next-line max-len\nexport function dispatchMetric<A, B>(metric: IMetric, fns: { withStat: (x: MetricStatConfig, c: MetricConfig) => A, withExpression: (x: MetricExpressionConfig, c: MetricConfig) => B }): A | B {\n  const conf = metric.toMetricConfig();\n  if (conf.metricStat && conf.mathExpression) {\n    throw new Error('Metric object must not produce both \\'metricStat\\' and \\'mathExpression\\'');\n  } else if (conf.metricStat) {\n    return fns.withStat(conf.metricStat, conf);\n  } else if (conf.mathExpression) {\n    return fns.withExpression(conf.mathExpression, conf);\n  } else {\n    throw new Error('Metric object must have either \\'metricStat\\' or \\'mathExpression\\'');\n  }\n}"],
  "mappings": "yIAAA,KAAA,QAAA,QAAA,eAAA,EAIM,iBAAmB,OAAO,mCAAmC,EAQnE,mBAA0B,OAAe,CAEvC,GAAI,OAAO,eAAe,gBAAgB,EACxC,MAAQ,QAAe,kBAGzB,KAAM,OAAQ,GAAI,OAEZ,KAAO,OAAO,eAAc,EAClC,GAAI,KAAK,eAAgB,CACvB,MAAM,KAAK,KAAK,eAAe,UAAU,EACzC,SAAW,MAAM,QAAO,KAAK,KAAK,eAAe,YAAY,EAAE,KAAI,EACjE,MAAM,KAAK,EAAE,EACb,MAAM,KAAK,UAAU,KAAK,eAAe,aAAa,GAAG,CAAC,EAE5D,AAAI,KAAK,eAAe,cACtB,MAAM,KAAK,KAAK,eAAe,YAAY,EAEzC,KAAK,eAAe,eACtB,MAAM,KAAK,KAAK,eAAe,aAAa,EAGhD,GAAI,KAAK,WAAY,CACnB,MAAM,KAAK,KAAK,WAAW,SAAS,EACpC,MAAM,KAAK,KAAK,WAAW,UAAU,EACrC,SAAW,OAAO,MAAK,WAAW,YAAc,CAAA,EAC9C,MAAM,KAAK,IAAI,IAAI,EACnB,MAAM,KAAK,IAAI,KAAK,EAEtB,AAAI,KAAK,WAAW,WAClB,MAAM,KAAK,KAAK,WAAW,SAAS,EAElC,KAAK,WAAW,QAClB,MAAM,KAAK,GAAG,KAAK,WAAW,OAAO,UAAS,GAAI,EAEhD,KAAK,WAAW,QAClB,MAAM,KAAK,KAAK,WAAW,MAAM,EAE/B,KAAK,WAAW,SAClB,MAAM,KAAK,KAAK,WAAW,OAAO,EAItC,KAAM,KAAM,MAAM,KAAK,GAAG,EAC1B,cAAO,eAAe,OAAQ,iBAAkB,CAAE,MAAO,GAAG,CAAE,EACvD,GACT,CA9CA,QAAA,UAAA,UAwDA,sBAA6B,OAAe,CAC1C,MAAO,gBAAe,OAAQ,CAC5B,SAAS,KAAI,CACX,MAAO,MAAK,QAEd,gBAAc,CACZ,MAAQ,QAA0B,QAAU,OAAA,SAAS,QAAQ,CAAC,GAEjE,CACH,CATA,QAAA,aAAA,aAkDA,wBAAqC,OAAiB,IAAiI,CACrL,KAAM,MAAO,OAAO,eAAc,EAClC,GAAI,KAAK,YAAc,KAAK,eAC1B,KAAM,IAAI,OAAM,uEAA2E,EACtF,GAAI,KAAK,WACd,MAAO,KAAI,SAAS,KAAK,WAAY,IAAI,EACpC,GAAI,KAAK,eACd,MAAO,KAAI,eAAe,KAAK,eAAgB,IAAI,EAEnD,KAAM,IAAI,OAAM,iEAAqE,CAEzF,CAXA,QAAA,eAAA",
  "names": []
}
