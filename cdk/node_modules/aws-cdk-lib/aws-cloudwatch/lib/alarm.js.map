{
  "version": 3,
  "sources": ["alarm.ts"],
  "sourcesContent": ["import { ArnFormat, Lazy, Stack, Token } from '../../core';\nimport { Construct } from 'constructs';\nimport { IAlarmAction } from './alarm-action';\nimport { AlarmBase, IAlarm } from './alarm-base';\nimport { CfnAlarm, CfnAlarmProps } from './cloudwatch.generated';\nimport { HorizontalAnnotation } from './graph';\nimport { CreateAlarmOptions } from './metric';\nimport { IMetric, MetricExpressionConfig, MetricStatConfig } from './metric-types';\nimport { dispatchMetric, metricPeriod } from './private/metric-util';\nimport { dropUndefined } from './private/object';\nimport { MetricSet } from './private/rendering';\nimport { parseStatistic } from './private/statistic';\n\n/**\n * Properties for Alarms\n */\nexport interface AlarmProps extends CreateAlarmOptions {\n  /**\n   * The metric to add the alarm on\n   *\n   * Metric objects can be obtained from most resources, or you can construct\n   * custom Metric objects by instantiating one.\n   */\n  readonly metric: IMetric;\n}\n\n/**\n * Comparison operator for evaluating alarms\n */\nexport enum ComparisonOperator {\n  /**\n   * Specified statistic is greater than or equal to the threshold\n   */\n  GREATER_THAN_OR_EQUAL_TO_THRESHOLD = 'GreaterThanOrEqualToThreshold',\n\n  /**\n   * Specified statistic is strictly greater than the threshold\n   */\n  GREATER_THAN_THRESHOLD = 'GreaterThanThreshold',\n\n  /**\n   * Specified statistic is strictly less than the threshold\n   */\n  LESS_THAN_THRESHOLD = 'LessThanThreshold',\n\n  /**\n   * Specified statistic is less than or equal to the threshold.\n   */\n  LESS_THAN_OR_EQUAL_TO_THRESHOLD = 'LessThanOrEqualToThreshold',\n\n  /**\n   * Specified statistic is lower than or greater than the anomaly model band.\n   * Used only for alarms based on anomaly detection models\n   */\n  LESS_THAN_LOWER_OR_GREATER_THAN_UPPER_THRESHOLD = 'LessThanLowerOrGreaterThanUpperThreshold',\n\n  /**\n   * Specified statistic is greater than the anomaly model band.\n   * Used only for alarms based on anomaly detection models\n   */\n  GREATER_THAN_UPPER_THRESHOLD = 'GreaterThanUpperThreshold',\n\n  /**\n   * Specified statistic is lower than the anomaly model band.\n   * Used only for alarms based on anomaly detection models\n   */\n  LESS_THAN_LOWER_THRESHOLD = 'LessThanLowerThreshold',\n}\n\nconst OPERATOR_SYMBOLS: {[key: string]: string} = {\n  GreaterThanOrEqualToThreshold: '>=',\n  GreaterThanThreshold: '>',\n  LessThanThreshold: '<',\n  LessThanOrEqualToThreshold: '<=',\n};\n\n/**\n * Specify how missing data points are treated during alarm evaluation\n */\nexport enum TreatMissingData {\n  /**\n   * Missing data points are treated as breaching the threshold\n   */\n  BREACHING = 'breaching',\n\n  /**\n   * Missing data points are treated as being within the threshold\n   */\n  NOT_BREACHING = 'notBreaching',\n\n  /**\n   * The current alarm state is maintained\n   */\n  IGNORE = 'ignore',\n\n  /**\n   * The alarm does not consider missing data points when evaluating whether to change state\n   */\n  MISSING = 'missing'\n}\n\n/**\n * An alarm on a CloudWatch metric\n */\nexport class Alarm extends AlarmBase {\n\n  /**\n   * Import an existing CloudWatch alarm provided an ARN\n   *\n   * @param scope The parent creating construct (usually `this`).\n   * @param id The construct's name\n   * @param alarmArn Alarm ARN (i.e. arn:aws:cloudwatch:<region>:<account-id>:alarm:Foo)\n   */\n  public static fromAlarmArn(scope: Construct, id: string, alarmArn: string): IAlarm {\n    class Import extends AlarmBase implements IAlarm {\n      public readonly alarmArn = alarmArn;\n      public readonly alarmName = Stack.of(scope).splitArn(alarmArn, ArnFormat.COLON_RESOURCE_NAME).resourceName!;\n    }\n    return new Import(scope, id);\n  }\n\n  /**\n   * ARN of this alarm\n   *\n   * @attribute\n   */\n  public readonly alarmArn: string;\n\n  /**\n   * Name of this alarm.\n   *\n   * @attribute\n   */\n  public readonly alarmName: string;\n\n  /**\n   * The metric object this alarm was based on\n   */\n  public readonly metric: IMetric;\n\n  /**\n   * This metric as an annotation\n   */\n  private readonly annotation: HorizontalAnnotation;\n\n  constructor(scope: Construct, id: string, props: AlarmProps) {\n    super(scope, id, {\n      physicalName: props.alarmName,\n    });\n\n    const comparisonOperator = props.comparisonOperator || ComparisonOperator.GREATER_THAN_OR_EQUAL_TO_THRESHOLD;\n\n    // Render metric, process potential overrides from the alarm\n    // (It would be preferable if the statistic etc. was worked into the metric,\n    // but hey we're allowing overrides...)\n    const metricProps: Writeable<Partial<CfnAlarmProps>> = this.renderMetric(props.metric);\n    if (props.period) {\n      metricProps.period = props.period.toSeconds();\n    }\n    if (props.statistic) {\n      // Will overwrite both fields if present\n      Object.assign(metricProps, {\n        statistic: renderIfSimpleStatistic(props.statistic),\n        extendedStatistic: renderIfExtendedStatistic(props.statistic),\n      });\n    }\n\n    const alarm = new CfnAlarm(this, 'Resource', {\n      // Meta\n      alarmDescription: props.alarmDescription,\n      alarmName: this.physicalName,\n\n      // Evaluation\n      comparisonOperator,\n      threshold: props.threshold,\n      datapointsToAlarm: props.datapointsToAlarm,\n      evaluateLowSampleCountPercentile: props.evaluateLowSampleCountPercentile,\n      evaluationPeriods: props.evaluationPeriods,\n      treatMissingData: props.treatMissingData,\n\n      // Actions\n      actionsEnabled: props.actionsEnabled,\n      alarmActions: Lazy.list({ produce: () => this.alarmActionArns }),\n      insufficientDataActions: Lazy.list({ produce: (() => this.insufficientDataActionArns) }),\n      okActions: Lazy.list({ produce: () => this.okActionArns }),\n\n      // Metric\n      ...metricProps,\n    });\n\n    this.alarmArn = this.getResourceArnAttribute(alarm.attrArn, {\n      service: 'cloudwatch',\n      resource: 'alarm',\n      resourceName: this.physicalName,\n      arnFormat: ArnFormat.COLON_RESOURCE_NAME,\n    });\n    this.alarmName = this.getResourceNameAttribute(alarm.ref);\n\n    this.metric = props.metric;\n    const datapoints = props.datapointsToAlarm || props.evaluationPeriods;\n    this.annotation = {\n      // eslint-disable-next-line max-len\n      label: `${this.metric} ${OPERATOR_SYMBOLS[comparisonOperator]} ${props.threshold} for ${datapoints} datapoints within ${describePeriod(props.evaluationPeriods * metricPeriod(props.metric).toSeconds())}`,\n      value: props.threshold,\n    };\n  }\n\n  /**\n   * Turn this alarm into a horizontal annotation\n   *\n   * This is useful if you want to represent an Alarm in a non-AlarmWidget.\n   * An `AlarmWidget` can directly show an alarm, but it can only show a\n   * single alarm and no other metrics. Instead, you can convert the alarm to\n   * a HorizontalAnnotation and add it as an annotation to another graph.\n   *\n   * This might be useful if:\n   *\n   * - You want to show multiple alarms inside a single graph, for example if\n   *   you have both a \"small margin/long period\" alarm as well as a\n   *   \"large margin/short period\" alarm.\n   *\n   * - You want to show an Alarm line in a graph with multiple metrics in it.\n   */\n  public toAnnotation(): HorizontalAnnotation {\n    return this.annotation;\n  }\n\n  /**\n   * Trigger this action if the alarm fires\n   *\n   * Typically the ARN of an SNS topic or ARN of an AutoScaling policy.\n   */\n  public addAlarmAction(...actions: IAlarmAction[]) {\n    if (this.alarmActionArns === undefined) {\n      this.alarmActionArns = [];\n    }\n\n    this.alarmActionArns.push(...actions.map(a =>\n      this.validateActionArn(a.bind(this, this).alarmActionArn),\n    ));\n  }\n\n  private validateActionArn(actionArn: string): string {\n    const ec2ActionsRegexp: RegExp = /arn:aws:automate:[a-z|\\d|-]+:ec2:[a-z]+/;\n    if (ec2ActionsRegexp.test(actionArn)) {\n      // Check per-instance metric\n      const metricConfig = this.metric.toMetricConfig();\n      if (metricConfig.metricStat?.dimensions?.length != 1 || metricConfig.metricStat?.dimensions![0].name != 'InstanceId') {\n        throw new Error(`EC2 alarm actions requires an EC2 Per-Instance Metric. (${JSON.stringify(metricConfig)} does not have an 'InstanceId' dimension)`);\n      }\n    }\n    return actionArn;\n  }\n\n  private renderMetric(metric: IMetric) {\n    const self = this;\n    return dispatchMetric(metric, {\n      withStat(stat, conf) {\n        self.validateMetricStat(stat, metric);\n        const canRenderAsLegacyMetric = conf.renderingProperties?.label == undefined && !self.requiresAccountId(stat);\n        // Do this to disturb existing templates as little as possible\n        if (canRenderAsLegacyMetric) {\n          return dropUndefined({\n            dimensions: stat.dimensions,\n            namespace: stat.namespace,\n            metricName: stat.metricName,\n            period: stat.period?.toSeconds(),\n            statistic: renderIfSimpleStatistic(stat.statistic),\n            extendedStatistic: renderIfExtendedStatistic(stat.statistic),\n            unit: stat.unitFilter,\n          });\n        }\n\n        return {\n          metrics: [\n            {\n              metricStat: {\n                metric: {\n                  metricName: stat.metricName,\n                  namespace: stat.namespace,\n                  dimensions: stat.dimensions,\n                },\n                period: stat.period.toSeconds(),\n                stat: stat.statistic,\n                unit: stat.unitFilter,\n              },\n              id: 'm1',\n              accountId: self.requiresAccountId(stat) ? stat.account : undefined,\n              label: conf.renderingProperties?.label,\n              returnData: true,\n            } as CfnAlarm.MetricDataQueryProperty,\n          ],\n        };\n      },\n\n      withExpression() {\n        // Expand the math expression metric into a set\n        const mset = new MetricSet<boolean>();\n        mset.addTopLevel(true, metric);\n\n        let eid = 0;\n        function uniqueMetricId() {\n          return `expr_${++eid}`;\n        }\n\n        return {\n          metrics: mset.entries.map(entry => dispatchMetric(entry.metric, {\n            withStat(stat, conf) {\n              self.validateMetricStat(stat, entry.metric);\n\n              return {\n                metricStat: {\n                  metric: {\n                    metricName: stat.metricName,\n                    namespace: stat.namespace,\n                    dimensions: stat.dimensions,\n                  },\n                  period: stat.period.toSeconds(),\n                  stat: stat.statistic,\n                  unit: stat.unitFilter,\n                },\n                id: entry.id || uniqueMetricId(),\n                accountId: self.requiresAccountId(stat) ? stat.account : undefined,\n                label: conf.renderingProperties?.label,\n                returnData: entry.tag ? undefined : false, // entry.tag evaluates to true if the metric is the math expression the alarm is based on.\n              };\n            },\n            withExpression(expr, conf) {\n\n              const hasSubmetrics = mathExprHasSubmetrics(expr);\n\n              if (hasSubmetrics) {\n                assertSubmetricsCount(expr);\n              }\n\n              self.validateMetricExpression(expr);\n\n              return {\n                expression: expr.expression,\n                id: entry.id || uniqueMetricId(),\n                label: conf.renderingProperties?.label,\n                period: hasSubmetrics ? undefined : expr.period,\n                returnData: entry.tag ? undefined : false, // entry.tag evaluates to true if the metric is the math expression the alarm is based on.\n              };\n            },\n          }) as CfnAlarm.MetricDataQueryProperty),\n        };\n      },\n    });\n  }\n\n  /**\n   * Validate that if a region is in the given stat config, they match the Alarm\n   */\n  private validateMetricStat(stat: MetricStatConfig, metric: IMetric) {\n    const stack = Stack.of(this);\n\n    if (definitelyDifferent(stat.region, stack.region)) {\n      throw new Error(`Cannot create an Alarm in region '${stack.region}' based on metric '${metric}' in '${stat.region}'`);\n    }\n  }\n\n  /**\n   * Validates that the expression config does not specify searchAccount or searchRegion props\n   * as search expressions are not supported by Alarms.\n   */\n  private validateMetricExpression(expr: MetricExpressionConfig) {\n    if (expr.searchAccount !== undefined || expr.searchRegion !== undefined) {\n      throw new Error('Cannot create an Alarm based on a MathExpression which specifies a searchAccount or searchRegion');\n    }\n  }\n\n  /**\n   * Determine if the accountId property should be included in the metric.\n   */\n  private requiresAccountId(stat: MetricStatConfig): boolean {\n    const stackAccount = Stack.of(this).account;\n\n    // if stat.account is undefined, it's by definition in the same account\n    if (stat.account === undefined) {\n      return false;\n    }\n\n    // Return true if they're different. The ACCOUNT_ID token is interned\n    // so will always have the same string value (and even if we guess wrong\n    // it will still work).\n    return stackAccount !== stat.account;\n  }\n}\n\nfunction definitelyDifferent(x: string | undefined, y: string) {\n  return x && !Token.isUnresolved(y) && x !== y;\n}\n\n/**\n * Return a human readable string for this period\n *\n * We know the seconds are always one of a handful of allowed values.\n */\nfunction describePeriod(seconds: number) {\n  if (seconds === 60) { return '1 minute'; }\n  if (seconds === 1) { return '1 second'; }\n  if (seconds > 60) { return (seconds / 60) + ' minutes'; }\n  return seconds + ' seconds';\n}\n\nfunction renderIfSimpleStatistic(statistic?: string): string | undefined {\n  if (statistic === undefined) { return undefined; }\n\n  const parsed = parseStatistic(statistic);\n  if (parsed.type === 'simple') {\n    return parsed.statistic;\n  }\n  return undefined;\n}\n\nfunction renderIfExtendedStatistic(statistic?: string): string | undefined {\n  if (statistic === undefined) { return undefined; }\n\n  const parsed = parseStatistic(statistic);\n  if (parsed.type === 'percentile') {\n    // Already percentile. Avoid parsing because we might get into\n    // floating point rounding issues, return as-is but lowercase the p.\n    return statistic.toLowerCase();\n  } else if (parsed.type === 'generic') {\n    return statistic;\n  }\n\n  return undefined;\n}\n\nfunction mathExprHasSubmetrics(expr: MetricExpressionConfig) {\n  return Object.keys(expr.usingMetrics).length > 0;\n}\n\nfunction assertSubmetricsCount(expr: MetricExpressionConfig) {\n  if (Object.keys(expr.usingMetrics).length > 10) {\n    // https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/AlarmThatSendsEmail.html#alarms-on-metric-math-expressions\n    throw new Error('Alarms on math expressions cannot contain more than 10 individual metrics');\n  };\n}\n\ntype Writeable<T> = { -readonly [P in keyof T]: T[P] };\n"],
  "mappings": "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",
  "names": []
}
