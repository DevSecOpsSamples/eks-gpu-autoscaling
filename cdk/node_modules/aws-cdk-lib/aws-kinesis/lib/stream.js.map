{
  "version": 3,
  "sources": ["stream.ts"],
  "sourcesContent": ["import * as cloudwatch from '../../aws-cloudwatch';\nimport * as iam from '../../aws-iam';\nimport * as kms from '../../aws-kms';\nimport { ArnFormat, Aws, CfnCondition, Duration, Fn, IResolvable, IResource, Resource, Stack, Token } from '../../core';\nimport { Construct } from 'constructs';\nimport { KinesisMetrics } from './kinesis-fixed-canned-metrics';\nimport { CfnStream } from './kinesis.generated';\n\nconst READ_OPERATIONS = [\n  'kinesis:DescribeStreamSummary',\n  'kinesis:GetRecords',\n  'kinesis:GetShardIterator',\n  'kinesis:ListShards',\n  'kinesis:SubscribeToShard',\n  'kinesis:DescribeStream',\n  'kinesis:ListStreams',\n];\n\nconst WRITE_OPERATIONS = [\n  'kinesis:ListShards',\n  'kinesis:PutRecord',\n  'kinesis:PutRecords',\n];\n\n/**\n * A Kinesis Stream\n */\nexport interface IStream extends IResource {\n  /**\n   * The ARN of the stream.\n   *\n   * @attribute\n   */\n  readonly streamArn: string;\n\n  /**\n   * The name of the stream\n   *\n   * @attribute\n   */\n  readonly streamName: string;\n\n  /**\n   * Optional KMS encryption key associated with this stream.\n   */\n  readonly encryptionKey?: kms.IKey;\n\n  /**\n   * Grant read permissions for this stream and its contents to an IAM\n   * principal (Role/Group/User).\n   *\n   * If an encryption key is used, permission to ues the key to decrypt the\n   * contents of the stream will also be granted.\n   */\n  grantRead(grantee: iam.IGrantable): iam.Grant;\n\n  /**\n   * Grant write permissions for this stream and its contents to an IAM\n   * principal (Role/Group/User).\n   *\n   * If an encryption key is used, permission to ues the key to encrypt the\n   * contents of the stream will also be granted.\n   */\n  grantWrite(grantee: iam.IGrantable): iam.Grant;\n\n  /**\n   * Grants read/write permissions for this stream and its contents to an IAM\n   * principal (Role/Group/User).\n   *\n   * If an encryption key is used, permission to use the key for\n   * encrypt/decrypt will also be granted.\n   */\n  grantReadWrite(grantee: iam.IGrantable): iam.Grant;\n\n  /**\n   * Grant the indicated permissions on this stream to the provided IAM principal.\n   */\n  grant(grantee: iam.IGrantable, ...actions: string[]): iam.Grant;\n\n  /**\n   * Return stream metric based from its metric name\n   *\n   * @param metricName name of the stream metric\n   * @param props properties of the metric\n   */\n  metric(metricName: string, props?: cloudwatch.MetricOptions): cloudwatch.Metric;\n\n  /**\n   * The number of bytes retrieved from the Kinesis stream, measured over the specified time period. Minimum, Maximum,\n   * and Average statistics represent the bytes in a single GetRecords operation for the stream in the specified time\n   * period.\n   *\n   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.\n   *\n   * @param props properties of the metric\n   */\n  metricGetRecordsBytes(props?: cloudwatch.MetricOptions): cloudwatch.Metric;\n\n  /**\n   * The age of the last record in all GetRecords calls made against a Kinesis stream, measured over the specified time\n   * period. Age is the difference between the current time and when the last record of the GetRecords call was written\n   * to the stream. The Minimum and Maximum statistics can be used to track the progress of Kinesis consumer\n   * applications. A value of zero indicates that the records being read are completely caught up with the stream.\n   *\n   * The metric defaults to maximum over 5 minutes, it can be changed by passing `statistic` and `period` properties.\n   *\n   * @param props properties of the metric\n   */\n  metricGetRecordsIteratorAgeMilliseconds(props?: cloudwatch.MetricOptions): cloudwatch.Metric;\n\n  /**\n   * The time taken per GetRecords operation, measured over the specified time period.\n   *\n   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.\n   *\n   * @param props properties of the metric\n   */\n  metricGetRecordsLatency(props?: cloudwatch.MetricOptions): cloudwatch.Metric;\n\n  /**\n   * The number of records retrieved from the shard, measured over the specified time period. Minimum, Maximum, and\n   * Average statistics represent the records in a single GetRecords operation for the stream in the specified time\n   * period.\n   *\n   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.\n   *\n   * @param props properties of the metric\n   */\n  metricGetRecords(props?: cloudwatch.MetricOptions): cloudwatch.Metric;\n\n  /**\n   * The number of successful GetRecords operations per stream, measured over the specified time period.\n   *\n   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.\n   *\n   * @param props properties of the metric\n   */\n  metricGetRecordsSuccess(props?: cloudwatch.MetricOptions): cloudwatch.Metric;\n\n  /**\n   * The number of bytes successfully put to the Kinesis stream over the specified time period. This metric includes\n   * bytes from PutRecord and PutRecords operations. Minimum, Maximum, and Average statistics represent the bytes in a\n   * single put operation for the stream in the specified time period.\n   *\n   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.\n   *\n   * @param props properties of the metric\n   */\n  metricIncomingBytes(props?: cloudwatch.MetricOptions): cloudwatch.Metric;\n\n  /**\n   * The number of records successfully put to the Kinesis stream over the specified time period. This metric includes\n   * record counts from PutRecord and PutRecords operations. Minimum, Maximum, and Average statistics represent the\n   * records in a single put operation for the stream in the specified time period.\n   *\n   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.\n   *\n   * @param props properties of the metric\n   */\n  metricIncomingRecords(props?: cloudwatch.MetricOptions): cloudwatch.Metric;\n\n  /**\n   * The number of bytes put to the Kinesis stream using the PutRecord operation over the specified time period.\n   *\n   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.\n   *\n   * @param props properties of the metric\n   */\n  metricPutRecordBytes(props?: cloudwatch.MetricOptions): cloudwatch.Metric;\n\n  /**\n   * The time taken per PutRecord operation, measured over the specified time period.\n   *\n   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.\n   *\n   * @param props properties of the metric\n   */\n  metricPutRecordLatency(props?: cloudwatch.MetricOptions): cloudwatch.Metric;\n\n  /**\n   * The number of successful PutRecord operations per Kinesis stream, measured over the specified time period. Average\n   * reflects the percentage of successful writes to a stream.\n   *\n   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.\n   *\n   * @param props properties of the metric\n   */\n  metricPutRecordSuccess(props?: cloudwatch.MetricOptions): cloudwatch.Metric;\n\n  /**\n   * The number of bytes put to the Kinesis stream using the PutRecords operation over the specified time period.\n   *\n   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.\n   *\n   * @param props properties of the metric\n   */\n  metricPutRecordsBytes(props?: cloudwatch.MetricOptions): cloudwatch.Metric;\n\n  /**\n   * The time taken per PutRecords operation, measured over the specified time period.\n   *\n   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.\n   *\n   * @param props properties of the metric\n   */\n  metricPutRecordsLatency(props?: cloudwatch.MetricOptions): cloudwatch.Metric;\n\n  /**\n   *  The number of PutRecords operations where at least one record succeeded, per Kinesis stream, measured over the\n   *  specified time period.\n   *\n   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.\n   *\n   * @param props properties of the metric\n   */\n  metricPutRecordsSuccess(props?: cloudwatch.MetricOptions): cloudwatch.Metric;\n\n  /**\n   * The total number of records sent in a PutRecords operation per Kinesis data stream, measured over the specified\n   * time period.\n   *\n   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.\n   *\n   * @param props properties of the metric\n   */\n  metricPutRecordsTotalRecords(props?: cloudwatch.MetricOptions): cloudwatch.Metric;\n\n  /**\n   * The number of successful records in a PutRecords operation per Kinesis data stream, measured over the specified\n   * time period.\n   *\n   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.\n   *\n   * @param props properties of the metric\n   */\n  metricPutRecordsSuccessfulRecords(props?: cloudwatch.MetricOptions): cloudwatch.Metric;\n\n  /**\n   * The number of records rejected due to internal failures in a PutRecords operation per Kinesis data stream,\n   * measured over the specified time period. Occasional internal failures are to be expected and should be retried.\n   *\n   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.\n   *\n   * @param props properties of the metric\n   */\n  metricPutRecordsFailedRecords(props?: cloudwatch.MetricOptions): cloudwatch.Metric;\n\n  /**\n   * The number of records rejected due to throttling in a PutRecords operation per Kinesis data stream, measured over\n   * the specified time period.\n   *\n   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.\n   *\n   * @param props properties of the metric\n   */\n  metricPutRecordsThrottledRecords(props?: cloudwatch.MetricOptions): cloudwatch.Metric;\n\n  /**\n   * The number of GetRecords calls throttled for the stream over the specified time period. The most commonly used\n   * statistic for this metric is Average.\n   *\n   * When the Minimum statistic has a value of 1, all records were throttled for the stream during the specified time\n   * period.\n   *\n   * When the Maximum statistic has a value of 0 (zero), no records were throttled for the stream during the specified\n   * time period.\n   *\n   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties\n   *\n   * @param props properties of the metric\n   *\n   */\n  metricReadProvisionedThroughputExceeded(props?: cloudwatch.MetricOptions): cloudwatch.Metric;\n\n  /**\n   * The number of records rejected due to throttling for the stream over the specified time period. This metric\n   * includes throttling from PutRecord and PutRecords operations.\n   *\n   * When the Minimum statistic has a non-zero value, records were being throttled for the stream during the specified\n   * time period.\n   *\n   * When the Maximum statistic has a value of 0 (zero), no records were being throttled for the stream during the\n   * specified time period.\n   *\n   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.\n   *\n   * @param props properties of the metric\n   */\n  metricWriteProvisionedThroughputExceeded(props?: cloudwatch.MetricOptions): cloudwatch.Metric;\n}\n\n/**\n * A reference to a stream. The easiest way to instantiate is to call\n * `stream.export()`. Then, the consumer can use `Stream.import(this, ref)` and\n * get a `Stream`.\n */\nexport interface StreamAttributes {\n  /**\n   * The ARN of the stream.\n   */\n  readonly streamArn: string;\n\n  /**\n   * The KMS key securing the contents of the stream if encryption is enabled.\n   *\n   * @default - No encryption\n   */\n  readonly encryptionKey?: kms.IKey;\n}\n\n/**\n * Represents a Kinesis Stream.\n */\nabstract class StreamBase extends Resource implements IStream {\n  /**\n   * The ARN of the stream.\n   */\n  public abstract readonly streamArn: string;\n\n  /**\n   * The name of the stream\n   */\n  public abstract readonly streamName: string;\n\n  /**\n   * Optional KMS encryption key associated with this stream.\n   */\n  public abstract readonly encryptionKey?: kms.IKey;\n\n  /**\n   * Grant read permissions for this stream and its contents to an IAM\n   * principal (Role/Group/User).\n   *\n   * If an encryption key is used, permission to ues the key to decrypt the\n   * contents of the stream will also be granted.\n   */\n  public grantRead(grantee: iam.IGrantable) {\n    const ret = this.grant(grantee, ...READ_OPERATIONS);\n\n    if (this.encryptionKey) {\n      this.encryptionKey.grantDecrypt(grantee);\n    }\n\n    return ret;\n  }\n\n  /**\n   * Grant write permissions for this stream and its contents to an IAM\n   * principal (Role/Group/User).\n   *\n   * If an encryption key is used, permission to ues the key to encrypt the\n   * contents of the stream will also be granted.\n   */\n  public grantWrite(grantee: iam.IGrantable) {\n    const ret = this.grant(grantee, ...WRITE_OPERATIONS);\n    this.encryptionKey?.grantEncrypt(grantee);\n\n    return ret;\n  }\n\n  /**\n   * Grants read/write permissions for this stream and its contents to an IAM\n   * principal (Role/Group/User).\n   *\n   * If an encryption key is used, permission to use the key for\n   * encrypt/decrypt will also be granted.\n   */\n  public grantReadWrite(grantee: iam.IGrantable) {\n    const ret = this.grant(grantee, ...Array.from(new Set([...READ_OPERATIONS, ...WRITE_OPERATIONS])));\n    this.encryptionKey?.grantEncryptDecrypt(grantee);\n\n    return ret;\n  }\n\n  /**\n   * Grant the indicated permissions on this stream to the given IAM principal (Role/Group/User).\n   */\n  public grant(grantee: iam.IGrantable, ...actions: string[]) {\n    return iam.Grant.addToPrincipal({\n      grantee,\n      actions,\n      resourceArns: [this.streamArn],\n      scope: this,\n    });\n  }\n\n  /**\n   * Return stream metric based from its metric name\n   *\n   * @param metricName name of the stream metric\n   * @param props properties of the metric\n   */\n  public metric(metricName: string, props?: cloudwatch.MetricOptions) {\n    return new cloudwatch.Metric({\n      namespace: 'AWS/Kinesis',\n      metricName,\n      dimensionsMap: {\n        StreamName: this.streamName,\n      },\n      ...props,\n    }).attachTo(this);\n  }\n\n  /**\n   * The number of bytes retrieved from the Kinesis stream, measured over the specified time period. Minimum, Maximum,\n   * and Average statistics represent the bytes in a single GetRecords operation for the stream in the specified time\n   * period.\n   *\n   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.\n   *\n   * @param props properties of the metric\n   */\n  public metricGetRecordsBytes(props?: cloudwatch.MetricOptions) {\n    return this.metricFromCannedFunction(KinesisMetrics.getRecordsBytesAverage, props);\n  }\n\n  /**\n   * The age of the last record in all GetRecords calls made against a Kinesis stream, measured over the specified time\n   * period. Age is the difference between the current time and when the last record of the GetRecords call was written\n   * to the stream. The Minimum and Maximum statistics can be used to track the progress of Kinesis consumer\n   * applications. A value of zero indicates that the records being read are completely caught up with the stream.\n   *\n   * The metric defaults to maximum over 5 minutes, it can be changed by passing `statistic` and `period` properties.\n   *\n   * @param props properties of the metric\n   */\n  public metricGetRecordsIteratorAgeMilliseconds(props?: cloudwatch.MetricOptions) {\n    return this.metricFromCannedFunction(KinesisMetrics.getRecordsIteratorAgeMillisecondsMaximum, props);\n  }\n\n  /**\n   * The number of successful GetRecords operations per stream, measured over the specified time period.\n   *\n   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.\n   *\n   * @param props properties of the metric\n   */\n  public metricGetRecordsSuccess(props?: cloudwatch.MetricOptions) {\n    return this.metricFromCannedFunction(KinesisMetrics.getRecordsSuccessAverage, props);\n  }\n\n  /**\n   * The number of records retrieved from the shard, measured over the specified time period. Minimum, Maximum, and\n   * Average statistics represent the records in a single GetRecords operation for the stream in the specified time\n   * period.\n   *\n   * average\n   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.\n   *\n   * @param props properties of the metric\n   */\n  public metricGetRecords(props?: cloudwatch.MetricOptions) {\n    return this.metricFromCannedFunction(KinesisMetrics.getRecordsRecordsAverage, props);\n  }\n\n  /**\n   * The number of successful GetRecords operations per stream, measured over the specified time period.\n   *\n   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.\n   *\n   * @param props properties of the metric\n   */\n  public metricGetRecordsLatency(props?: cloudwatch.MetricOptions) {\n    return this.metricFromCannedFunction(KinesisMetrics.getRecordsLatencyAverage, props);\n  }\n\n  /**\n   * The number of bytes put to the Kinesis stream using the PutRecord operation over the specified time period.\n   *\n   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.\n   *\n   * @param props properties of the metric\n   */\n  public metricPutRecordBytes(props?: cloudwatch.MetricOptions) {\n    return this.metricFromCannedFunction(KinesisMetrics.putRecordBytesAverage, props);\n  }\n\n  /**\n   * The time taken per PutRecord operation, measured over the specified time period.\n   *\n   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.\n   *\n   * @param props properties of the metric\n   */\n  metricPutRecordLatency(props?: cloudwatch.MetricOptions) {\n    return this.metricFromCannedFunction(KinesisMetrics.putRecordLatencyAverage, props);\n  }\n\n  /**\n   * The number of successful PutRecord operations per Kinesis stream, measured over the specified time period. Average\n   * reflects the percentage of successful writes to a stream.\n   *\n   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.\n   *\n   * @param props properties of the metric\n   */\n  public metricPutRecordSuccess(props?: cloudwatch.MetricOptions) {\n    return this.metricFromCannedFunction(KinesisMetrics.putRecordSuccessAverage, props);\n  }\n\n  /**\n   * The number of bytes put to the Kinesis stream using the PutRecords operation over the specified time period.\n   *\n   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.\n   *\n   * @param props properties of the metric\n   */\n  public metricPutRecordsBytes(props?: cloudwatch.MetricOptions) {\n    return this.metricFromCannedFunction(KinesisMetrics.putRecordsBytesAverage, props);\n  }\n\n  /**\n   * The time taken per PutRecords operation, measured over the specified time period.\n   *\n   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.\n   *\n   * @param props properties of the metric\n   */\n  public metricPutRecordsLatency(props?: cloudwatch.MetricOptions) {\n    return this.metricFromCannedFunction(KinesisMetrics.putRecordsLatencyAverage, props);\n  }\n\n  /**\n   *  The number of PutRecords operations where at least one record succeeded, per Kinesis stream, measured over the\n   *  specified time period.\n   *\n   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.\n   *\n   * @param props properties of the metric\n   */\n  public metricPutRecordsSuccess(props?: cloudwatch.MetricOptions) {\n    return this.metricFromCannedFunction(KinesisMetrics.putRecordsSuccessAverage, props);\n  }\n\n  /**\n   * The total number of records sent in a PutRecords operation per Kinesis data stream, measured over the specified\n   * time period.\n   *\n   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.\n   *\n   * @param props properties of the metric\n   */\n  public metricPutRecordsTotalRecords(props?: cloudwatch.MetricOptions) {\n    return this.metricFromCannedFunction(KinesisMetrics.putRecordsTotalRecordsAverage, props);\n  }\n\n  /**\n   * The number of successful records in a PutRecords operation per Kinesis data stream, measured over the specified\n   * time period.\n   *\n   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.\n   *\n   * @param props properties of the metric\n   */\n  public metricPutRecordsSuccessfulRecords(props?: cloudwatch.MetricOptions) {\n    return this.metricFromCannedFunction(KinesisMetrics.putRecordsSuccessfulRecordsAverage, props);\n  }\n\n  /**\n   * The number of records rejected due to internal failures in a PutRecords operation per Kinesis data stream,\n   * measured over the specified time period. Occasional internal failures are to be expected and should be retried.\n   *\n   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.\n   *\n   * @param props properties of the metric\n   */\n  public metricPutRecordsFailedRecords(props?: cloudwatch.MetricOptions) {\n    return this.metricFromCannedFunction(KinesisMetrics.putRecordsFailedRecordsAverage, props);\n  }\n\n  /**\n   * The number of records rejected due to throttling in a PutRecords operation per Kinesis data stream, measured over\n   * the specified time period.\n   *\n   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.\n   *\n   * @param props properties of the metric\n   */\n  public metricPutRecordsThrottledRecords(props?: cloudwatch.MetricOptions) {\n    return this.metricFromCannedFunction(KinesisMetrics.putRecordsThrottledRecordsAverage, props);\n  }\n\n  /**\n   * The number of bytes successfully put to the Kinesis stream over the specified time period. This metric includes\n   * bytes from PutRecord and PutRecords operations. Minimum, Maximum, and Average statistics represent the bytes in a\n   * single put operation for the stream in the specified time period.\n   *\n   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.\n   *\n   * @param props properties of the metric\n   */\n  public metricIncomingBytes(props?: cloudwatch.MetricOptions) {\n    return this.metricFromCannedFunction(KinesisMetrics.incomingBytesAverage, props);\n  }\n\n  /**\n   * The number of records successfully put to the Kinesis stream over the specified time period. This metric includes\n   * record counts from PutRecord and PutRecords operations. Minimum, Maximum, and Average statistics represent the\n   * records in a single put operation for the stream in the specified time period.\n   *\n   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.\n   *\n   * @param props properties of the metric\n   */\n  public metricIncomingRecords(props?: cloudwatch.MetricOptions) {\n    return this.metricFromCannedFunction(KinesisMetrics.incomingRecordsAverage, props);\n  }\n\n  /**\n   * The number of GetRecords calls throttled for the stream over the specified time period. The most commonly used\n   * statistic for this metric is Average.\n   *\n   * When the Minimum statistic has a value of 1, all records were throttled for the stream during the specified time\n   * period.\n   *\n   * When the Maximum statistic has a value of 0 (zero), no records were throttled for the stream during the specified\n   * time period.\n   *\n   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties\n   *\n   * @param props properties of the metric\n   *\n   */\n  public metricReadProvisionedThroughputExceeded(props?: cloudwatch.MetricOptions) {\n    return this.metricFromCannedFunction(KinesisMetrics.readProvisionedThroughputExceededAverage, props);\n  }\n\n  /**\n   * The number of records rejected due to throttling for the stream over the specified time period. This metric\n   * includes throttling from PutRecord and PutRecords operations.\n   *\n   * When the Minimum statistic has a non-zero value, records were being throttled for the stream during the specified\n   * time period.\n   *\n   * When the Maximum statistic has a value of 0 (zero), no records were being throttled for the stream during the\n   * specified time period.\n   *\n   * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.\n   *\n   * @param props properties of the metric\n   */\n  public metricWriteProvisionedThroughputExceeded(props?: cloudwatch.MetricOptions) {\n    return this.metricFromCannedFunction(KinesisMetrics.writeProvisionedThroughputExceededAverage, props);\n  }\n\n  // create metrics based on generated KinesisMetrics static methods\n  private metricFromCannedFunction(\n    createCannedProps: (dimensions: { StreamName: string }) => cloudwatch.MetricProps,\n    props?: cloudwatch.MetricOptions): cloudwatch.Metric {\n    return new cloudwatch.Metric({\n      ...createCannedProps({ StreamName: this.streamName }),\n      ...props,\n    }).attachTo(this);\n  }\n\n}\n\n/**\n * Properties for a Kinesis Stream\n */\nexport interface StreamProps {\n  /**\n   * Enforces a particular physical stream name.\n   * @default <generated>\n   */\n  readonly streamName?: string;\n\n  /**\n   * The number of hours for the data records that are stored in shards to remain accessible.\n   * @default Duration.hours(24)\n   */\n  readonly retentionPeriod?: Duration;\n\n  /**\n   * The number of shards for the stream.\n   *\n   * Can only be provided if streamMode is Provisioned.\n   *\n   * @default 1\n   */\n  readonly shardCount?: number;\n\n  /**\n   * The kind of server-side encryption to apply to this stream.\n   *\n   * If you choose KMS, you can specify a KMS key via `encryptionKey`. If\n   * encryption key is not specified, a key will automatically be created.\n   *\n   * @default - StreamEncryption.KMS if encrypted Streams are supported in the region\n   *   or StreamEncryption.UNENCRYPTED otherwise.\n   *   StreamEncryption.KMS if an encryption key is supplied through the encryptionKey property\n   */\n  readonly encryption?: StreamEncryption;\n\n  /**\n   * External KMS key to use for stream encryption.\n   *\n   * The 'encryption' property must be set to \"Kms\".\n   *\n   * @default - Kinesis Data Streams master key ('/alias/aws/kinesis').\n   *   If encryption is set to StreamEncryption.KMS and this property is undefined, a new KMS key\n   *   will be created and associated with this stream.\n   */\n  readonly encryptionKey?: kms.IKey;\n\n  /**\n   * The capacity mode of this stream.\n   *\n   * @default StreamMode.PROVISIONED\n   */\n  readonly streamMode?: StreamMode;\n}\n\n/**\n * A Kinesis stream. Can be encrypted with a KMS key.\n */\nexport class Stream extends StreamBase {\n\n  /**\n   * Import an existing Kinesis Stream provided an ARN\n   *\n   * @param scope The parent creating construct (usually `this`).\n   * @param id The construct's name\n   * @param streamArn Stream ARN (i.e. arn:aws:kinesis:<region>:<account-id>:stream/Foo)\n   */\n  public static fromStreamArn(scope: Construct, id: string, streamArn: string): IStream {\n    return Stream.fromStreamAttributes(scope, id, { streamArn });\n  }\n\n  /**\n   * Creates a Stream construct that represents an external stream.\n   *\n   * @param scope The parent creating construct (usually `this`).\n   * @param id The construct's name.\n   * @param attrs Stream import properties\n   */\n  public static fromStreamAttributes(scope: Construct, id: string, attrs: StreamAttributes): IStream {\n    class Import extends StreamBase {\n      public readonly streamArn = attrs.streamArn;\n      public readonly streamName = Stack.of(scope).splitArn(attrs.streamArn, ArnFormat.SLASH_RESOURCE_NAME).resourceName!;\n      public readonly encryptionKey = attrs.encryptionKey;\n    }\n\n    return new Import(scope, id);\n  }\n\n  public readonly streamArn: string;\n  public readonly streamName: string;\n  public readonly encryptionKey?: kms.IKey;\n\n  private readonly stream: CfnStream;\n\n  constructor(scope: Construct, id: string, props: StreamProps = {}) {\n    super(scope, id, {\n      physicalName: props.streamName,\n    });\n\n    let shardCount = props.shardCount;\n    const streamMode = props.streamMode ?? StreamMode.PROVISIONED;\n\n    if (streamMode === StreamMode.ON_DEMAND && shardCount !== undefined) {\n      throw new Error(`streamMode must be set to ${StreamMode.PROVISIONED} (default) when specifying shardCount`);\n    }\n    if (streamMode === StreamMode.PROVISIONED && shardCount === undefined) {\n      shardCount = 1;\n    }\n\n    const retentionPeriodHours = props.retentionPeriod?.toHours() ?? 24;\n    if (!Token.isUnresolved(retentionPeriodHours)) {\n      if (retentionPeriodHours < 24 || retentionPeriodHours > 8760) {\n        throw new Error(`retentionPeriod must be between 24 and 8760 hours. Received ${retentionPeriodHours}`);\n      }\n    }\n\n    const { streamEncryption, encryptionKey } = this.parseEncryption(props);\n\n    this.stream = new CfnStream(this, 'Resource', {\n      name: this.physicalName,\n      retentionPeriodHours,\n      shardCount,\n      streamEncryption,\n      streamModeDetails: streamMode ? { streamMode } : undefined,\n    });\n\n    this.streamArn = this.getResourceArnAttribute(this.stream.attrArn, {\n      service: 'kinesis',\n      resource: 'stream',\n      resourceName: this.physicalName,\n    });\n    this.streamName = this.getResourceNameAttribute(this.stream.ref);\n\n    this.encryptionKey = encryptionKey;\n  }\n\n  /**\n   * Set up key properties and return the Stream encryption property from the\n   * user's configuration.\n   */\n  private parseEncryption(props: StreamProps): {\n    streamEncryption?: CfnStream.StreamEncryptionProperty | IResolvable\n    encryptionKey?: kms.IKey\n  } {\n\n    // if encryption properties are not set, default to KMS in regions where KMS is available\n    if (!props.encryption && !props.encryptionKey) {\n\n      const conditionName = 'AwsCdkKinesisEncryptedStreamsUnsupportedRegions';\n      const existing = Stack.of(this).node.tryFindChild(conditionName);\n\n      // create a single condition for the Stack\n      if (!existing) {\n        new CfnCondition(Stack.of(this), conditionName, {\n          expression: Fn.conditionOr(\n            Fn.conditionEquals(Aws.REGION, 'cn-north-1'),\n            Fn.conditionEquals(Aws.REGION, 'cn-northwest-1'),\n          ),\n        });\n      }\n\n      return {\n        streamEncryption: Fn.conditionIf(conditionName,\n          Aws.NO_VALUE,\n          { EncryptionType: 'KMS', KeyId: 'alias/aws/kinesis' }),\n      };\n    }\n\n    // default based on whether encryption key is specified\n    const encryptionType = props.encryption ??\n      (props.encryptionKey ? StreamEncryption.KMS : StreamEncryption.UNENCRYPTED);\n\n    // if encryption key is set, encryption must be set to KMS.\n    if (encryptionType !== StreamEncryption.KMS && props.encryptionKey) {\n      throw new Error(`encryptionKey is specified, so 'encryption' must be set to KMS (value: ${encryptionType})`);\n    }\n\n    if (encryptionType === StreamEncryption.UNENCRYPTED) {\n      return { };\n    }\n\n    if (encryptionType === StreamEncryption.MANAGED) {\n      const encryption = { encryptionType: 'KMS', keyId: 'alias/aws/kinesis' };\n      return { streamEncryption: encryption };\n    }\n\n    if (encryptionType === StreamEncryption.KMS) {\n      const encryptionKey = props.encryptionKey || new kms.Key(this, 'Key', {\n        description: `Created by ${this.node.path}`,\n      });\n\n      const streamEncryption: CfnStream.StreamEncryptionProperty = {\n        encryptionType: 'KMS',\n        keyId: encryptionKey.keyArn,\n      };\n      return { encryptionKey, streamEncryption };\n    }\n\n    throw new Error(`Unexpected 'encryptionType': ${encryptionType}`);\n  }\n}\n\n/**\n * What kind of server-side encryption to apply to this stream\n */\nexport enum StreamEncryption {\n  /**\n   * Records in the stream are not encrypted.\n   */\n  UNENCRYPTED = 'NONE',\n\n  /**\n   * Server-side encryption with a KMS key managed by the user.\n   * If `encryptionKey` is specified, this key will be used, otherwise, one will be defined.\n   */\n  KMS = 'KMS',\n\n  /**\n   * Server-side encryption with a master key managed by Amazon Kinesis\n   */\n  MANAGED = 'MANAGED'\n}\n\n/**\n * Specifies the capacity mode to apply to this stream.\n */\nexport enum StreamMode {\n  /**\n   * Specify the provisioned capacity mode. The stream will have `shardCount` shards unless\n   * modified and will be billed according to the provisioned capacity.\n   */\n  PROVISIONED = 'PROVISIONED',\n\n  /**\n   * Specify the on-demand capacity mode. The stream will autoscale and be billed according to the\n   * volume of data ingested and retrieved.\n   */\n  ON_DEMAND = 'ON_DEMAND'\n}\n"],
  "mappings": "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",
  "names": []
}
