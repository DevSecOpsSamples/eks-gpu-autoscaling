{
  "version": 3,
  "sources": ["step-scaling-policy.ts"],
  "sourcesContent": ["import { findAlarmThresholds, normalizeIntervals } from '../../aws-autoscaling-common';\nimport * as cloudwatch from '../../aws-cloudwatch';\nimport { Duration } from '../../core';\nimport { Construct } from 'constructs';\nimport { IAutoScalingGroup } from './auto-scaling-group';\nimport { AdjustmentType, MetricAggregationType, StepScalingAction } from './step-scaling-action';\n\nexport interface BasicStepScalingPolicyProps {\n  /**\n   * Metric to scale on.\n   */\n  readonly metric: cloudwatch.IMetric;\n\n  /**\n   * The intervals for scaling.\n   *\n   * Maps a range of metric values to a particular scaling behavior.\n   */\n  readonly scalingSteps: ScalingInterval[];\n\n  /**\n   * How the adjustment numbers inside 'intervals' are interpreted.\n   *\n   * @default ChangeInCapacity\n   */\n  readonly adjustmentType?: AdjustmentType;\n\n  /**\n   * Grace period after scaling activity.\n   *\n   * @default Default cooldown period on your AutoScalingGroup\n   */\n  readonly cooldown?: Duration;\n\n  /**\n   * Estimated time until a newly launched instance can send metrics to CloudWatch.\n   *\n   * @default Same as the cooldown\n   */\n  readonly estimatedInstanceWarmup?: Duration;\n\n  /**\n   * Minimum absolute number to adjust capacity with as result of percentage scaling.\n   *\n   * Only when using AdjustmentType = PercentChangeInCapacity, this number controls\n   * the minimum absolute effect size.\n   *\n   * @default No minimum scaling effect\n   */\n  readonly minAdjustmentMagnitude?: number;\n\n  /**\n   * How many evaluation periods of the metric to wait before triggering a scaling action\n   *\n   * Raising this value can be used to smooth out the metric, at the expense\n   * of slower response times.\n   *\n   * @default 1\n   */\n  readonly evaluationPeriods?: number;\n\n  /**\n   * Aggregation to apply to all data points over the evaluation periods\n   *\n   * Only has meaning if `evaluationPeriods != 1`.\n   *\n   * @default - The statistic from the metric if applicable (MIN, MAX, AVERAGE), otherwise AVERAGE.\n   */\n  readonly metricAggregationType?: MetricAggregationType;\n}\n\nexport interface StepScalingPolicyProps extends BasicStepScalingPolicyProps {\n  /**\n   * The auto scaling group\n   */\n  readonly autoScalingGroup: IAutoScalingGroup;\n}\n\n/**\n * Define a acaling strategy which scales depending on absolute values of some metric.\n *\n * You can specify the scaling behavior for various values of the metric.\n *\n * Implemented using one or more CloudWatch alarms and Step Scaling Policies.\n */\nexport class StepScalingPolicy extends Construct {\n  public readonly lowerAlarm?: cloudwatch.Alarm;\n  public readonly lowerAction?: StepScalingAction;\n  public readonly upperAlarm?: cloudwatch.Alarm;\n  public readonly upperAction?: StepScalingAction;\n\n  constructor(scope: Construct, id: string, props: StepScalingPolicyProps) {\n    super(scope, id);\n\n    if (props.scalingSteps.length < 2) {\n      throw new Error('You must supply at least 2 intervals for autoscaling');\n    }\n\n    const adjustmentType = props.adjustmentType || AdjustmentType.CHANGE_IN_CAPACITY;\n    const changesAreAbsolute = adjustmentType === AdjustmentType.EXACT_CAPACITY;\n\n    const intervals = normalizeIntervals(props.scalingSteps, changesAreAbsolute);\n    const alarms = findAlarmThresholds(intervals);\n\n    if (alarms.lowerAlarmIntervalIndex !== undefined) {\n      const threshold = intervals[alarms.lowerAlarmIntervalIndex].upper;\n\n      this.lowerAction = new StepScalingAction(this, 'LowerPolicy', {\n        adjustmentType: props.adjustmentType,\n        cooldown: props.cooldown,\n        metricAggregationType: props.metricAggregationType ?? aggregationTypeFromMetric(props.metric),\n        minAdjustmentMagnitude: props.minAdjustmentMagnitude,\n        autoScalingGroup: props.autoScalingGroup,\n      });\n\n      for (let i = alarms.lowerAlarmIntervalIndex; i >= 0; i--) {\n        this.lowerAction.addAdjustment({\n          adjustment: intervals[i].change!,\n          lowerBound: i !== 0 ? intervals[i].lower - threshold : undefined, // Extend last interval to -infinity\n          upperBound: intervals[i].upper - threshold,\n        });\n      }\n\n      this.lowerAlarm = new cloudwatch.Alarm(this, 'LowerAlarm', {\n        // Recommended by AutoScaling\n        metric: props.metric,\n        alarmDescription: 'Lower threshold scaling alarm',\n        comparisonOperator: cloudwatch.ComparisonOperator.LESS_THAN_OR_EQUAL_TO_THRESHOLD,\n        evaluationPeriods: props.evaluationPeriods ?? 1,\n        threshold,\n      });\n      this.lowerAlarm.addAlarmAction(new StepScalingAlarmAction(this.lowerAction));\n    }\n\n    if (alarms.upperAlarmIntervalIndex !== undefined) {\n      const threshold = intervals[alarms.upperAlarmIntervalIndex].lower;\n\n      this.upperAction = new StepScalingAction(this, 'UpperPolicy', {\n        adjustmentType: props.adjustmentType,\n        cooldown: props.cooldown,\n        metricAggregationType: props.metricAggregationType ?? aggregationTypeFromMetric(props.metric),\n        minAdjustmentMagnitude: props.minAdjustmentMagnitude,\n        autoScalingGroup: props.autoScalingGroup,\n      });\n\n      for (let i = alarms.upperAlarmIntervalIndex; i < intervals.length; i++) {\n        this.upperAction.addAdjustment({\n          adjustment: intervals[i].change!,\n          lowerBound: intervals[i].lower - threshold,\n          upperBound: i !== intervals.length - 1 ? intervals[i].upper - threshold : undefined, // Extend last interval to +infinity\n        });\n      }\n\n      this.upperAlarm = new cloudwatch.Alarm(this, 'UpperAlarm', {\n        // Recommended by AutoScaling\n        metric: props.metric,\n        alarmDescription: 'Upper threshold scaling alarm',\n        comparisonOperator: cloudwatch.ComparisonOperator.GREATER_THAN_OR_EQUAL_TO_THRESHOLD,\n        evaluationPeriods: props.evaluationPeriods ?? 1,\n        threshold,\n      });\n      this.upperAlarm.addAlarmAction(new StepScalingAlarmAction(this.upperAction));\n    }\n  }\n}\n\nfunction aggregationTypeFromMetric(metric: cloudwatch.IMetric): MetricAggregationType | undefined {\n  const statistic = metric.toMetricConfig().metricStat?.statistic;\n  if (statistic === undefined) { return undefined; } // Math expression, don't know aggregation, leave default\n\n  switch (statistic) {\n    case 'Average':\n      return MetricAggregationType.AVERAGE;\n    case 'Minimum':\n      return MetricAggregationType.MINIMUM;\n    case 'Maximum':\n      return MetricAggregationType.MAXIMUM;\n    default:\n      return MetricAggregationType.AVERAGE;\n  }\n}\n\n/**\n * A range of metric values in which to apply a certain scaling operation\n */\nexport interface ScalingInterval {\n  /**\n   * The lower bound of the interval.\n   *\n   * The scaling adjustment will be applied if the metric is higher than this value.\n   *\n   * @default Threshold automatically derived from neighbouring intervals\n   */\n  readonly lower?: number;\n\n  /**\n   * The upper bound of the interval.\n   *\n   * The scaling adjustment will be applied if the metric is lower than this value.\n   *\n   * @default Threshold automatically derived from neighbouring intervals\n   */\n  readonly upper?: number;\n\n  /**\n   * The capacity adjustment to apply in this interval\n   *\n   * The number is interpreted differently based on AdjustmentType:\n   *\n   * - ChangeInCapacity: add the adjustment to the current capacity.\n   *  The number can be positive or negative.\n   * - PercentChangeInCapacity: add or remove the given percentage of the current\n   *   capacity to itself. The number can be in the range [-100..100].\n   * - ExactCapacity: set the capacity to this number. The number must\n   *   be positive.\n   */\n  readonly change: number;\n}\n\n/**\n * Use a StepScalingAction as an Alarm Action\n *\n * This class is here and not in aws-cloudwatch-actions because this library\n * needs to use the class, and otherwise we'd have a circular dependency:\n *\n * aws-autoscaling -> aws-cloudwatch-actions (for using the Action)\n * aws-cloudwatch-actions -> aws-autoscaling (for the definition of IStepScalingAction)\n */\nclass StepScalingAlarmAction implements cloudwatch.IAlarmAction {\n  constructor(private readonly stepScalingAction: StepScalingAction) {\n  }\n\n  public bind(_scope: Construct, _alarm: cloudwatch.IAlarm): cloudwatch.AlarmActionConfig {\n    return { alarmActionArn: this.stepScalingAction.scalingPolicyArn };\n  }\n}\n"],
  "mappings": "wNAAA,yBAAA,QAAA,8BAAA,EACA,WAAA,QAAA,sBAAA,EAEA,aAAA,QAAA,YAAA,EAEA,sBAAA,QAAA,uBAAA,EAgFA,MAAa,yBAA0B,cAAA,SAAS,CAM9C,YAAY,MAAkB,GAAY,MAA6B,iBACrE,MAAM,MAAO,EAAE,EAEf,qFAAI,MAAM,aAAa,OAAS,EAC9B,KAAM,IAAI,OAAM,sDAAsD,EAIxE,KAAM,oBAAqB,AADJ,OAAM,gBAAkB,sBAAA,eAAe,sBAChB,sBAAA,eAAe,eAEvD,UAAY,yBAAA,mBAAmB,MAAM,aAAc,kBAAkB,EACrE,OAAS,yBAAA,oBAAoB,SAAS,EAE5C,GAAI,OAAO,0BAA4B,OAAW,CAChD,KAAM,WAAY,UAAU,OAAO,yBAAyB,MAE5D,KAAK,YAAc,GAAI,uBAAA,kBAAkB,KAAM,cAAe,CAC5D,eAAgB,MAAM,eACtB,SAAU,MAAM,SAChB,sBAAqB,IAAE,MAAM,yBAAqB,MAAA,KAAA,OAAA,GAAI,0BAA0B,MAAM,MAAM,EAC5F,uBAAwB,MAAM,uBAC9B,iBAAkB,MAAM,iBACzB,EAED,OAAS,GAAI,OAAO,wBAAyB,GAAK,EAAG,IACnD,KAAK,YAAY,cAAc,CAC7B,WAAY,UAAU,GAAG,OACzB,WAAY,IAAM,EAAI,UAAU,GAAG,MAAQ,UAAY,OACvD,WAAY,UAAU,GAAG,MAAQ,UAClC,EAGH,KAAK,WAAa,GAAI,YAAW,MAAM,KAAM,aAAc,CAEzD,OAAQ,MAAM,OACd,iBAAkB,gCAClB,mBAAoB,WAAW,mBAAmB,gCAClD,kBAAiB,IAAE,MAAM,qBAAiB,MAAA,KAAA,OAAA,GAAI,EAC9C,UACD,EACD,KAAK,WAAW,eAAe,GAAI,wBAAuB,KAAK,WAAW,CAAC,EAG7E,GAAI,OAAO,0BAA4B,OAAW,CAChD,KAAM,WAAY,UAAU,OAAO,yBAAyB,MAE5D,KAAK,YAAc,GAAI,uBAAA,kBAAkB,KAAM,cAAe,CAC5D,eAAgB,MAAM,eACtB,SAAU,MAAM,SAChB,sBAAqB,IAAE,MAAM,yBAAqB,MAAA,KAAA,OAAA,GAAI,0BAA0B,MAAM,MAAM,EAC5F,uBAAwB,MAAM,uBAC9B,iBAAkB,MAAM,iBACzB,EAED,OAAS,GAAI,OAAO,wBAAyB,EAAI,UAAU,OAAQ,IACjE,KAAK,YAAY,cAAc,CAC7B,WAAY,UAAU,GAAG,OACzB,WAAY,UAAU,GAAG,MAAQ,UACjC,WAAY,IAAM,UAAU,OAAS,EAAI,UAAU,GAAG,MAAQ,UAAY,OAC3E,EAGH,KAAK,WAAa,GAAI,YAAW,MAAM,KAAM,aAAc,CAEzD,OAAQ,MAAM,OACd,iBAAkB,gCAClB,mBAAoB,WAAW,mBAAmB,mCAClD,kBAAiB,IAAE,MAAM,qBAAiB,MAAA,KAAA,OAAA,GAAI,EAC9C,UACD,EACD,KAAK,WAAW,eAAe,GAAI,wBAAuB,KAAK,WAAW,CAAC,IA5EjF,QAAA,kBAAA,qIAiFA,mCAAmC,OAA0B,QAC3D,KAAM,WAAS,IAAG,OAAO,eAAc,EAAG,cAAU,MAAA,KAAA,OAAA,OAAA,GAAE,UACtD,GAAI,YAAc,OAElB,OAAQ,eACD,UACH,MAAO,uBAAA,sBAAsB,YAC1B,UACH,MAAO,uBAAA,sBAAsB,YAC1B,UACH,MAAO,uBAAA,sBAAsB,gBAE7B,MAAO,uBAAA,sBAAsB,QAEnC,CAgDA,MAAM,sBAAsB,CAC1B,YAA6B,kBAAoC,CAApC,KAAA,kBAAA,kBAGtB,KAAK,OAAmB,OAAyB,CACtD,MAAO,CAAE,eAAgB,KAAK,kBAAkB,gBAAgB",
  "names": []
}
