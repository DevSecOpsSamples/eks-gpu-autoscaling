{
  "version": 3,
  "sources": ["queue-processing-service-base.ts"],
  "sourcesContent": ["import { ScalingInterval } from '../../../aws-applicationautoscaling';\nimport { IVpc } from '../../../aws-ec2';\nimport {\n  AwsLogDriver, BaseService, CapacityProviderStrategy, Cluster, ContainerImage, DeploymentController, DeploymentCircuitBreaker,\n  ICluster, LogDriver, PropagatedTagSource, Secret,\n} from '../../../aws-ecs';\nimport { IQueue, Queue } from '../../../aws-sqs';\nimport { CfnOutput, Duration, FeatureFlags, Stack } from '../../../core';\nimport * as cxapi from '../../../cx-api';\nimport { Construct } from 'constructs';\n\n/**\n * The properties for the base QueueProcessingEc2Service or QueueProcessingFargateService service.\n */\nexport interface QueueProcessingServiceBaseProps {\n  /**\n   * The name of the service.\n   *\n   * @default - CloudFormation-generated name.\n   */\n  readonly serviceName?: string;\n\n  /**\n   * The name of the cluster that hosts the service.\n   *\n   * If a cluster is specified, the vpc construct should be omitted. Alternatively, you can omit both cluster and vpc.\n   * @default - create a new cluster; if both cluster and vpc are omitted, a new VPC will be created for you.\n   */\n  readonly cluster?: ICluster;\n\n  /**\n   * The VPC where the container instances will be launched or the elastic network interfaces (ENIs) will be deployed.\n   *\n   * If a vpc is specified, the cluster construct should be omitted. Alternatively, you can omit both vpc and cluster.\n   * @default - uses the VPC defined in the cluster or creates a new VPC.\n   */\n  readonly vpc?: IVpc;\n\n  /**\n   * The image used to start a container.\n   */\n  readonly image: ContainerImage;\n\n  /**\n   * The command that is passed to the container.\n   *\n   * If you provide a shell command as a single string, you have to quote command-line arguments.\n   *\n   * @default - CMD value built into container image.\n   */\n  readonly command?: string[];\n\n  /**\n   * The desired number of instantiations of the task definition to keep running on the service.\n   *\n   * @default - If the feature flag, ECS_REMOVE_DEFAULT_DESIRED_COUNT is false, the default is 1;\n   * if true, the minScalingCapacity is 1 for all new services and uses the existing services desired count\n   * when updating an existing service.\n   * @deprecated - Use `minScalingCapacity` or a literal object instead.\n   */\n  readonly desiredTaskCount?: number;\n\n  /**\n   * Flag to indicate whether to enable logging.\n   *\n   * @default true\n   */\n  readonly enableLogging?: boolean;\n\n  /**\n   * The environment variables to pass to the container.\n   *\n   * The variable `QUEUE_NAME` with value `queue.queueName` will\n   * always be passed.\n   *\n   * @default 'QUEUE_NAME: queue.queueName'\n   */\n  readonly environment?: { [key: string]: string };\n\n  /**\n   * The secret to expose to the container as an environment variable.\n   *\n   * @default - No secret environment variables.\n   */\n  readonly secrets?: { [key: string]: Secret };\n\n  /**\n   * A queue for which to process items from.\n   *\n   * If specified and this is a FIFO queue, the queue name must end in the string '.fifo'. See\n   * [CreateQueue](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/APIReference/API_CreateQueue.html)\n   *\n   * @default 'SQSQueue with CloudFormation-generated name'\n   */\n  readonly queue?: IQueue;\n\n  /**\n   * The maximum number of times that a message can be received by consumers.\n   * When this value is exceeded for a message the message will be automatically sent to the Dead Letter Queue.\n   *\n   * @default 3\n   */\n  readonly maxReceiveCount?: number;\n\n  /**\n   * Timeout of processing a single message. After dequeuing, the processor has this much time to handle the message and delete it from the queue\n   * before it becomes visible again for dequeueing by another processor. Values must be between 0 and (12 hours).\n   *\n   * @default Duration.seconds(30)\n   */\n  readonly visibilityTimeout?: Duration;\n\n  /**\n   * The number of seconds that Dead Letter Queue retains a message.\n   *\n   * @default Duration.days(14)\n   */\n  readonly retentionPeriod?: Duration;\n\n  /**\n   * Maximum capacity to scale to.\n   *\n   * @default - If the feature flag, ECS_REMOVE_DEFAULT_DESIRED_COUNT is false, the default is (desiredTaskCount * 2); if true, the default is 2.\n   */\n  readonly maxScalingCapacity?: number\n\n  /**\n   * Minimum capacity to scale to.\n   *\n   * @default - If the feature flag, ECS_REMOVE_DEFAULT_DESIRED_COUNT is false, the default is the desiredTaskCount; if true, the default is 1.\n   */\n  readonly minScalingCapacity?: number\n\n  /**\n   * The intervals for scaling based on the SQS queue's ApproximateNumberOfMessagesVisible metric.\n   *\n   * Maps a range of metric values to a particular scaling behavior. See\n   * [Simple and Step Scaling Policies for Amazon EC2 Auto Scaling](https://docs.aws.amazon.com/autoscaling/ec2/userguide/as-scaling-simple-step.html)\n   *\n   * @default [{ upper: 0, change: -1 },{ lower: 100, change: +1 },{ lower: 500, change: +5 }]\n   */\n  readonly scalingSteps?: ScalingInterval[];\n\n  /**\n   * The log driver to use.\n   *\n   * @default - AwsLogDriver if enableLogging is true\n   */\n  readonly logDriver?: LogDriver;\n\n  /**\n   * Specifies whether to propagate the tags from the task definition or the service to the tasks in the service.\n   * Tags can only be propagated to the tasks within the service during service creation.\n   *\n   * @default - none\n   */\n  readonly propagateTags?: PropagatedTagSource;\n\n  /**\n   * Specifies whether to enable Amazon ECS managed tags for the tasks within the service. For more information, see\n   * [Tagging Your Amazon ECS Resources](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-using-tags.html)\n   *\n   * @default false\n   */\n  readonly enableECSManagedTags?: boolean;\n\n  /**\n   * The name of a family that the task definition is registered to. A family groups multiple versions of a task definition.\n   *\n   * @default - Automatically generated name.\n   */\n  readonly family?: string;\n\n  /**\n   * The maximum number of tasks, specified as a percentage of the Amazon ECS\n   * service's DesiredCount value, that can run in a service during a\n   * deployment.\n   *\n   * @default - default from underlying service.\n   */\n  readonly maxHealthyPercent?: number;\n\n  /**\n   * The minimum number of tasks, specified as a percentage of\n   * the Amazon ECS service's DesiredCount value, that must\n   * continue to run and remain healthy during a deployment.\n   *\n   * @default - default from underlying service.\n   */\n  readonly minHealthyPercent?: number;\n\n  /**\n   * Specifies which deployment controller to use for the service. For more information, see\n   * [Amazon ECS Deployment Types](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/deployment-types.html)\n   *\n   * @default - Rolling update (ECS)\n   */\n  readonly deploymentController?: DeploymentController;\n\n  /**\n   * Whether to enable the deployment circuit breaker. If this property is defined, circuit breaker will be implicitly\n   * enabled.\n   * @default - disabled\n   */\n  readonly circuitBreaker?: DeploymentCircuitBreaker;\n\n  /**\n   * A list of Capacity Provider strategies used to place a service.\n   *\n   * @default - undefined\n   *\n   */\n  readonly capacityProviderStrategies?: CapacityProviderStrategy[];\n}\n\n/**\n * The base class for QueueProcessingEc2Service and QueueProcessingFargateService services.\n */\nexport abstract class QueueProcessingServiceBase extends Construct {\n  /**\n   * The SQS queue that the service will process from\n   */\n  public readonly sqsQueue: IQueue;\n\n  /**\n   * The dead letter queue for the primary SQS queue\n   */\n  public readonly deadLetterQueue?: IQueue;\n\n  /**\n   * The cluster where your service will be deployed\n   */\n  public readonly cluster: ICluster;\n\n  // Properties that have defaults defined. The Queue Processing Service will handle assigning undefined properties with default\n  // values so that derived classes do not need to maintain the same logic.\n\n  /**\n   * Environment variables that will include the queue name\n   */\n  public readonly environment: { [key: string]: string };\n\n  /**\n   * The secret environment variables.\n   */\n  public readonly secrets?: { [key: string]: Secret };\n\n  /**\n   * The minimum number of tasks to run.\n   * @deprecated - Use `minCapacity` instead.\n   */\n  public readonly desiredCount: number;\n\n  /**\n   * The maximum number of instances for autoscaling to scale up to.\n   */\n  public readonly maxCapacity: number;\n\n  /**\n   * The minimum number of instances for autoscaling to scale down to.\n   */\n  public readonly minCapacity: number;\n\n  /**\n   * The scaling interval for autoscaling based off an SQS Queue size.\n   */\n  public readonly scalingSteps: ScalingInterval[];\n  /**\n   * The AwsLogDriver to use for logging if logging is enabled.\n   */\n  public readonly logDriver?: LogDriver;\n\n  /**\n   * Constructs a new instance of the QueueProcessingServiceBase class.\n   */\n  constructor(scope: Construct, id: string, props: QueueProcessingServiceBaseProps) {\n    super(scope, id);\n\n    if (props.cluster && props.vpc) {\n      throw new Error('You can only specify either vpc or cluster. Alternatively, you can leave both blank');\n    }\n    this.cluster = props.cluster || this.getDefaultCluster(this, props.vpc);\n\n    // Create the SQS queue and it's corresponding DLQ if one is not provided\n    if (props.queue) {\n      this.sqsQueue = props.queue;\n    } else {\n      this.deadLetterQueue = new Queue(this, 'EcsProcessingDeadLetterQueue', {\n        retentionPeriod: props.retentionPeriod || Duration.days(14),\n      });\n      this.sqsQueue = new Queue(this, 'EcsProcessingQueue', {\n        visibilityTimeout: props.visibilityTimeout,\n        deadLetterQueue: {\n          queue: this.deadLetterQueue,\n          maxReceiveCount: props.maxReceiveCount || 3,\n        },\n      });\n\n      new CfnOutput(this, 'SQSDeadLetterQueue', { value: this.deadLetterQueue.queueName });\n      new CfnOutput(this, 'SQSDeadLetterQueueArn', { value: this.deadLetterQueue.queueArn });\n    }\n\n    // Setup autoscaling scaling intervals\n    const defaultScalingSteps = [{ upper: 0, change: -1 }, { lower: 100, change: +1 }, { lower: 500, change: +5 }];\n    this.scalingSteps = props.scalingSteps ?? defaultScalingSteps;\n\n    // Create log driver if logging is enabled\n    const enableLogging = props.enableLogging ?? true;\n    this.logDriver = props.logDriver ?? (enableLogging ? this.createAWSLogDriver(this.node.id) : undefined);\n\n    // Add the queue name to environment variables\n    this.environment = { ...(props.environment || {}), QUEUE_NAME: this.sqsQueue.queueName };\n    this.secrets = props.secrets;\n\n    this.desiredCount = props.desiredTaskCount ?? 1;\n\n    // Determine the desired task count (minimum) and maximum scaling capacity\n    if (!FeatureFlags.of(this).isEnabled(cxapi.ECS_REMOVE_DEFAULT_DESIRED_COUNT)) {\n      this.minCapacity = props.minScalingCapacity ?? this.desiredCount;\n      this.maxCapacity = props.maxScalingCapacity || (2 * this.desiredCount);\n    } else {\n      if (props.desiredTaskCount != null) {\n        this.minCapacity = props.minScalingCapacity ?? this.desiredCount;\n        this.maxCapacity = props.maxScalingCapacity || (2 * this.desiredCount);\n      } else {\n        this.minCapacity = props.minScalingCapacity ?? 1;\n        this.maxCapacity = props.maxScalingCapacity || 2;\n      }\n    }\n\n    if (!this.desiredCount && !this.maxCapacity) {\n      throw new Error('maxScalingCapacity must be set and greater than 0 if desiredCount is 0');\n    }\n\n    new CfnOutput(this, 'SQSQueue', { value: this.sqsQueue.queueName });\n    new CfnOutput(this, 'SQSQueueArn', { value: this.sqsQueue.queueArn });\n  }\n\n  /**\n   * Configure autoscaling based off of CPU utilization as well as the number of messages visible in the SQS queue\n   *\n   * @param service the ECS/Fargate service for which to apply the autoscaling rules to\n   */\n  protected configureAutoscalingForService(service: BaseService) {\n    const scalingTarget = service.autoScaleTaskCount({ maxCapacity: this.maxCapacity, minCapacity: this.minCapacity });\n    scalingTarget.scaleOnCpuUtilization('CpuScaling', {\n      targetUtilizationPercent: 50,\n    });\n    scalingTarget.scaleOnMetric('QueueMessagesVisibleScaling', {\n      metric: this.sqsQueue.metricApproximateNumberOfMessagesVisible(),\n      scalingSteps: this.scalingSteps,\n    });\n  }\n\n  /**\n   * Grant SQS permissions to an ECS service.\n   * @param service the ECS/Fargate service to which to grant SQS permissions\n   */\n  protected grantPermissionsToService(service: BaseService) {\n    this.sqsQueue.grantConsumeMessages(service.taskDefinition.taskRole);\n  }\n\n  /**\n   * Returns the default cluster.\n   */\n  protected getDefaultCluster(scope: Construct, vpc?: IVpc): Cluster {\n    // magic string to avoid collision with user-defined constructs\n    const DEFAULT_CLUSTER_ID = `EcsDefaultClusterMnL3mNNYN${vpc ? vpc.node.id : ''}`;\n    const stack = Stack.of(scope);\n    return stack.node.tryFindChild(DEFAULT_CLUSTER_ID) as Cluster || new Cluster(stack, DEFAULT_CLUSTER_ID, { vpc });\n  }\n\n  /**\n   * Create an AWS Log Driver with the provided streamPrefix\n   *\n   * @param prefix the Cloudwatch logging prefix\n   */\n  private createAWSLogDriver(prefix: string): AwsLogDriver {\n    return new AwsLogDriver({ streamPrefix: prefix });\n  }\n}\n"],
  "mappings": "oOAEA,UAAA,QAAA,kBAAA,EAIA,UAAA,QAAA,kBAAA,EACA,OAAA,QAAA,eAAA,EACA,MAAA,QAAA,iBAAA,EACA,aAAA,QAAA,YAAA,EAiNA,MAAsB,kCAAmC,cAAA,SAAS,CAyDhE,YAAY,MAAkB,GAAY,MAAsC,0BAC9E,MAAM,MAAO,EAAE,EAEf,+FAAI,MAAM,SAAW,MAAM,IACzB,KAAM,IAAI,OAAM,qFAAqF,EAEvG,KAAK,QAAU,MAAM,SAAW,KAAK,kBAAkB,KAAM,MAAM,GAAG,EAGtE,AAAI,MAAM,MACR,KAAK,SAAW,MAAM,MAEtB,MAAK,gBAAkB,GAAI,WAAA,MAAM,KAAM,+BAAgC,CACrE,gBAAiB,MAAM,iBAAmB,OAAA,SAAS,KAAK,EAAE,EAC3D,EACD,KAAK,SAAW,GAAI,WAAA,MAAM,KAAM,qBAAsB,CACpD,kBAAmB,MAAM,kBACzB,gBAAiB,CACf,MAAO,KAAK,gBACZ,gBAAiB,MAAM,iBAAmB,GAE7C,EAED,GAAI,QAAA,UAAU,KAAM,qBAAsB,CAAE,MAAO,KAAK,gBAAgB,SAAS,CAAE,EACnF,GAAI,QAAA,UAAU,KAAM,wBAAyB,CAAE,MAAO,KAAK,gBAAgB,QAAQ,CAAE,GAIvF,KAAM,qBAAsB,CAAC,CAAE,MAAO,EAAG,OAAQ,EAAE,EAAI,CAAE,MAAO,IAAK,OAAQ,CAAE,EAAI,CAAE,MAAO,IAAK,OAAQ,CAAE,CAAE,EAC7G,KAAK,aAAY,IAAG,MAAM,gBAAY,MAAA,KAAA,OAAA,GAAI,oBAG1C,KAAM,eAAa,IAAG,MAAM,iBAAa,MAAA,KAAA,OAAA,GAAI,GAuB7C,GAtBA,KAAK,UAAS,IAAG,MAAM,aAAS,MAAA,KAAA,OAAA,GAAK,cAAgB,KAAK,mBAAmB,KAAK,KAAK,EAAE,EAAI,OAG7F,KAAK,YAAc,IAAM,MAAM,aAAe,CAAA,EAAK,WAAY,KAAK,SAAS,SAAS,EACtF,KAAK,QAAU,MAAM,QAErB,KAAK,aAAY,IAAG,MAAM,oBAAgB,MAAA,KAAA,OAAA,GAAI,EAG9C,AAAK,OAAA,aAAa,GAAG,IAAI,EAAE,UAAU,MAAM,gCAAgC,EAIzE,AAAI,MAAM,kBAAoB,KAC5B,MAAK,YAAW,IAAG,MAAM,sBAAkB,MAAA,KAAA,OAAA,GAAI,KAAK,aACpD,KAAK,YAAc,MAAM,oBAAuB,EAAI,KAAK,cAEzD,MAAK,YAAW,IAAG,MAAM,sBAAkB,MAAA,KAAA,OAAA,GAAI,EAC/C,KAAK,YAAc,MAAM,oBAAsB,GARjD,MAAK,YAAW,IAAG,MAAM,sBAAkB,MAAA,KAAA,OAAA,GAAI,KAAK,aACpD,KAAK,YAAc,MAAM,oBAAuB,EAAI,KAAK,cAWvD,CAAC,KAAK,cAAgB,CAAC,KAAK,YAC9B,KAAM,IAAI,OAAM,wEAAwE,EAG1F,GAAI,QAAA,UAAU,KAAM,WAAY,CAAE,MAAO,KAAK,SAAS,SAAS,CAAE,EAClE,GAAI,QAAA,UAAU,KAAM,cAAe,CAAE,MAAO,KAAK,SAAS,QAAQ,CAAE,EAQ5D,+BAA+B,QAAoB,kEAC3D,KAAM,eAAgB,QAAQ,mBAAmB,CAAE,YAAa,KAAK,YAAa,YAAa,KAAK,WAAW,CAAE,EACjH,cAAc,sBAAsB,aAAc,CAChD,yBAA0B,GAC3B,EACD,cAAc,cAAc,8BAA+B,CACzD,OAAQ,KAAK,SAAS,yCAAwC,EAC9D,aAAc,KAAK,aACpB,EAOO,0BAA0B,QAAoB,kEACtD,KAAK,SAAS,qBAAqB,QAAQ,eAAe,QAAQ,EAM1D,kBAAkB,MAAkB,IAAU,uDAEtD,KAAM,oBAAqB,6BAA6B,IAAM,IAAI,KAAK,GAAK,KACtE,MAAQ,OAAA,MAAM,GAAG,KAAK,EAC5B,MAAO,OAAM,KAAK,aAAa,kBAAkB,GAAgB,GAAI,WAAA,QAAQ,MAAO,mBAAoB,CAAE,GAAG,CAAE,EAQzG,mBAAmB,OAAc,CACvC,MAAO,IAAI,WAAA,aAAa,CAAE,aAAc,MAAM,CAAE,GAhKpD,QAAA,2BAAA",
  "names": []
}
