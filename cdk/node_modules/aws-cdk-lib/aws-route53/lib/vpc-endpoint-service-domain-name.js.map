{
  "version": 3,
  "sources": ["vpc-endpoint-service-domain-name.ts"],
  "sourcesContent": ["import * as crypto from 'crypto';\nimport { IVpcEndpointService } from '../../aws-ec2';\nimport { Fn, Names, Stack } from '../../core';\nimport { AwsCustomResource, AwsCustomResourcePolicy, PhysicalResourceId } from '../../custom-resources';\nimport { Construct } from 'constructs';\nimport { IPublicHostedZone, TxtRecord } from '../lib';\n\n/**\n * Properties to configure a VPC Endpoint Service domain name\n */\nexport interface VpcEndpointServiceDomainNameProps {\n\n  /**\n   * The VPC Endpoint Service to configure Private DNS for\n   */\n  readonly endpointService: IVpcEndpointService;\n\n  /**\n   * The domain name to use.\n   *\n   * This domain name must be owned by this account (registered through Route53),\n   * or delegated to this account. Domain ownership will be verified by AWS before\n   * private DNS can be used.\n   * @see https://docs.aws.amazon.com/vpc/latest/userguide/endpoint-services-dns-validation.html\n   */\n  readonly domainName: string;\n\n  /**\n   * The public hosted zone to use for the domain.\n   */\n  readonly publicHostedZone: IPublicHostedZone;\n}\n\n/**\n * A Private DNS configuration for a VPC endpoint service.\n */\nexport class VpcEndpointServiceDomainName extends Construct {\n\n  // Track all domain names created, so someone doesn't accidentally associate two domains with a single service\n  private static readonly endpointServices: IVpcEndpointService[] = [];\n\n  // Track all domain names created, so someone doesn't accidentally associate two domains with a single service\n  private static readonly endpointServicesMap: { [endpointService: string]: string} = {};\n\n  /**\n   * The domain name associated with the private DNS configuration\n   */\n  public domainName: string;\n\n  // The way this class works is by using three custom resources and a TxtRecord in conjunction\n  // The first custom resource tells the VPC endpoint service to use the given DNS name\n  // The VPC endpoint service will then say:\n  // \"ok, create a TXT record using these two values to prove you own the domain\"\n  // The second custom resource retrieves these two values from the service\n  // The TxtRecord is created from these two values\n  // The third custom resource tells the VPC Endpoint Service to verify the domain ownership\n  constructor(scope: Construct, id: string, props: VpcEndpointServiceDomainNameProps) {\n    super(scope, id);\n\n    const serviceUniqueId = Names.nodeUniqueId(props.endpointService.node);\n    const serviceId = props.endpointService.vpcEndpointServiceId;\n    this.domainName = props.domainName;\n\n    // Make sure a user doesn't accidentally add multiple domains\n    this.validateProps(props);\n\n    VpcEndpointServiceDomainName.endpointServicesMap[serviceUniqueId] = this.domainName;\n    VpcEndpointServiceDomainName.endpointServices.push(props.endpointService);\n\n    // Enable Private DNS on the endpoint service and retrieve the AWS-generated configuration\n    const privateDnsConfiguration = this.getPrivateDnsConfiguration(serviceUniqueId, serviceId, this.domainName);\n\n    // Tell AWS to verify that this account owns the domain attached to the service\n    this.verifyPrivateDnsConfiguration(privateDnsConfiguration, props.publicHostedZone);\n\n    // Finally, don't do any of the above before the endpoint service is created\n    this.node.addDependency(props.endpointService);\n  }\n\n  private validateProps(props: VpcEndpointServiceDomainNameProps): void {\n    const serviceUniqueId = Names.nodeUniqueId(props.endpointService.node);\n    if (serviceUniqueId in VpcEndpointServiceDomainName.endpointServicesMap) {\n      const endpoint = VpcEndpointServiceDomainName.endpointServicesMap[serviceUniqueId];\n      throw new Error(\n        `Cannot create a VpcEndpointServiceDomainName for service ${serviceUniqueId}, another VpcEndpointServiceDomainName (${endpoint}) is already associated with it`);\n    }\n  }\n\n  /**\n   * Sets up Custom Resources to make AWS calls to set up Private DNS on an endpoint service,\n   * returning the values to use in a TxtRecord, which AWS uses to verify domain ownership.\n   */\n  private getPrivateDnsConfiguration(serviceUniqueId: string, serviceId: string, privateDnsName: string): PrivateDnsConfiguration {\n\n    // The custom resource which tells AWS to enable Private DNS on the given service, using the given domain name\n    // AWS will generate a name/value pair for use in a TxtRecord, which is used to verify domain ownership.\n    const enablePrivateDnsAction = {\n      service: 'EC2',\n      action: 'modifyVpcEndpointServiceConfiguration',\n      parameters: {\n        ServiceId: serviceId,\n        PrivateDnsName: privateDnsName,\n      },\n      physicalResourceId: PhysicalResourceId.of(serviceUniqueId),\n    };\n    const removePrivateDnsAction = {\n      service: 'EC2',\n      action: 'modifyVpcEndpointServiceConfiguration',\n      parameters: {\n        ServiceId: serviceId,\n        RemovePrivateDnsName: true,\n      },\n    };\n    const enable = new AwsCustomResource(this, 'EnableDns', {\n      onCreate: enablePrivateDnsAction,\n      onUpdate: enablePrivateDnsAction,\n      onDelete: removePrivateDnsAction,\n      policy: AwsCustomResourcePolicy.fromSdkCalls({\n        resources: [\n          Fn.join(':', [\n            'arn',\n            Stack.of(this).partition,\n            'ec2',\n            Stack.of(this).region,\n            Stack.of(this).account,\n            Fn.join('/', [\n              'vpc-endpoint-service',\n              serviceId,\n            ]),\n          ]),\n        ],\n      }),\n    });\n\n    // Look up the name/value pair if the domain changes, or the service changes,\n    // which would cause the values to be different. If the unique ID changes,\n    // the resource may be entirely recreated, so we will need to look it up again.\n    const lookup = hashcode(Names.uniqueId(this) + serviceUniqueId + privateDnsName);\n\n    // Create the custom resource to look up the name/value pair generated by AWS\n    // after the previous API call\n    const retrieveNameValuePairAction = {\n      service: 'EC2',\n      action: 'describeVpcEndpointServiceConfigurations',\n      parameters: {\n        ServiceIds: [serviceId],\n      },\n      physicalResourceId: PhysicalResourceId.of(lookup),\n    };\n    const getNames = new AwsCustomResource(this, 'GetNames', {\n      onCreate: retrieveNameValuePairAction,\n      onUpdate: retrieveNameValuePairAction,\n      // describeVpcEndpointServiceConfigurations can't take an ARN for granular permissions\n      policy: AwsCustomResourcePolicy.fromSdkCalls({\n        resources: AwsCustomResourcePolicy.ANY_RESOURCE,\n      }),\n    });\n\n    // We only want to call and get the name/value pair after we've told AWS to enable Private DNS\n    // If we call before then, we'll get an empty pair of values.\n    getNames.node.addDependency(enable);\n\n    // Get the references to the name/value pair associated with the endpoint service\n    const name = getNames.getResponseField('ServiceConfigurations.0.PrivateDnsNameConfiguration.Name');\n    const value = getNames.getResponseField('ServiceConfigurations.0.PrivateDnsNameConfiguration.Value');\n\n    return { name, value, serviceId };\n  }\n\n  /**\n   * Creates a Route53 entry and a Custom Resource which explicitly tells AWS to verify ownership\n   * of the domain name attached to an endpoint service.\n   */\n  private verifyPrivateDnsConfiguration(config: PrivateDnsConfiguration, publicHostedZone: IPublicHostedZone) {\n    // Create the TXT record in the provided hosted zone\n    const verificationRecord = new TxtRecord(this, 'DnsVerificationRecord', {\n      recordName: config.name,\n      values: [config.value],\n      zone: publicHostedZone,\n    });\n\n    // Tell the endpoint service to verify the domain ownership\n    const startVerificationAction = {\n      service: 'EC2',\n      action: 'startVpcEndpointServicePrivateDnsVerification',\n      parameters: {\n        ServiceId: config.serviceId,\n      },\n      physicalResourceId: PhysicalResourceId.of(Fn.join(':', [config.name, config.value])),\n    };\n    const startVerification = new AwsCustomResource(this, 'StartVerification', {\n      onCreate: startVerificationAction,\n      onUpdate: startVerificationAction,\n      policy: AwsCustomResourcePolicy.fromSdkCalls({\n        resources: [\n          Fn.join(':', [\n            'arn',\n            Stack.of(this).partition,\n            'ec2',\n            Stack.of(this).region,\n            Stack.of(this).account,\n            Fn.join('/', [\n              'vpc-endpoint-service',\n              config.serviceId,\n            ]),\n          ]),\n        ],\n      }),\n    });\n    // Only verify after the record has been created\n    startVerification.node.addDependency(verificationRecord);\n  }\n}\n\n/**\n * Represent the name/value pair associated with a Private DNS enabled endpoint service\n */\ninterface PrivateDnsConfiguration {\n  readonly name: string;\n  readonly value: string;\n  readonly serviceId: string;\n}\n\n/**\n * Hash a string\n */\nfunction hashcode(s: string): string {\n  const hash = crypto.createHash('md5');\n  hash.update(s);\n  return hash.digest('hex');\n};"],
  "mappings": "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",
  "names": []
}
