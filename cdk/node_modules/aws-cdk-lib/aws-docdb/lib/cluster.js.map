{
  "version": 3,
  "sources": ["cluster.ts"],
  "sourcesContent": ["import * as ec2 from '../../aws-ec2';\nimport { IRole } from '../../aws-iam';\nimport * as kms from '../../aws-kms';\nimport * as logs from '../../aws-logs';\nimport * as secretsmanager from '../../aws-secretsmanager';\nimport { CfnResource, Duration, RemovalPolicy, Resource, Token } from '../../core';\nimport { Construct } from 'constructs';\nimport { DatabaseClusterAttributes, IDatabaseCluster } from './cluster-ref';\nimport { DatabaseSecret } from './database-secret';\nimport { CfnDBCluster, CfnDBInstance, CfnDBSubnetGroup } from './docdb.generated';\nimport { Endpoint } from './endpoint';\nimport { IClusterParameterGroup } from './parameter-group';\nimport { BackupProps, Login, RotationMultiUserOptions } from './props';\n\n/**\n * Properties for a new database cluster\n */\nexport interface DatabaseClusterProps {\n  /**\n   * What version of the database to start\n   *\n   * @default - The default engine version.\n   */\n  readonly engineVersion?: string;\n\n  /**\n   * The port the DocumentDB cluster will listen on\n   *\n   * @default DatabaseCluster.DEFAULT_PORT\n   */\n  readonly port?: number;\n\n  /**\n   * Username and password for the administrative user\n   */\n  readonly masterUser: Login;\n\n  /**\n   * Backup settings\n   *\n   * @default - Backup retention period for automated backups is 1 day.\n   * Backup preferred window is set to a 30-minute window selected at random from an\n   * 8-hour block of time for each AWS Region, occurring on a random day of the week.\n   * @see https://docs.aws.amazon.com/documentdb/latest/developerguide/backup-restore.db-cluster-snapshots.html#backup-restore.backup-window\n   */\n  readonly backup?: BackupProps;\n\n  /**\n   * The KMS key for storage encryption.\n   *\n   * @default - default master key.\n   */\n  readonly kmsKey?: kms.IKey;\n\n  /**\n   * Whether to enable storage encryption\n   *\n   * @default true\n   */\n  readonly storageEncrypted?: boolean;\n\n  /**\n   * Number of DocDB compute instances\n   *\n   * @default 1\n   */\n  readonly instances?: number;\n\n  /**\n   * An optional identifier for the cluster\n   *\n   * @default - A name is automatically generated.\n   */\n  readonly dbClusterName?: string;\n\n  /**\n   * Base identifier for instances\n   *\n   * Every replica is named by appending the replica number to this string, 1-based.\n   *\n   * @default - `dbClusterName` is used with the word \"Instance\" appended. If `dbClusterName` is not provided, the\n   * identifier is automatically generated.\n   */\n  readonly instanceIdentifierBase?: string;\n\n  /**\n   * What type of instance to start for the replicas\n   */\n  readonly instanceType: ec2.InstanceType;\n\n  /**\n    * What subnets to run the DocumentDB instances in.\n    *\n    * Must be at least 2 subnets in two different AZs.\n    */\n  readonly vpc: ec2.IVpc;\n\n  /**\n    * Where to place the instances within the VPC\n    *\n    * @default private subnets\n    */\n  readonly vpcSubnets?: ec2.SubnetSelection;\n\n  /**\n    * Security group.\n    *\n    * @default a new security group is created.\n    */\n  readonly securityGroup?: ec2.ISecurityGroup;\n\n  /**\n    * The DB parameter group to associate with the instance.\n    *\n    * @default no parameter group\n    */\n  readonly parameterGroup?: IClusterParameterGroup;\n\n  /**\n   * A weekly time range in which maintenance should preferably execute.\n   *\n   * Must be at least 30 minutes long.\n   *\n   * Example: 'tue:04:17-tue:04:47'\n   *\n   * @default - 30-minute window selected at random from an 8-hour block of time for\n   * each AWS Region, occurring on a random day of the week.\n   * @see https://docs.aws.amazon.com/documentdb/latest/developerguide/db-instance-maintain.html#maintenance-window\n   */\n  readonly preferredMaintenanceWindow?: string;\n\n  /**\n   * The removal policy to apply when the cluster and its instances are removed\n   * or replaced during a stack update, or when the stack is deleted. This\n   * removal policy also applies to the implicit security group created for the\n   * cluster if one is not supplied as a parameter.\n   *\n   * @default - Retain cluster.\n   */\n  readonly removalPolicy?: RemovalPolicy\n\n  /**\n   * Specifies whether this cluster can be deleted. If deletionProtection is\n   * enabled, the cluster cannot be deleted unless it is modified and\n   * deletionProtection is disabled. deletionProtection protects clusters from\n   * being accidentally deleted.\n   *\n   * @default - false\n   */\n  readonly deletionProtection?: boolean;\n\n  /**\n   * Whether the profiler logs should be exported to CloudWatch.\n   * Note that you also have to configure the profiler log export in the Cluster's Parameter Group.\n   *\n   * @see https://docs.aws.amazon.com/documentdb/latest/developerguide/profiling.html#profiling.enable-profiling\n   * @default false\n   */\n  readonly exportProfilerLogsToCloudWatch?: boolean;\n\n  /**\n   * Whether the audit logs should be exported to CloudWatch.\n   * Note that you also have to configure the audit log export in the Cluster's Parameter Group.\n   *\n   * @see https://docs.aws.amazon.com/documentdb/latest/developerguide/event-auditing.html#event-auditing-enabling-auditing\n   * @default false\n   */\n  readonly exportAuditLogsToCloudWatch?: boolean;\n\n  /**\n   * The number of days log events are kept in CloudWatch Logs. When updating\n   * this property, unsetting it doesn't remove the log retention policy. To\n   * remove the retention policy, set the value to `Infinity`.\n   *\n   * @default - logs never expire\n   */\n  readonly cloudWatchLogsRetention?: logs.RetentionDays;\n\n  /**\n    * The IAM role for the Lambda function associated with the custom resource\n    * that sets the retention policy.\n    *\n    * @default - a new role is created.\n    */\n  readonly cloudWatchLogsRetentionRole?: IRole;\n}\n\n/**\n * A new or imported clustered database.\n */\nabstract class DatabaseClusterBase extends Resource implements IDatabaseCluster {\n  /**\n   * Identifier of the cluster\n   */\n  public abstract readonly clusterIdentifier: string;\n  /**\n   * Identifiers of the replicas\n   */\n  public abstract readonly instanceIdentifiers: string[];\n\n  /**\n   * The endpoint to use for read/write operations\n   */\n  public abstract readonly clusterEndpoint: Endpoint;\n\n  /**\n   * Endpoint to use for load-balanced read-only operations.\n   */\n  public abstract readonly clusterReadEndpoint: Endpoint;\n\n  /**\n   * Endpoints which address each individual replica.\n   */\n  public abstract readonly instanceEndpoints: Endpoint[];\n\n  /**\n   * Access to the network connections\n   */\n  public abstract readonly connections: ec2.Connections;\n\n  /**\n   * Security group identifier of this database\n   */\n  public abstract readonly securityGroupId: string;\n\n  /**\n   * Renders the secret attachment target specifications.\n   */\n  public asSecretAttachmentTarget(): secretsmanager.SecretAttachmentTargetProps {\n    return {\n      targetId: this.clusterIdentifier,\n      targetType: secretsmanager.AttachmentTargetType.DOCDB_DB_CLUSTER,\n    };\n  }\n}\n\n/**\n * Create a clustered database with a given number of instances.\n *\n * @resource AWS::DocDB::DBCluster\n */\nexport class DatabaseCluster extends DatabaseClusterBase {\n\n  /**\n   * The default number of instances in the DocDB cluster if none are\n   * specified\n   */\n  public static readonly DEFAULT_NUM_INSTANCES = 1;\n\n  /**\n   * The default port Document DB listens on\n   */\n  public static readonly DEFAULT_PORT = 27017;\n\n  /**\n   * Import an existing DatabaseCluster from properties\n   */\n  public static fromDatabaseClusterAttributes(scope: Construct, id: string, attrs: DatabaseClusterAttributes): IDatabaseCluster {\n    class Import extends DatabaseClusterBase implements IDatabaseCluster {\n      public readonly defaultPort = ec2.Port.tcp(attrs.port);\n      public readonly connections = new ec2.Connections({\n        securityGroups: [attrs.securityGroup],\n        defaultPort: this.defaultPort,\n      });\n      public readonly clusterIdentifier = attrs.clusterIdentifier;\n      public readonly instanceIdentifiers = attrs.instanceIdentifiers;\n      public readonly clusterEndpoint = new Endpoint(attrs.clusterEndpointAddress, attrs.port);\n      public readonly clusterReadEndpoint = new Endpoint(attrs.readerEndpointAddress, attrs.port);\n      public readonly instanceEndpoints = attrs.instanceEndpointAddresses.map(a => new Endpoint(a, attrs.port));\n      public readonly securityGroupId = attrs.securityGroup.securityGroupId;\n    }\n\n    return new Import(scope, id);\n  }\n\n  /**\n   * The single user secret rotation application.\n   */\n  private static readonly SINGLE_USER_ROTATION_APPLICATION = secretsmanager.SecretRotationApplication.MONGODB_ROTATION_SINGLE_USER;\n\n  /**\n   * The multi user secret rotation application.\n   */\n  private static readonly MULTI_USER_ROTATION_APPLICATION = secretsmanager.SecretRotationApplication.MONGODB_ROTATION_MULTI_USER;\n\n  /**\n   * Identifier of the cluster\n   */\n  public readonly clusterIdentifier: string;\n\n  /**\n   * The endpoint to use for read/write operations\n   */\n  public readonly clusterEndpoint: Endpoint;\n\n  /**\n   * Endpoint to use for load-balanced read-only operations.\n   */\n  public readonly clusterReadEndpoint: Endpoint;\n\n  /**\n   * The resource id for the cluster; for example: cluster-ABCD1234EFGH5678IJKL90MNOP. The cluster ID uniquely\n   * identifies the cluster and is used in things like IAM authentication policies.\n   * @attribute ClusterResourceId\n   */\n  public readonly clusterResourceIdentifier: string;\n\n  /**\n   * The connections object to implement IConnectable\n   */\n  public readonly connections: ec2.Connections;\n\n  /**\n   * Identifiers of the replicas\n   */\n  public readonly instanceIdentifiers: string[] = [];\n\n  /**\n   * Endpoints which address each individual replica.\n   */\n  public readonly instanceEndpoints: Endpoint[] = [];\n\n  /**\n   * Security group identifier of this database\n   */\n  public readonly securityGroupId: string;\n\n  /**\n   * The secret attached to this cluster\n   */\n  public readonly secret?: secretsmanager.ISecret;\n\n  /**\n   * The underlying CloudFormation resource for a database cluster.\n   */\n  private readonly cluster: CfnDBCluster;\n\n  /**\n   * The VPC where the DB subnet group is created.\n   */\n  private readonly vpc: ec2.IVpc;\n\n  /**\n   * The subnets used by the DB subnet group.\n   */\n  private readonly vpcSubnets?: ec2.SubnetSelection;\n\n  constructor(scope: Construct, id: string, props: DatabaseClusterProps) {\n    super(scope, id);\n\n    this.vpc = props.vpc;\n    this.vpcSubnets = props.vpcSubnets;\n\n    // Determine the subnet(s) to deploy the DocDB cluster to\n    const { subnetIds, internetConnectivityEstablished } = this.vpc.selectSubnets(this.vpcSubnets);\n\n    // DocDB clusters require a subnet group with subnets from at least two AZs.\n    // We cannot test whether the subnets are in different AZs, but at least we can test the amount.\n    // See https://docs.aws.amazon.com/documentdb/latest/developerguide/replication.html#replication.high-availability\n    if (subnetIds.length < 2) {\n      throw new Error(`Cluster requires at least 2 subnets, got ${subnetIds.length}`);\n    }\n\n    const subnetGroup = new CfnDBSubnetGroup(this, 'Subnets', {\n      dbSubnetGroupDescription: `Subnets for ${id} database`,\n      subnetIds,\n    });\n\n    // Create the security group for the DB cluster\n    let securityGroup: ec2.ISecurityGroup;\n    if (props.securityGroup) {\n      securityGroup = props.securityGroup;\n    } else {\n      securityGroup = new ec2.SecurityGroup(this, 'SecurityGroup', {\n        description: 'DocumentDB security group',\n        vpc: this.vpc,\n      });\n      // HACK: Use an escape-hatch to apply a consistent removal policy to the\n      // security group so we don't get errors when trying to delete the stack\n      (securityGroup.node.defaultChild as CfnResource).applyRemovalPolicy(props.removalPolicy, {\n        applyToUpdateReplacePolicy: true,\n      });\n    }\n    this.securityGroupId = securityGroup.securityGroupId;\n\n    // Create the CloudwatchLogsConfiguratoin\n    const enableCloudwatchLogsExports: string[] = [];\n    if (props.exportAuditLogsToCloudWatch) {\n      enableCloudwatchLogsExports.push('audit');\n    }\n    if (props.exportProfilerLogsToCloudWatch) {\n      enableCloudwatchLogsExports.push('profiler');\n    }\n\n    // Create the secret manager secret if no password is specified\n    let secret: DatabaseSecret | undefined;\n    if (!props.masterUser.password) {\n      secret = new DatabaseSecret(this, 'Secret', {\n        username: props.masterUser.username,\n        encryptionKey: props.masterUser.kmsKey,\n        excludeCharacters: props.masterUser.excludeCharacters,\n        secretName: props.masterUser.secretName,\n      });\n    }\n\n    // Default to encrypted storage\n    const storageEncrypted = props.storageEncrypted ?? true;\n\n    if (props.kmsKey && !storageEncrypted) {\n      throw new Error('KMS key supplied but storageEncrypted is false');\n    }\n\n    // Create the DocDB cluster\n    this.cluster = new CfnDBCluster(this, 'Resource', {\n      // Basic\n      engineVersion: props.engineVersion,\n      dbClusterIdentifier: props.dbClusterName,\n      dbSubnetGroupName: subnetGroup.ref,\n      port: props.port,\n      vpcSecurityGroupIds: [this.securityGroupId],\n      dbClusterParameterGroupName: props.parameterGroup?.parameterGroupName,\n      deletionProtection: props.deletionProtection,\n      // Admin\n      masterUsername: secret ? secret.secretValueFromJson('username').toString() : props.masterUser.username,\n      masterUserPassword: secret\n        ? secret.secretValueFromJson('password').toString()\n        : props.masterUser.password!.toString(),\n      // Backup\n      backupRetentionPeriod: props.backup?.retention?.toDays(),\n      preferredBackupWindow: props.backup?.preferredWindow,\n      preferredMaintenanceWindow: props.preferredMaintenanceWindow,\n      // EnableCloudwatchLogsExports\n      enableCloudwatchLogsExports: enableCloudwatchLogsExports.length > 0 ? enableCloudwatchLogsExports : undefined,\n      // Encryption\n      kmsKeyId: props.kmsKey?.keyArn,\n      storageEncrypted,\n    });\n\n    this.cluster.applyRemovalPolicy(props.removalPolicy, {\n      applyToUpdateReplacePolicy: true,\n    });\n\n    this.clusterIdentifier = this.cluster.ref;\n    this.clusterResourceIdentifier = this.cluster.attrClusterResourceId;\n\n    const port = Token.asNumber(this.cluster.attrPort);\n    this.clusterEndpoint = new Endpoint(this.cluster.attrEndpoint, port);\n    this.clusterReadEndpoint = new Endpoint(this.cluster.attrReadEndpoint, port);\n\n    this.setLogRetention(this, props, enableCloudwatchLogsExports);\n\n    if (secret) {\n      this.secret = secret.attach(this);\n    }\n\n    // Create the instances\n    const instanceCount = props.instances ?? DatabaseCluster.DEFAULT_NUM_INSTANCES;\n    if (instanceCount < 1) {\n      throw new Error('At least one instance is required');\n    }\n\n    for (let i = 0; i < instanceCount; i++) {\n      const instanceIndex = i + 1;\n\n      const instanceIdentifier = props.instanceIdentifierBase != null ? `${props.instanceIdentifierBase}${instanceIndex}`\n        : props.dbClusterName != null ? `${props.dbClusterName}instance${instanceIndex}` : undefined;\n\n      const instance = new CfnDBInstance(this, `Instance${instanceIndex}`, {\n        // Link to cluster\n        dbClusterIdentifier: this.cluster.ref,\n        dbInstanceIdentifier: instanceIdentifier,\n        // Instance properties\n        dbInstanceClass: databaseInstanceType(props.instanceType),\n      });\n\n      instance.applyRemovalPolicy(props.removalPolicy, {\n        applyToUpdateReplacePolicy: true,\n      });\n\n      // We must have a dependency on the NAT gateway provider here to create\n      // things in the right order.\n      instance.node.addDependency(internetConnectivityEstablished);\n\n      this.instanceIdentifiers.push(instance.ref);\n      this.instanceEndpoints.push(new Endpoint(instance.attrEndpoint, port));\n    }\n\n    this.connections = new ec2.Connections({\n      defaultPort: ec2.Port.tcp(port),\n      securityGroups: [securityGroup],\n    });\n  }\n\n  /**\n   * Sets up CloudWatch log retention if configured.\n   */\n  private setLogRetention(cluster: DatabaseCluster, props: DatabaseClusterProps, cloudwatchLogsExports: string[]) {\n    if (props.cloudWatchLogsRetention) {\n      for (const log of cloudwatchLogsExports) {\n        new logs.LogRetention(cluster, `LogRetention${log}`, {\n          logGroupName: `/aws/docdb/${cluster.clusterIdentifier}/${log}`,\n          retention: props.cloudWatchLogsRetention,\n          role: props.cloudWatchLogsRetentionRole,\n        });\n      }\n    }\n  }\n\n  /**\n   * Adds the single user rotation of the master password to this cluster.\n   *\n   * @param [automaticallyAfter=Duration.days(30)] Specifies the number of days after the previous rotation\n   * before Secrets Manager triggers the next automatic rotation.\n   */\n  public addRotationSingleUser(automaticallyAfter?: Duration): secretsmanager.SecretRotation {\n    if (!this.secret) {\n      throw new Error('Cannot add single user rotation for a cluster without secret.');\n    }\n\n    const id = 'RotationSingleUser';\n    const existing = this.node.tryFindChild(id);\n    if (existing) {\n      throw new Error('A single user rotation was already added to this cluster.');\n    }\n\n    return new secretsmanager.SecretRotation(this, id, {\n      secret: this.secret,\n      automaticallyAfter,\n      application: DatabaseCluster.SINGLE_USER_ROTATION_APPLICATION,\n      excludeCharacters: (this.node.tryFindChild('Secret') as DatabaseSecret)._excludedCharacters,\n      vpc: this.vpc,\n      vpcSubnets: this.vpcSubnets,\n      target: this,\n    });\n  }\n\n  /**\n   * Adds the multi user rotation to this cluster.\n   */\n  public addRotationMultiUser(id: string, options: RotationMultiUserOptions): secretsmanager.SecretRotation {\n    if (!this.secret) {\n      throw new Error('Cannot add multi user rotation for a cluster without secret.');\n    }\n    return new secretsmanager.SecretRotation(this, id, {\n      secret: options.secret,\n      masterSecret: this.secret,\n      automaticallyAfter: options.automaticallyAfter,\n      excludeCharacters: (this.node.tryFindChild('Secret') as DatabaseSecret)._excludedCharacters,\n      application: DatabaseCluster.MULTI_USER_ROTATION_APPLICATION,\n      vpc: this.vpc,\n      vpcSubnets: this.vpcSubnets,\n      target: this,\n    });\n  }\n\n  /**\n   * Adds security groups to this cluster.\n   * @param securityGroups The security groups to add.\n   */\n  public addSecurityGroups(...securityGroups: ec2.ISecurityGroup[]): void {\n    if (this.cluster.vpcSecurityGroupIds === undefined) {\n      this.cluster.vpcSecurityGroupIds = [];\n    }\n    this.cluster.vpcSecurityGroupIds.push(...securityGroups.map(sg => sg.securityGroupId));\n  }\n}\n\n/**\n * Turn a regular instance type into a database instance type\n */\nfunction databaseInstanceType(instanceType: ec2.InstanceType) {\n  return 'db.' + instanceType.toString();\n}\n"],
  "mappings": "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",
  "names": []
}
