{
  "version": 3,
  "sources": ["source-action.ts"],
  "sourcesContent": ["import * as codecommit from '../../../aws-codecommit';\nimport * as codepipeline from '../../../aws-codepipeline';\nimport * as targets from '../../../aws-events-targets';\nimport * as iam from '../../../aws-iam';\nimport { Names, Stack, Token, TokenComparison } from '../../../core';\nimport { Action } from '../action';\nimport { sourceArtifactBounds } from '../common';\n\n// keep this import separate from other imports to reduce chance for merge conflicts with v2-main\n// eslint-disable-next-line no-duplicate-imports, import/order\nimport { Construct } from 'constructs';\n\n/**\n * How should the CodeCommit Action detect changes.\n * This is the type of the {@link CodeCommitSourceAction.trigger} property.\n */\nexport enum CodeCommitTrigger {\n  /**\n   * The Action will never detect changes -\n   * the Pipeline it's part of will only begin a run when explicitly started.\n   */\n  NONE = 'None',\n\n  /**\n   * CodePipeline will poll the repository to detect changes.\n   */\n  POLL = 'Poll',\n\n  /**\n   * CodePipeline will use CloudWatch Events to be notified of changes.\n   * This is the default method of detecting changes.\n   */\n  EVENTS = 'Events',\n}\n\n/**\n * The CodePipeline variables emitted by the CodeCommit source Action.\n */\nexport interface CodeCommitSourceVariables {\n  /** The name of the repository this action points to. */\n  readonly repositoryName: string;\n\n  /** The name of the branch this action tracks. */\n  readonly branchName: string;\n\n  /** The date the currently last commit on the tracked branch was authored, in ISO-8601 format. */\n  readonly authorDate: string;\n\n  /** The date the currently last commit on the tracked branch was committed, in ISO-8601 format. */\n  readonly committerDate: string;\n\n  /** The SHA1 hash of the currently last commit on the tracked branch. */\n  readonly commitId: string;\n\n  /** The message of the currently last commit on the tracked branch. */\n  readonly commitMessage: string;\n}\n\n/**\n * Construction properties of the {@link CodeCommitSourceAction CodeCommit source CodePipeline Action}.\n */\nexport interface CodeCommitSourceActionProps extends codepipeline.CommonAwsActionProps {\n  /**\n   *\n   */\n  readonly output: codepipeline.Artifact;\n\n  /**\n   * @default 'master'\n   */\n  readonly branch?: string;\n\n  /**\n   * How should CodePipeline detect source changes for this Action.\n   *\n   * @default CodeCommitTrigger.EVENTS\n   */\n  readonly trigger?: CodeCommitTrigger;\n\n  /**\n   * The CodeCommit repository.\n   */\n  readonly repository: codecommit.IRepository;\n\n  /**\n   * Role to be used by on commit event rule.\n   * Used only when trigger value is CodeCommitTrigger.EVENTS.\n   *\n   * @default a new role will be created.\n   */\n  readonly eventRole?: iam.IRole;\n\n  /**\n   * Whether the output should be the contents of the repository\n   * (which is the default),\n   * or a link that allows CodeBuild to clone the repository before building.\n   *\n   * **Note**: if this option is true,\n   * then only CodeBuild actions can use the resulting {@link output}.\n   *\n   * @default false\n   * @see https://docs.aws.amazon.com/codepipeline/latest/userguide/action-reference-CodeCommit.html\n   */\n  readonly codeBuildCloneOutput?: boolean;\n}\n\n/**\n * CodePipeline Source that is provided by an AWS CodeCommit repository.\n *\n * If the CodeCommit repository is in a different account, you must use\n * `CodeCommitTrigger.EVENTS` to trigger the pipeline.\n *\n * (That is because the Pipeline structure normally only has a `RepositoryName`\n * field, and that is not enough for the pipeline to locate the repository's\n * source account. However, if the pipeline is triggered via an EventBridge\n * event, the event itself has the full repository ARN in there, allowing the\n * pipeline to locate the repository).\n */\nexport class CodeCommitSourceAction extends Action {\n  /**\n   * The name of the property that holds the ARN of the CodeCommit Repository\n   * inside of the CodePipeline Artifact's metadata.\n   *\n   * @internal\n   */\n  public static readonly _FULL_CLONE_ARN_PROPERTY = 'CodeCommitCloneRepositoryArn';\n\n  private readonly branch: string;\n  private readonly props: CodeCommitSourceActionProps;\n\n  constructor(props: CodeCommitSourceActionProps) {\n    const branch = props.branch ?? 'master';\n    if (!branch) {\n      throw new Error(\"'branch' parameter cannot be an empty string\");\n    }\n\n    if (props.codeBuildCloneOutput === true) {\n      props.output.setMetadata(CodeCommitSourceAction._FULL_CLONE_ARN_PROPERTY, props.repository.repositoryArn);\n    }\n\n    super({\n      ...props,\n      resource: props.repository,\n      category: codepipeline.ActionCategory.SOURCE,\n      provider: 'CodeCommit',\n      artifactBounds: sourceArtifactBounds(),\n      outputs: [props.output],\n    });\n\n    this.branch = branch;\n    this.props = props;\n  }\n\n  /** The variables emitted by this action. */\n  public get variables(): CodeCommitSourceVariables {\n    return {\n      repositoryName: this.variableExpression('RepositoryName'),\n      branchName: this.variableExpression('BranchName'),\n      authorDate: this.variableExpression('AuthorDate'),\n      committerDate: this.variableExpression('CommitterDate'),\n      commitId: this.variableExpression('CommitId'),\n      commitMessage: this.variableExpression('CommitMessage'),\n    };\n  }\n\n  protected bound(_scope: Construct, stage: codepipeline.IStage, options: codepipeline.ActionBindOptions):\n  codepipeline.ActionConfig {\n    const createEvent = this.props.trigger === undefined ||\n      this.props.trigger === CodeCommitTrigger.EVENTS;\n    if (createEvent) {\n      const eventId = this.generateEventId(stage);\n      this.props.repository.onCommit(eventId, {\n        target: new targets.CodePipeline(stage.pipeline, {\n          eventRole: this.props.eventRole,\n        }),\n        branches: [this.branch],\n      });\n    }\n\n    // the Action will write the contents of the Git repository to the Bucket,\n    // so its Role needs write permissions to the Pipeline Bucket\n    options.bucket.grantReadWrite(options.role);\n    // when this action is cross-account,\n    // the Role needs the s3:PutObjectAcl permission for some not yet fully understood reason\n    if (Token.compareStrings(this.props.repository.env.account, Stack.of(stage.pipeline).account) === TokenComparison.DIFFERENT) {\n      options.bucket.grantPutAcl(options.role);\n    }\n\n    // https://docs.aws.amazon.com/codecommit/latest/userguide/auth-and-access-control-permissions-reference.html#aa-acp\n    options.role.addToPrincipalPolicy(new iam.PolicyStatement({\n      resources: [this.props.repository.repositoryArn],\n      actions: [\n        'codecommit:GetBranch',\n        'codecommit:GetCommit',\n        'codecommit:UploadArchive',\n        'codecommit:GetUploadArchiveStatus',\n        'codecommit:CancelUploadArchive',\n        ...(this.props.codeBuildCloneOutput === true ? ['codecommit:GetRepository'] : []),\n      ],\n    }));\n\n    return {\n      configuration: {\n        RepositoryName: this.props.repository.repositoryName,\n        BranchName: this.branch,\n        PollForSourceChanges: this.props.trigger === CodeCommitTrigger.POLL,\n        OutputArtifactFormat: this.props.codeBuildCloneOutput === true\n          ? 'CODEBUILD_CLONE_REF'\n          : undefined,\n      },\n    };\n  }\n\n  private generateEventId(stage: codepipeline.IStage): string {\n    const baseId = Names.nodeUniqueId(stage.pipeline.node);\n    if (Token.isUnresolved(this.branch)) {\n      let candidate = '';\n      let counter = 0;\n      do {\n        candidate = this.eventIdFromPrefix(`${baseId}${counter}`);\n        counter += 1;\n      } while (this.props.repository.node.tryFindChild(candidate) !== undefined);\n      return candidate;\n    } else {\n      const branchIdDisambiguator = this.branch === 'master' ? '' : `-${this.branch}-`;\n      return this.eventIdFromPrefix(`${baseId}${branchIdDisambiguator}`);\n    }\n  }\n\n  private eventIdFromPrefix(eventIdPrefix: string) {\n    return `${eventIdPrefix}EventRule`;\n  }\n}\n"],
  "mappings": "0PACA,aAAA,QAAA,2BAAA,EACA,QAAA,QAAA,6BAAA,EACA,IAAA,QAAA,kBAAA,EACA,OAAA,QAAA,eAAA,EACA,SAAA,QAAA,WAAA,EACA,SAAA,QAAA,WAAA,EAUA,GAAY,mBAAZ,AAAA,UAAY,mBAAiB,CAK3B,mBAAA,KAAA,OAKA,mBAAA,KAAA,OAMA,mBAAA,OAAA,QACF,GAjBY,kBAAA,QAAA,mBAAA,SAAA,kBAAiB,CAAA,EAAA,EAsG7B,MAAa,8BAA+B,UAAA,MAAM,CAYhD,YAAY,MAAkC,wGAC5C,KAAM,QAAM,IAAG,MAAM,UAAM,MAAA,KAAA,OAAA,GAAI,SAC/B,GAAI,CAAC,OACH,KAAM,IAAI,OAAM,8CAA8C,EAGhE,AAAI,MAAM,uBAAyB,IACjC,MAAM,OAAO,YAAY,uBAAuB,yBAA0B,MAAM,WAAW,aAAa,EAG1G,MAAM,IACD,MACH,SAAU,MAAM,WAChB,SAAU,aAAa,eAAe,OACtC,SAAU,aACV,eAAgB,SAAA,qBAAoB,EACpC,QAAS,CAAC,MAAM,MAAM,EACvB,EAED,KAAK,OAAS,OACd,KAAK,MAAQ,SAIJ,YAAS,CAClB,MAAO,CACL,eAAgB,KAAK,mBAAmB,gBAAgB,EACxD,WAAY,KAAK,mBAAmB,YAAY,EAChD,WAAY,KAAK,mBAAmB,YAAY,EAChD,cAAe,KAAK,mBAAmB,eAAe,EACtD,SAAU,KAAK,mBAAmB,UAAU,EAC5C,cAAe,KAAK,mBAAmB,eAAe,GAIhD,MAAM,OAAmB,MAA4B,QAAuC,CAIpG,sJAFoB,KAAK,MAAM,UAAY,QACzC,KAAK,MAAM,UAAY,kBAAkB,OAC1B,CACf,KAAM,SAAU,KAAK,gBAAgB,KAAK,EAC1C,KAAK,MAAM,WAAW,SAAS,QAAS,CACtC,OAAQ,GAAI,SAAQ,aAAa,MAAM,SAAU,CAC/C,UAAW,KAAK,MAAM,UACvB,EACD,SAAU,CAAC,KAAK,MAAM,EACvB,EAKH,eAAQ,OAAO,eAAe,QAAQ,IAAI,EAGtC,OAAA,MAAM,eAAe,KAAK,MAAM,WAAW,IAAI,QAAS,OAAA,MAAM,GAAG,MAAM,QAAQ,EAAE,OAAO,IAAM,OAAA,gBAAgB,WAChH,QAAQ,OAAO,YAAY,QAAQ,IAAI,EAIzC,QAAQ,KAAK,qBAAqB,GAAI,KAAI,gBAAgB,CACxD,UAAW,CAAC,KAAK,MAAM,WAAW,aAAa,EAC/C,QAAS,CACP,uBACA,uBACA,2BACA,oCACA,iCACA,GAAI,KAAK,MAAM,uBAAyB,GAAO,CAAC,0BAA0B,EAAI,CAAA,GAEjF,CAAC,EAEK,CACL,cAAe,CACb,eAAgB,KAAK,MAAM,WAAW,eACtC,WAAY,KAAK,OACjB,qBAAsB,KAAK,MAAM,UAAY,kBAAkB,KAC/D,qBAAsB,KAAK,MAAM,uBAAyB,GACtD,sBACA,SAKF,gBAAgB,MAA0B,CAChD,KAAM,QAAS,OAAA,MAAM,aAAa,MAAM,SAAS,IAAI,EACrD,GAAI,OAAA,MAAM,aAAa,KAAK,MAAM,EAAG,CACnC,GAAI,WAAY,GACZ,QAAU,EACd,EACE,WAAY,KAAK,kBAAkB,GAAG,SAAS,SAAS,EACxD,SAAW,QACJ,KAAK,MAAM,WAAW,KAAK,aAAa,SAAS,IAAM,QAChE,MAAO,eACF,CACL,KAAM,uBAAwB,KAAK,SAAW,SAAW,GAAK,IAAI,KAAK,UACvE,MAAO,MAAK,kBAAkB,GAAG,SAAS,uBAAuB,GAI7D,kBAAkB,cAAqB,CAC7C,MAAO,GAAG,0BAhHd,QAAA,uBAAA,6JAOyB,uBAAA,yBAA2B",
  "names": []
}
