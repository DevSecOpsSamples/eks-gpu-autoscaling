{
  "version": 3,
  "sources": ["notifications-resource.ts"],
  "sourcesContent": ["import * as iam from '../../../aws-iam';\nimport * as cdk from '../../../core';\nimport { Construct } from 'constructs';\nimport { Bucket, IBucket, EventType, NotificationKeyFilter } from '../bucket';\nimport { BucketNotificationDestinationType, IBucketNotificationDestination } from '../destination';\nimport { NotificationsResourceHandler } from './notifications-resource-handler';\n\ninterface NotificationsProps {\n  /**\n   * The bucket to manage notifications for.\n   */\n  bucket: IBucket;\n\n  /**\n   * The role to be used by the lambda handler\n   */\n  handlerRole?: iam.IRole;\n}\n\n/**\n * A custom CloudFormation resource that updates bucket notifications for a\n * bucket. The reason we need it is because the AWS::S3::Bucket notification\n * configuration is defined on the bucket itself, which makes it impossible to\n * provision notifications at the same time as the target (since\n * PutBucketNotifications validates the targets).\n *\n * Since only a single BucketNotifications resource is allowed for each Bucket,\n * this construct is not exported in the public API of this module. Instead, it\n * is created just-in-time by `s3.Bucket.onEvent`, so a 1:1 relationship is\n * ensured.\n *\n * @see\n * https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-notificationconfig.html\n */\nexport class BucketNotifications extends Construct {\n  private eventBridgeEnabled = false;\n  private readonly lambdaNotifications = new Array<LambdaFunctionConfiguration>();\n  private readonly queueNotifications = new Array<QueueConfiguration>();\n  private readonly topicNotifications = new Array<TopicConfiguration>();\n  private resource?: cdk.CfnResource;\n  private readonly bucket: IBucket;\n  private readonly handlerRole?: iam.IRole;\n\n  constructor(scope: Construct, id: string, props: NotificationsProps) {\n    super(scope, id);\n    this.bucket = props.bucket;\n    this.handlerRole = props.handlerRole;\n  }\n\n  /**\n   * Adds a notification subscription for this bucket.\n   * If this is the first notification, a BucketNotification resource is added to the stack.\n   *\n   * @param event The type of event\n   * @param target The target construct\n   * @param filters A set of S3 key filters\n   */\n  public addNotification(event: EventType, target: IBucketNotificationDestination, ...filters: NotificationKeyFilter[]) {\n    const resource = this.createResourceOnce();\n\n    // resolve target. this also provides an opportunity for the target to e.g. update\n    // policies to allow this notification to happen.\n    const targetProps = target.bind(this, this.bucket);\n    const commonConfig: CommonConfiguration = {\n      Events: [event],\n      Filter: renderFilters(filters),\n    };\n\n    // if the target specifies any dependencies, add them to the custom resource.\n    // for example, the SNS topic policy must be created /before/ the notification resource.\n    // otherwise, S3 won't be able to confirm the subscription.\n    if (targetProps.dependencies) {\n      resource.node.addDependency(...targetProps.dependencies);\n    }\n\n    // based on the target type, add the the correct configurations array\n    switch (targetProps.type) {\n      case BucketNotificationDestinationType.LAMBDA:\n        this.lambdaNotifications.push({ ...commonConfig, LambdaFunctionArn: targetProps.arn });\n        break;\n\n      case BucketNotificationDestinationType.QUEUE:\n        this.queueNotifications.push({ ...commonConfig, QueueArn: targetProps.arn });\n        break;\n\n      case BucketNotificationDestinationType.TOPIC:\n        this.topicNotifications.push({ ...commonConfig, TopicArn: targetProps.arn });\n        break;\n\n      default:\n        throw new Error('Unsupported notification target type:' + BucketNotificationDestinationType[targetProps.type]);\n    }\n  }\n\n  public enableEventBridgeNotification() {\n    this.createResourceOnce();\n    this.eventBridgeEnabled = true;\n  }\n\n  private renderNotificationConfiguration(): NotificationConfiguration {\n    return {\n      EventBridgeConfiguration: this.eventBridgeEnabled ? {} : undefined,\n      LambdaFunctionConfigurations: this.lambdaNotifications.length > 0 ? this.lambdaNotifications : undefined,\n      QueueConfigurations: this.queueNotifications.length > 0 ? this.queueNotifications : undefined,\n      TopicConfigurations: this.topicNotifications.length > 0 ? this.topicNotifications : undefined,\n    };\n  }\n\n  /**\n   * Defines the bucket notifications resources in the stack only once.\n   * This is called lazily as we add notifications, so that if notifications are not added,\n   * there is no notifications resource.\n   */\n  private createResourceOnce() {\n    if (!this.resource) {\n      const handler = NotificationsResourceHandler.singleton(this, {\n        role: this.handlerRole,\n      });\n\n      const managed = this.bucket instanceof Bucket;\n\n      if (!managed) {\n        handler.addToRolePolicy(new iam.PolicyStatement({\n          actions: ['s3:GetBucketNotification'],\n          resources: ['*'],\n        }));\n      }\n\n      this.resource = new cdk.CfnResource(this, 'Resource', {\n        type: 'Custom::S3BucketNotifications',\n        properties: {\n          ServiceToken: handler.functionArn,\n          BucketName: this.bucket.bucketName,\n          NotificationConfiguration: cdk.Lazy.any({ produce: () => this.renderNotificationConfiguration() }),\n          Managed: managed,\n        },\n      });\n    }\n\n    return this.resource;\n  }\n}\n\nfunction renderFilters(filters?: NotificationKeyFilter[]): Filter | undefined {\n  if (!filters || filters.length === 0) {\n    return undefined;\n  }\n\n  const renderedRules = new Array<FilterRule>();\n  let hasPrefix = false;\n  let hasSuffix = false;\n\n  for (const rule of filters) {\n    if (!rule.suffix && !rule.prefix) {\n      throw new Error('NotificationKeyFilter must specify `prefix` and/or `suffix`');\n    }\n\n    if (rule.suffix) {\n      if (hasSuffix) {\n        throw new Error('Cannot specify more than one suffix rule in a filter.');\n      }\n      renderedRules.push({ Name: 'suffix', Value: rule.suffix });\n      hasSuffix = true;\n    }\n\n    if (rule.prefix) {\n      if (hasPrefix) {\n        throw new Error('Cannot specify more than one prefix rule in a filter.');\n      }\n      renderedRules.push({ Name: 'prefix', Value: rule.prefix });\n      hasPrefix = true;\n    }\n  }\n\n  return {\n    Key: {\n      FilterRules: renderedRules,\n    },\n  };\n}\n\ninterface NotificationConfiguration {\n  EventBridgeConfiguration?: EventBridgeConfiguration;\n  LambdaFunctionConfigurations?: LambdaFunctionConfiguration[];\n  QueueConfigurations?: QueueConfiguration[];\n  TopicConfigurations?: TopicConfiguration[];\n}\n\ninterface CommonConfiguration {\n  Id?: string;\n  Events: EventType[];\n  Filter?: Filter\n}\n\ninterface EventBridgeConfiguration { }\n\ninterface LambdaFunctionConfiguration extends CommonConfiguration {\n  LambdaFunctionArn: string;\n}\n\ninterface QueueConfiguration extends CommonConfiguration {\n  QueueArn: string;\n}\n\ninterface TopicConfiguration extends CommonConfiguration {\n  TopicArn: string;\n}\n\ninterface FilterRule {\n  Name: 'prefix' | 'suffix';\n  Value: string;\n}\n\ninterface Filter {\n  Key: { FilterRules: FilterRule[] }\n}\n"],
  "mappings": "uGAAA,KAAA,KAAA,QAAA,kBAAA,EACA,IAAA,QAAA,eAAA,EACA,aAAA,QAAA,YAAA,EACA,SAAA,QAAA,WAAA,EACA,cAAA,QAAA,gBAAA,EACA,iCAAA,QAAA,kCAAA,EA6BA,MAAa,2BAA4B,cAAA,SAAS,CAShD,YAAY,MAAkB,GAAY,MAAyB,CACjE,MAAM,MAAO,EAAE,EATT,KAAA,mBAAqB,GACZ,KAAA,oBAAsB,GAAI,OAC1B,KAAA,mBAAqB,GAAI,OACzB,KAAA,mBAAqB,GAAI,OAOxC,KAAK,OAAS,MAAM,OACpB,KAAK,YAAc,MAAM,YAWpB,gBAAgB,MAAkB,UAA2C,QAAgC,CAClH,KAAM,UAAW,KAAK,mBAAkB,EAIlC,YAAc,OAAO,KAAK,KAAM,KAAK,MAAM,EAC3C,aAAoC,CACxC,OAAQ,CAAC,KAAK,EACd,OAAQ,cAAc,OAAO,GAW/B,OALI,YAAY,cACd,SAAS,KAAK,cAAc,GAAG,YAAY,YAAY,EAIjD,YAAY,UACb,eAAA,kCAAkC,OACrC,KAAK,oBAAoB,KAAK,IAAK,aAAc,kBAAmB,YAAY,GAAG,CAAE,EACrF,UAEG,eAAA,kCAAkC,MACrC,KAAK,mBAAmB,KAAK,IAAK,aAAc,SAAU,YAAY,GAAG,CAAE,EAC3E,UAEG,eAAA,kCAAkC,MACrC,KAAK,mBAAmB,KAAK,IAAK,aAAc,SAAU,YAAY,GAAG,CAAE,EAC3E,cAGA,KAAM,IAAI,OAAM,wCAA0C,cAAA,kCAAkC,YAAY,KAAK,GAI5G,+BAA6B,CAClC,KAAK,mBAAkB,EACvB,KAAK,mBAAqB,GAGpB,iCAA+B,CACrC,MAAO,CACL,yBAA0B,KAAK,mBAAqB,CAAA,EAAK,OACzD,6BAA8B,KAAK,oBAAoB,OAAS,EAAI,KAAK,oBAAsB,OAC/F,oBAAqB,KAAK,mBAAmB,OAAS,EAAI,KAAK,mBAAqB,OACpF,oBAAqB,KAAK,mBAAmB,OAAS,EAAI,KAAK,mBAAqB,QAShF,oBAAkB,CACxB,GAAI,CAAC,KAAK,SAAU,CAClB,KAAM,SAAU,iCAAA,6BAA6B,UAAU,KAAM,CAC3D,KAAM,KAAK,YACZ,EAEK,QAAU,KAAK,iBAAkB,UAAA,OAEvC,AAAK,SACH,QAAQ,gBAAgB,GAAI,KAAI,gBAAgB,CAC9C,QAAS,CAAC,0BAA0B,EACpC,UAAW,CAAC,GAAG,EAChB,CAAC,EAGJ,KAAK,SAAW,GAAI,KAAI,YAAY,KAAM,WAAY,CACpD,KAAM,gCACN,WAAY,CACV,aAAc,QAAQ,YACtB,WAAY,KAAK,OAAO,WACxB,0BAA2B,IAAI,KAAK,IAAI,CAAE,QAAS,IAAM,KAAK,gCAA+B,CAAE,CAAE,EACjG,QAAS,SAEZ,EAGH,MAAO,MAAK,UAzGhB,QAAA,oBAAA,oBA6GA,uBAAuB,QAAiC,CACtD,GAAI,CAAC,SAAW,QAAQ,SAAW,EACjC,OAGF,KAAM,eAAgB,GAAI,OAC1B,GAAI,WAAY,GACZ,UAAY,GAEhB,SAAW,QAAQ,SAAS,CAC1B,GAAI,CAAC,KAAK,QAAU,CAAC,KAAK,OACxB,KAAM,IAAI,OAAM,6DAA6D,EAG/E,GAAI,KAAK,OAAQ,CACf,GAAI,UACF,KAAM,IAAI,OAAM,uDAAuD,EAEzE,cAAc,KAAK,CAAE,KAAM,SAAU,MAAO,KAAK,MAAM,CAAE,EACzD,UAAY,GAGd,GAAI,KAAK,OAAQ,CACf,GAAI,UACF,KAAM,IAAI,OAAM,uDAAuD,EAEzE,cAAc,KAAK,CAAE,KAAM,SAAU,MAAO,KAAK,MAAM,CAAE,EACzD,UAAY,IAIhB,MAAO,CACL,IAAK,CACH,YAAa,eAGnB",
  "names": []
}
