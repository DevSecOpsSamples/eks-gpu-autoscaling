{
  "version": 3,
  "sources": ["rule.ts"],
  "sourcesContent": ["import { IRole, PolicyStatement, Role, ServicePrincipal } from '../../aws-iam';\nimport { App, IResource, Lazy, Names, Resource, Stack, Token, PhysicalName, ArnFormat } from '../../core';\nimport { Node, Construct } from 'constructs';\nimport { IEventBus } from './event-bus';\nimport { EventPattern } from './event-pattern';\nimport { CfnEventBusPolicy, CfnRule } from './events.generated';\nimport { IRule } from './rule-ref';\nimport { Schedule } from './schedule';\nimport { IRuleTarget } from './target';\nimport { mergeEventPattern, renderEventPattern, sameEnvDimension } from './util';\n\n/**\n * Properties for defining an EventBridge Rule\n */\nexport interface RuleProps {\n  /**\n   * A description of the rule's purpose.\n   *\n   * @default - No description.\n   */\n  readonly description?: string;\n\n  /**\n   * A name for the rule.\n   *\n   * @default - AWS CloudFormation generates a unique physical ID and uses that ID\n   * for the rule name. For more information, see Name Type.\n   */\n  readonly ruleName?: string;\n\n  /**\n   * Indicates whether the rule is enabled.\n   *\n   * @default true\n   */\n  readonly enabled?: boolean;\n\n  /**\n   * The schedule or rate (frequency) that determines when EventBridge\n   * runs the rule. For more information, see Schedule Expression Syntax for\n   * Rules in the Amazon EventBridge User Guide.\n   *\n   * @see https://docs.aws.amazon.com/eventbridge/latest/userguide/scheduled-events.html\n   *\n   * You must specify this property, the `eventPattern` property, or both.\n   *\n   * @default - None.\n   */\n  readonly schedule?: Schedule;\n\n  /**\n   * Describes which events EventBridge routes to the specified target.\n   * These routed events are matched events. For more information, see Events\n   * and Event Patterns in the Amazon EventBridge User Guide.\n   *\n   * @see\n   * https://docs.aws.amazon.com/eventbridge/latest/userguide/eventbridge-and-event-patterns.html\n   *\n   * You must specify this property (either via props or via\n   * `addEventPattern`), the `scheduleExpression` property, or both. The\n   * method `addEventPattern` can be used to add filter values to the event\n   * pattern.\n   *\n   * @default - None.\n   */\n  readonly eventPattern?: EventPattern;\n\n  /**\n   * Targets to invoke when this rule matches an event.\n   *\n   * Input will be the full matched event. If you wish to specify custom\n   * target input, use `addTarget(target[, inputOptions])`.\n   *\n   * @default - No targets.\n   */\n  readonly targets?: IRuleTarget[];\n\n  /**\n   * The event bus to associate with this rule.\n   *\n   * @default - The default event bus.\n   */\n  readonly eventBus?: IEventBus;\n}\n\n/**\n * Defines an EventBridge Rule in this stack.\n *\n * @resource AWS::Events::Rule\n */\nexport class Rule extends Resource implements IRule {\n\n  /**\n   * Import an existing EventBridge Rule provided an ARN\n   *\n   * @param scope The parent creating construct (usually `this`).\n   * @param id The construct's name.\n   * @param eventRuleArn Event Rule ARN (i.e. arn:aws:events:<region>:<account-id>:rule/MyScheduledRule).\n   */\n  public static fromEventRuleArn(scope: Construct, id: string, eventRuleArn: string): IRule {\n    const parts = Stack.of(scope).splitArn(eventRuleArn, ArnFormat.SLASH_RESOURCE_NAME);\n\n    class Import extends Resource implements IRule {\n      public ruleArn = eventRuleArn;\n      public ruleName = parts.resourceName || '';\n    }\n    return new Import(scope, id);\n  }\n\n  public readonly ruleArn: string;\n  public readonly ruleName: string;\n\n  private readonly targets = new Array<CfnRule.TargetProperty>();\n  private readonly eventPattern: EventPattern = { };\n  private readonly scheduleExpression?: string;\n  private readonly description?: string;\n\n  /** Set to keep track of what target accounts and regions we've already created event buses for */\n  private readonly _xEnvTargetsAdded = new Set<string>();\n\n  constructor(scope: Construct, id: string, props: RuleProps = { }) {\n    super(scope, id, {\n      physicalName: props.ruleName,\n    });\n\n    if (props.eventBus && props.schedule) {\n      throw new Error('Cannot associate rule with \\'eventBus\\' when using \\'schedule\\'');\n    }\n\n    this.description = props.description;\n    this.scheduleExpression = props.schedule?.expressionString;\n\n    // add a warning on synth when minute is not defined in a cron schedule\n    props.schedule?._bind(this);\n\n    const resource = new CfnRule(this, 'Resource', {\n      name: this.physicalName,\n      description: this.description,\n      state: props.enabled == null ? 'ENABLED' : (props.enabled ? 'ENABLED' : 'DISABLED'),\n      scheduleExpression: this.scheduleExpression,\n      eventPattern: Lazy.any({ produce: () => this._renderEventPattern() }),\n      targets: Lazy.any({ produce: () => this.renderTargets() }),\n      eventBusName: props.eventBus && props.eventBus.eventBusName,\n    });\n\n    this.ruleArn = this.getResourceArnAttribute(resource.attrArn, {\n      service: 'events',\n      resource: 'rule',\n      resourceName: this.physicalName,\n    });\n    this.ruleName = this.getResourceNameAttribute(resource.ref);\n\n    this.addEventPattern(props.eventPattern);\n\n    for (const target of props.targets || []) {\n      this.addTarget(target);\n    }\n\n    this.node.addValidation({ validate: () => this.validateRule() });\n  }\n\n  /**\n   * Adds a target to the rule. The abstract class RuleTarget can be extended to define new\n   * targets.\n   *\n   * No-op if target is undefined.\n   */\n  public addTarget(target?: IRuleTarget): void {\n    if (!target) { return; }\n\n    // Simply increment id for each `addTarget` call. This is guaranteed to be unique.\n    const autoGeneratedId = `Target${this.targets.length}`;\n\n    const targetProps = target.bind(this, autoGeneratedId);\n    const inputProps = targetProps.input && targetProps.input.bind(this);\n\n    const roleArn = targetProps.role?.roleArn;\n    const id = targetProps.id || autoGeneratedId;\n\n    if (targetProps.targetResource) {\n      const targetStack = Stack.of(targetProps.targetResource);\n\n      const targetAccount = (targetProps.targetResource as IResource).env?.account || targetStack.account;\n      const targetRegion = (targetProps.targetResource as IResource).env?.region || targetStack.region;\n\n      const sourceStack = Stack.of(this);\n      const sourceAccount = sourceStack.account;\n      const sourceRegion = sourceStack.region;\n\n      // if the target is in a different account or region and is defined in this CDK App\n      // we can generate all the needed components:\n      // - forwarding rule in the source stack (target: default event bus of the receiver region)\n      // - eventbus permissions policy (creating an extra stack)\n      // - receiver rule in the target stack (target: the actual target)\n      if (!sameEnvDimension(sourceAccount, targetAccount) || !sameEnvDimension(sourceRegion, targetRegion)) {\n        // cross-account and/or cross-region event - strap in, this works differently than regular events!\n        // based on:\n        // https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-cross-account.html\n\n        // for cross-account or cross-region events, we require a concrete target account and region\n        if (!targetAccount || Token.isUnresolved(targetAccount)) {\n          throw new Error('You need to provide a concrete account for the target stack when using cross-account or cross-region events');\n        }\n        if (!targetRegion || Token.isUnresolved(targetRegion)) {\n          throw new Error('You need to provide a concrete region for the target stack when using cross-account or cross-region events');\n        }\n        if (Token.isUnresolved(sourceAccount)) {\n          throw new Error('You need to provide a concrete account for the source stack when using cross-account or cross-region events');\n        }\n\n        // Don't exactly understand why this code was here (seems unlikely this rule would be violated), but\n        // let's leave it in nonetheless.\n        const sourceApp = this.node.root;\n        if (!sourceApp || !App.isApp(sourceApp)) {\n          throw new Error('Event stack which uses cross-account or cross-region targets must be part of a CDK app');\n        }\n        const targetApp = Node.of(targetProps.targetResource).root;\n        if (!targetApp || !App.isApp(targetApp)) {\n          throw new Error('Target stack which uses cross-account or cross-region event targets must be part of a CDK app');\n        }\n        if (sourceApp !== targetApp) {\n          throw new Error('Event stack and target stack must belong to the same CDK app');\n        }\n\n        // The target of this Rule will be the default event bus of the target environment\n        this.ensureXEnvTargetEventBus(targetStack, targetAccount, targetRegion, id);\n\n        // The actual rule lives in the target stack. Other than the account, it's identical to this one,\n        // but only evaluated at render time (via a special subclass).\n        //\n        // FIXME: the MirrorRule is a bit silly, forwarding the exact same event to another event bus\n        // and trigger on it there (there will be issues with construct references, for example). Especially\n        // in the case of scheduled events, we will just trigger both rules in parallel in both environments.\n        //\n        // A better solution would be to have the source rule add a unique token to the the event,\n        // and have the mirror rule trigger on that token only (thereby properly separating triggering, which\n        // happens in the source env; and activating, which happens in the target env).\n        //\n        // Don't have time to do that right now.\n        const mirrorRuleScope = this.obtainMirrorRuleScope(targetStack, targetAccount, targetRegion);\n        new MirrorRule(mirrorRuleScope, `${Names.uniqueId(this)}-${id}`, {\n          targets: [target],\n          eventPattern: this.eventPattern,\n          schedule: this.scheduleExpression ? Schedule.expression(this.scheduleExpression) : undefined,\n          description: this.description,\n        }, this);\n\n        return;\n      }\n    }\n\n    // Here only if the target does not have a targetResource defined.\n    // In such case we don't have to generate any extra component.\n    // Note that this can also be an imported resource (i.e: EventBus target)\n\n    this.targets.push({\n      id,\n      arn: targetProps.arn,\n      roleArn,\n      ecsParameters: targetProps.ecsParameters,\n      httpParameters: targetProps.httpParameters,\n      kinesisParameters: targetProps.kinesisParameters,\n      runCommandParameters: targetProps.runCommandParameters,\n      batchParameters: targetProps.batchParameters,\n      deadLetterConfig: targetProps.deadLetterConfig,\n      retryPolicy: targetProps.retryPolicy,\n      sqsParameters: targetProps.sqsParameters,\n      input: inputProps && inputProps.input,\n      inputPath: inputProps && inputProps.inputPath,\n      inputTransformer: inputProps?.inputTemplate !== undefined ? {\n        inputTemplate: inputProps.inputTemplate,\n        inputPathsMap: inputProps.inputPathsMap,\n      } : undefined,\n    });\n  }\n\n  /**\n   * Adds an event pattern filter to this rule. If a pattern was already specified,\n   * these values are merged into the existing pattern.\n   *\n   * For example, if the rule already contains the pattern:\n   *\n   *    {\n   *      \"resources\": [ \"r1\" ],\n   *      \"detail\": {\n   *        \"hello\": [ 1 ]\n   *      }\n   *    }\n   *\n   * And `addEventPattern` is called with the pattern:\n   *\n   *    {\n   *      \"resources\": [ \"r2\" ],\n   *      \"detail\": {\n   *        \"foo\": [ \"bar\" ]\n   *      }\n   *    }\n   *\n   * The resulting event pattern will be:\n   *\n   *    {\n   *      \"resources\": [ \"r1\", \"r2\" ],\n   *      \"detail\": {\n   *        \"hello\": [ 1 ],\n   *        \"foo\": [ \"bar\" ]\n   *      }\n   *    }\n   *\n   */\n  public addEventPattern(eventPattern?: EventPattern) {\n    if (!eventPattern) {\n      return;\n    }\n    mergeEventPattern(this.eventPattern, eventPattern);\n  }\n\n  /**\n   * Not private only to be overrideen in CopyRule.\n   *\n   * @internal\n   */\n  public _renderEventPattern(): any {\n    return renderEventPattern(this.eventPattern);\n  }\n\n  protected validateRule() {\n    if (Object.keys(this.eventPattern).length === 0 && !this.scheduleExpression) {\n      return ['Either \\'eventPattern\\' or \\'schedule\\' must be defined'];\n    }\n\n    return [];\n  }\n\n  private renderTargets() {\n    if (this.targets.length === 0) {\n      return undefined;\n    }\n\n    return this.targets;\n  }\n\n  /**\n   * Make sure we add the target environments event bus as a target, and the target has permissions set up to receive our events\n   *\n   * For cross-account rules, uses a support stack to set up a policy on the target event bus.\n   */\n  private ensureXEnvTargetEventBus(targetStack: Stack, targetAccount: string, targetRegion: string, id: string) {\n    // the _actual_ target is just the event bus of the target's account\n    // make sure we only add it once per account per region\n    const key = `${targetAccount}:${targetRegion}`;\n    if (this._xEnvTargetsAdded.has(key)) { return; }\n    this._xEnvTargetsAdded.add(key);\n\n    const eventBusArn = targetStack.formatArn({\n      service: 'events',\n      resource: 'event-bus',\n      resourceName: 'default',\n      region: targetRegion,\n      account: targetAccount,\n    });\n\n    // For some reason, cross-region requires a Role (with `PutEvents` on the\n    // target event bus) while cross-account doesn't\n    const roleArn = !sameEnvDimension(targetRegion, Stack.of(this).region)\n      ? this.crossRegionPutEventsRole(eventBusArn).roleArn\n      : undefined;\n\n    this.targets.push({\n      id,\n      arn: eventBusArn,\n      roleArn,\n    });\n\n    // Add a policy to the target Event Bus to allow the source account/region to publish into it.\n    //\n    // Since this Event Bus permission needs to be deployed before the stack containing the Rule is deployed\n    // (as EventBridge verifies whether you have permissions to the targets on rule creation), this needs\n    // to be in a support stack.\n\n    const sourceApp = this.node.root as App;\n    const sourceAccount = Stack.of(this).account;\n\n    // If different accounts, we need to add the permissions to the target eventbus\n    //\n    // For different region, no need for a policy on the target event bus (but a need\n    // for a role).\n    if (!sameEnvDimension(sourceAccount, targetAccount)) {\n      const stackId = `EventBusPolicy-${sourceAccount}-${targetRegion}-${targetAccount}`;\n      let eventBusPolicyStack: Stack = sourceApp.node.tryFindChild(stackId) as Stack;\n      if (!eventBusPolicyStack) {\n        eventBusPolicyStack = new Stack(sourceApp, stackId, {\n          env: {\n            account: targetAccount,\n            region: targetRegion,\n          },\n          // The region in the stack name is rather redundant (it will always be the target region)\n          // Leaving it in for backwards compatibility.\n          stackName: `${targetStack.stackName}-EventBusPolicy-support-${targetRegion}-${sourceAccount}`,\n        });\n        new CfnEventBusPolicy(eventBusPolicyStack, 'GivePermToOtherAccount', {\n          action: 'events:PutEvents',\n          statementId: `Allow-account-${sourceAccount}-${this.node.addr}`,\n          principal: sourceAccount,\n        });\n      }\n      // deploy the event bus permissions before the source stack\n      Stack.of(this).addDependency(eventBusPolicyStack);\n    }\n  }\n\n  /**\n   * Return the scope where the mirror rule should be created for x-env event targets\n   *\n   * This is the target resource's containing stack if it shares the same region (owned\n   * resources), or should be a fresh support stack for imported resources.\n   *\n   * We don't implement the second yet, as I have to think long and hard on whether we\n   * can reuse the existing support stack or not, and I don't have time for that right now.\n   */\n  private obtainMirrorRuleScope(targetStack: Stack, targetAccount: string, targetRegion: string): Construct {\n    // for cross-account or cross-region events, we cannot create new components for an imported resource\n    // because we don't have the target stack\n    if (sameEnvDimension(targetStack.account, targetAccount) && sameEnvDimension(targetStack.region, targetRegion)) {\n      return targetStack;\n    }\n\n    // For now, we don't do the work for the support stack yet\n    throw new Error('Cannot create a cross-account or cross-region rule for an imported resource (create a stack with the right environment for the imported resource)');\n  }\n\n  /**\n   * Obtain the Role for the EventBridge event\n   *\n   * If a role already exists, it will be returned. This ensures that if multiple\n   * events have the same target, they will share a role.\n   * @internal\n   */\n  private crossRegionPutEventsRole(eventBusArn: string): IRole {\n    const id = 'EventsRole';\n    let role = this.node.tryFindChild(id) as IRole;\n    if (!role) {\n      role = new Role(this, id, {\n        roleName: PhysicalName.GENERATE_IF_NEEDED,\n        assumedBy: new ServicePrincipal('events.amazonaws.com'),\n      });\n    }\n\n    role.addToPrincipalPolicy(new PolicyStatement({\n      actions: ['events:PutEvents'],\n      resources: [eventBusArn],\n    }));\n\n    return role;\n  }\n}\n\n/**\n * A rule that mirrors another rule\n */\nclass MirrorRule extends Rule {\n  constructor(scope: Construct, id: string, props: RuleProps, private readonly source: Rule) {\n    super(scope, id, props);\n  }\n\n  public _renderEventPattern(): any {\n    return this.source._renderEventPattern();\n  }\n\n  /**\n   * Override validateRule to be a no-op\n   *\n   * The rules are never stored on this object so there's nothing to validate.\n   *\n   * Instead, we mirror the other rule at render time.\n   */\n  protected validateRule(): string[] {\n    return [];\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
