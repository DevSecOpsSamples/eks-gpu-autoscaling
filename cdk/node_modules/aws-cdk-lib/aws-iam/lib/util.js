"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.UniqueStringSet=exports.mergePrincipal=exports.AttachedPolicies=exports.generatePolicyName=exports.undefinedIfEmpty=exports.LITERAL_STRING_KEY=void 0;const core_1=require("../../core"),MAX_POLICY_NAME_LEN=128;exports.LITERAL_STRING_KEY="LiteralString";function undefinedIfEmpty(f){return core_1.Lazy.list({produce:()=>{const array=f();return array&&array.length>0?array:void 0}})}exports.undefinedIfEmpty=undefinedIfEmpty;function generatePolicyName(scope,logicalId){const resolvedLogicalId=core_1.Tokenization.resolve(logicalId,{scope,resolver:new core_1.DefaultTokenResolver(new core_1.StringConcat)});return lastNCharacters(resolvedLogicalId,MAX_POLICY_NAME_LEN)}exports.generatePolicyName=generatePolicyName;function lastNCharacters(str,n){const startIndex=Math.max(str.length-n,0);return str.substring(startIndex,str.length)}class AttachedPolicies{constructor(){this.policies=new Array}attach(policy){if(!this.policies.find(p=>p===policy)){if(this.policies.find(p=>p.policyName===policy.policyName))throw new Error(`A policy named "${policy.policyName}" is already attached`);this.policies.push(policy)}}}exports.AttachedPolicies=AttachedPolicies;function mergePrincipal(target,source){var _a;if(exports.LITERAL_STRING_KEY in source&&!isEmptyObject(target)||exports.LITERAL_STRING_KEY in target&&!isEmptyObject(source))throw new Error(`Cannot merge principals ${JSON.stringify(target)} and ${JSON.stringify(source)}; if one uses a literal principal string the other one must be empty`);for(const key of Object.keys(source)){target[key]=(_a=target[key])!==null&&_a!==void 0?_a:[];let value=source[key];Array.isArray(value)||(value=[value]),target[key].push(...value)}return target}exports.mergePrincipal=mergePrincipal;class UniqueStringSet{constructor(fn){this.fn=fn,this.creationStack=core_1.captureStackTrace()}static from(fn){return core_1.Token.asList(new UniqueStringSet(fn))}resolve(context){return context.registerPostProcessor(this),this.fn()}postProcess(input,_context){if(!Array.isArray(input))return input;if(input.length===0)return;const uniq={};for(const el of input)uniq[JSON.stringify(el)]=el;return Object.values(uniq)}toString(){return core_1.Token.asString(this)}}exports.UniqueStringSet=UniqueStringSet;function isEmptyObject(x){return Object.keys(x).length===0}
//# sourceMappingURL=util.js.map
