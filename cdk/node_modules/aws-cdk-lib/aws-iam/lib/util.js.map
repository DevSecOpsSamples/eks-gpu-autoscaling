{
  "version": 3,
  "sources": ["util.ts"],
  "sourcesContent": ["import { captureStackTrace, DefaultTokenResolver, IPostProcessor, IResolvable, IResolveContext, Lazy, StringConcat, Token, Tokenization } from '../../core';\nimport { IConstruct } from 'constructs';\nimport { IPolicy } from './policy';\n\nconst MAX_POLICY_NAME_LEN = 128;\n\nexport const LITERAL_STRING_KEY = 'LiteralString';\n\nexport function undefinedIfEmpty(f: () => string[]): string[] {\n  return Lazy.list({\n    produce: () => {\n      const array = f();\n      return (array && array.length > 0) ? array : undefined;\n    },\n  });\n}\n\n/**\n * Used to generate a unique policy name based on the policy resource construct.\n * The logical ID of the resource is a great candidate as long as it doesn't exceed\n * 128 characters, so we take the last 128 characters (in order to make sure the hash\n * is there).\n */\nexport function generatePolicyName(scope: IConstruct, logicalId: string): string {\n  // as logicalId is itself a Token, resolve it first\n  const resolvedLogicalId = Tokenization.resolve(logicalId, {\n    scope,\n    resolver: new DefaultTokenResolver(new StringConcat()),\n  });\n  return lastNCharacters(resolvedLogicalId, MAX_POLICY_NAME_LEN);\n}\n\n/**\n * Returns a string composed of the last n characters of str.\n * If str is shorter than n, returns str.\n *\n * @param str the string to return the last n characters of\n * @param n how many characters to return\n */\nfunction lastNCharacters(str: string, n: number) {\n  const startIndex = Math.max(str.length - n, 0);\n  return str.substring(startIndex, str.length);\n}\n\n/**\n * Helper class that maintains the set of attached policies for a principal.\n */\nexport class AttachedPolicies {\n  private policies = new Array<IPolicy>();\n\n  /**\n   * Adds a policy to the list of attached policies.\n   *\n   * If this policy is already, attached, returns false.\n   * If there is another policy attached with the same name, throws an exception.\n   */\n  public attach(policy: IPolicy) {\n    if (this.policies.find(p => p === policy)) {\n      return; // already attached\n    }\n\n    if (this.policies.find(p => p.policyName === policy.policyName)) {\n      throw new Error(`A policy named \"${policy.policyName}\" is already attached`);\n    }\n\n    this.policies.push(policy);\n  }\n}\n\n/**\n * Merge two dictionaries that represent IAM principals\n *\n * Does an in-place merge.\n */\nexport function mergePrincipal(target: { [key: string]: string[] }, source: { [key: string]: string[] }) {\n  // If one represents a literal string, the other one must be empty\n  if ((LITERAL_STRING_KEY in source && !isEmptyObject(target)) ||\n    (LITERAL_STRING_KEY in target && !isEmptyObject(source))) {\n    throw new Error(`Cannot merge principals ${JSON.stringify(target)} and ${JSON.stringify(source)}; if one uses a literal principal string the other one must be empty`);\n  }\n\n  for (const key of Object.keys(source)) {\n    target[key] = target[key] ?? [];\n\n    let value = source[key];\n    if (!Array.isArray(value)) {\n      value = [value];\n    }\n\n    target[key].push(...value);\n  }\n\n  return target;\n}\n\n/**\n * Lazy string set token that dedupes entries\n *\n * Needs to operate post-resolve, because the inputs could be\n * `[ '${Token[TOKEN.9]}', '${Token[TOKEN.10]}', '${Token[TOKEN.20]}' ]`, which\n * still all resolve to the same string value.\n *\n * Needs to JSON.stringify() results because strings could resolve to literal\n * strings but could also resolve to `{ Fn::Join: [...] }`.\n */\nexport class UniqueStringSet implements IResolvable, IPostProcessor {\n  public static from(fn: () => string[]) {\n    return Token.asList(new UniqueStringSet(fn));\n  }\n\n  public readonly creationStack: string[];\n\n  private constructor(private readonly fn: () => string[]) {\n    this.creationStack = captureStackTrace();\n  }\n\n  public resolve(context: IResolveContext) {\n    context.registerPostProcessor(this);\n    return this.fn();\n  }\n\n  public postProcess(input: any, _context: IResolveContext) {\n    if (!Array.isArray(input)) { return input; }\n    if (input.length === 0) { return undefined; }\n\n    const uniq: Record<string, any> = {};\n    for (const el of input) {\n      uniq[JSON.stringify(el)] = el;\n    }\n    return Object.values(uniq);\n  }\n\n  public toString(): string {\n    return Token.asString(this);\n  }\n}\n\nfunction isEmptyObject(x: { [key: string]: any }): boolean {\n  return Object.keys(x).length === 0;\n}\n"],
  "mappings": "kOAAA,KAAA,QAAA,QAAA,YAAA,EAIM,oBAAsB,IAEf,QAAA,mBAAqB,gBAElC,0BAAiC,EAAiB,CAChD,MAAO,QAAA,KAAK,KAAK,CACf,QAAS,IAAK,CACZ,KAAM,OAAQ,EAAC,EACf,MAAQ,QAAS,MAAM,OAAS,EAAK,MAAQ,MAC/C,EACD,CACH,CAPA,QAAA,iBAAA,iBAeA,4BAAmC,MAAmB,UAAiB,CAErE,KAAM,mBAAoB,OAAA,aAAa,QAAQ,UAAW,CACxD,MACA,SAAU,GAAI,QAAA,qBAAqB,GAAI,QAAA,YAAc,EACtD,EACD,MAAO,iBAAgB,kBAAmB,mBAAmB,CAC/D,CAPA,QAAA,mBAAA,mBAgBA,yBAAyB,IAAa,EAAS,CAC7C,KAAM,YAAa,KAAK,IAAI,IAAI,OAAS,EAAG,CAAC,EAC7C,MAAO,KAAI,UAAU,WAAY,IAAI,MAAM,CAC7C,CAKA,MAAa,gBAAgB,CAA7B,aAAA,CACU,KAAA,SAAW,GAAI,MAmBzB,CAXS,OAAO,OAAe,CAC3B,GAAI,MAAK,SAAS,KAAK,GAAK,IAAM,MAAM,EAIxC,IAAI,KAAK,SAAS,KAAK,GAAK,EAAE,aAAe,OAAO,UAAU,EAC5D,KAAM,IAAI,OAAM,mBAAmB,OAAO,iCAAiC,EAG7E,KAAK,SAAS,KAAK,MAAM,IAlB7B,QAAA,iBAAA,iBA2BA,wBAA+B,OAAqC,OAAmC,QAErG,GAAK,QAAA,qBAAsB,SAAU,CAAC,cAAc,MAAM,GACvD,QAAA,qBAAsB,SAAU,CAAC,cAAc,MAAM,EACtD,KAAM,IAAI,OAAM,2BAA2B,KAAK,UAAU,MAAM,SAAS,KAAK,UAAU,MAAM,uEAAuE,EAGvK,SAAW,OAAO,QAAO,KAAK,MAAM,EAAG,CACrC,OAAO,KAAI,IAAG,OAAO,QAAI,MAAA,KAAA,OAAA,GAAI,CAAA,EAE7B,GAAI,OAAQ,OAAO,KACnB,AAAK,MAAM,QAAQ,KAAK,GACtB,OAAQ,CAAC,KAAK,GAGhB,OAAO,KAAK,KAAK,GAAG,KAAK,EAG3B,MAAO,OACT,CAnBA,QAAA,eAAA,eA+BA,MAAa,eAAe,CAO1B,YAAqC,GAAkB,CAAlB,KAAA,GAAA,GACnC,KAAK,cAAgB,OAAA,kBAAiB,QAP1B,MAAK,GAAkB,CACnC,MAAO,QAAA,MAAM,OAAO,GAAI,iBAAgB,EAAE,CAAC,EAStC,QAAQ,QAAwB,CACrC,eAAQ,sBAAsB,IAAI,EAC3B,KAAK,GAAE,EAGT,YAAY,MAAY,SAAyB,CACtD,GAAI,CAAC,MAAM,QAAQ,KAAK,EAAK,MAAO,OACpC,GAAI,MAAM,SAAW,EAAK,OAE1B,KAAM,MAA4B,CAAA,EAClC,SAAW,MAAM,OACf,KAAK,KAAK,UAAU,EAAE,GAAK,GAE7B,MAAO,QAAO,OAAO,IAAI,EAGpB,UAAQ,CACb,MAAO,QAAA,MAAM,SAAS,IAAI,GA5B9B,QAAA,gBAAA,gBAgCA,uBAAuB,EAAyB,CAC9C,MAAO,QAAO,KAAK,CAAC,EAAE,SAAW,CACnC",
  "names": []
}
