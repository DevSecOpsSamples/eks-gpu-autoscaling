{
  "version": 3,
  "sources": ["user.ts"],
  "sourcesContent": ["import { Arn, Aws, Lazy, Resource, SecretValue, Stack } from '../../core';\nimport { Construct } from 'constructs';\nimport { IGroup } from './group';\nimport { CfnUser, CfnUserToGroupAddition } from './iam.generated';\nimport { IIdentity } from './identity-base';\nimport { IManagedPolicy } from './managed-policy';\nimport { Policy } from './policy';\nimport { PolicyStatement } from './policy-statement';\nimport { AddToPrincipalPolicyResult, ArnPrincipal, IPrincipal, PrincipalPolicyFragment } from './principals';\nimport { AttachedPolicies, undefinedIfEmpty } from './util';\n\n/**\n * Represents an IAM user\n *\n * @see https://docs.aws.amazon.com/IAM/latest/UserGuide/id_users.html\n */\nexport interface IUser extends IIdentity {\n  /**\n   * The user's name\n   * @attribute\n   */\n  readonly userName: string;\n\n  /**\n   * The user's ARN\n   * @attribute\n   */\n  readonly userArn: string;\n\n  /**\n   * Adds this user to a group.\n   */\n  addToGroup(group: IGroup): void;\n}\n\n/**\n * Properties for defining an IAM user\n */\nexport interface UserProps {\n  /**\n   * Groups to add this user to. You can also use `addToGroup` to add this\n   * user to a group.\n   *\n   * @default - No groups.\n   */\n  readonly groups?: IGroup[];\n\n  /**\n   * A list of managed policies associated with this role.\n   *\n   * You can add managed policies later using\n   * `addManagedPolicy(ManagedPolicy.fromAwsManagedPolicyName(policyName))`.\n   *\n   * @default - No managed policies.\n   */\n  readonly managedPolicies?: IManagedPolicy[];\n\n  /**\n   * The path for the user name. For more information about paths, see IAM\n   * Identifiers in the IAM User Guide.\n   *\n   * @default /\n   */\n  readonly path?: string;\n\n  /**\n   * AWS supports permissions boundaries for IAM entities (users or roles).\n   * A permissions boundary is an advanced feature for using a managed policy\n   * to set the maximum permissions that an identity-based policy can grant to\n   * an IAM entity. An entity's permissions boundary allows it to perform only\n   * the actions that are allowed by both its identity-based policies and its\n   * permissions boundaries.\n   *\n   * @link https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-role.html#cfn-iam-role-permissionsboundary\n   * @link https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_boundaries.html\n   *\n   * @default - No permissions boundary.\n   */\n  readonly permissionsBoundary?: IManagedPolicy;\n\n  /**\n   * A name for the IAM user. For valid values, see the UserName parameter for\n   * the CreateUser action in the IAM API Reference. If you don't specify a\n   * name, AWS CloudFormation generates a unique physical ID and uses that ID\n   * for the user name.\n   *\n   * If you specify a name, you cannot perform updates that require\n   * replacement of this resource. You can perform updates that require no or\n   * some interruption. If you must replace the resource, specify a new name.\n   *\n   * If you specify a name, you must specify the CAPABILITY_NAMED_IAM value to\n   * acknowledge your template's capabilities. For more information, see\n   * Acknowledging IAM Resources in AWS CloudFormation Templates.\n   *\n   * @default - Generated by CloudFormation (recommended)\n   */\n  readonly userName?: string;\n\n  /**\n   * The password for the user. This is required so the user can access the\n   * AWS Management Console.\n   *\n   * You can use `SecretValue.plainText` to specify a password in plain text or\n   * use `secretsmanager.Secret.fromSecretAttributes` to reference a secret in\n   * Secrets Manager.\n   *\n   * @default - User won't be able to access the management console without a password.\n   */\n  readonly password?: SecretValue;\n\n  /**\n   * Specifies whether the user is required to set a new password the next\n   * time the user logs in to the AWS Management Console.\n   *\n   * If this is set to 'true', you must also specify \"initialPassword\".\n   *\n   * @default false\n   */\n  readonly passwordResetRequired?: boolean;\n}\n\n/**\n * Represents a user defined outside of this stack.\n */\nexport interface UserAttributes {\n  /**\n   * The ARN of the user.\n   *\n   * Format: arn:<partition>:iam::<account-id>:user/<user-name-with-path>\n   */\n  readonly userArn: string;\n}\n\n/**\n * Define a new IAM user\n */\nexport class User extends Resource implements IIdentity, IUser {\n  /**\n   * Import an existing user given a username.\n   *\n   * @param scope construct scope\n   * @param id construct id\n   * @param userName the username of the existing user to import\n   */\n  public static fromUserName(scope: Construct, id: string, userName: string): IUser {\n    const userArn = Stack.of(scope).formatArn({\n      service: 'iam',\n      region: '',\n      resource: 'user',\n      resourceName: userName,\n    });\n\n    return User.fromUserAttributes(scope, id, { userArn });\n  }\n\n  /**\n   * Import an existing user given a user ARN.\n   *\n   * If the ARN comes from a Token, the User cannot have a path; if so, any attempt\n   * to reference its username will fail.\n   *\n   * @param scope construct scope\n   * @param id construct id\n   * @param userArn the ARN of an existing user to import\n   */\n  public static fromUserArn(scope: Construct, id: string, userArn: string): IUser {\n    return User.fromUserAttributes(scope, id, { userArn });\n  }\n\n  /**\n   * Import an existing user given user attributes.\n   *\n   * If the ARN comes from a Token, the User cannot have a path; if so, any attempt\n   * to reference its username will fail.\n   *\n   * @param scope construct scope\n   * @param id construct id\n   * @param attrs the attributes of the user to import\n   */\n  public static fromUserAttributes(scope: Construct, id: string, attrs: UserAttributes): IUser {\n    class Import extends Resource implements IUser {\n      public readonly grantPrincipal: IPrincipal = this;\n      public readonly principalAccount = Aws.ACCOUNT_ID;\n      // Resource name with path can have multiple elements separated by slash.\n      // Therefore, use element after last slash as userName. Happens to work for Tokens since\n      // they don't have a '/' in them.\n      public readonly userName: string = Arn.extractResourceName(attrs.userArn, 'user').split('/').pop()!;\n      public readonly userArn: string = attrs.userArn;\n      public readonly assumeRoleAction: string = 'sts:AssumeRole';\n      public readonly policyFragment: PrincipalPolicyFragment = new ArnPrincipal(attrs.userArn).policyFragment;\n      private readonly attachedPolicies = new AttachedPolicies();\n      private defaultPolicy?: Policy;\n      private groupId = 0;\n\n      public addToPolicy(statement: PolicyStatement): boolean {\n        return this.addToPrincipalPolicy(statement).statementAdded;\n      }\n\n      public addToPrincipalPolicy(statement: PolicyStatement): AddToPrincipalPolicyResult {\n        if (!this.defaultPolicy) {\n          this.defaultPolicy = new Policy(this, 'Policy');\n          this.defaultPolicy.attachToUser(this);\n        }\n        this.defaultPolicy.addStatements(statement);\n        return { statementAdded: true, policyDependable: this.defaultPolicy };\n      }\n\n      public addToGroup(group: IGroup): void {\n        new CfnUserToGroupAddition(Stack.of(group), `${this.userName}Group${this.groupId}`, {\n          groupName: group.groupName,\n          users: [this.userName],\n        });\n        this.groupId += 1;\n      }\n\n      public attachInlinePolicy(policy: Policy): void {\n        this.attachedPolicies.attach(policy);\n        policy.attachToUser(this);\n      }\n\n      public addManagedPolicy(_policy: IManagedPolicy): void {\n        throw new Error('Cannot add managed policy to imported User');\n      }\n    }\n\n    return new Import(scope, id);\n  }\n\n  public readonly grantPrincipal: IPrincipal = this;\n  public readonly principalAccount: string | undefined = this.env.account;\n  public readonly assumeRoleAction: string = 'sts:AssumeRole';\n\n  /**\n   * An attribute that represents the user name.\n   * @attribute\n   */\n  public readonly userName: string;\n\n  /**\n   * An attribute that represents the user's ARN.\n   * @attribute\n   */\n  public readonly userArn: string;\n\n  /**\n   * Returns the permissions boundary attached  to this user\n   */\n  public readonly permissionsBoundary?: IManagedPolicy;\n\n  public readonly policyFragment: PrincipalPolicyFragment;\n\n  private readonly groups = new Array<any>();\n  private readonly managedPolicies = new Array<IManagedPolicy>();\n  private readonly attachedPolicies = new AttachedPolicies();\n  private defaultPolicy?: Policy;\n\n  constructor(scope: Construct, id: string, props: UserProps = {}) {\n    super(scope, id, {\n      physicalName: props.userName,\n    });\n\n    this.managedPolicies.push(...props.managedPolicies || []);\n    this.permissionsBoundary = props.permissionsBoundary;\n\n    const user = new CfnUser(this, 'Resource', {\n      userName: this.physicalName,\n      groups: undefinedIfEmpty(() => this.groups),\n      managedPolicyArns: Lazy.list({ produce: () => this.managedPolicies.map(p => p.managedPolicyArn) }, { omitEmpty: true }),\n      path: props.path,\n      permissionsBoundary: this.permissionsBoundary ? this.permissionsBoundary.managedPolicyArn : undefined,\n      loginProfile: this.parseLoginProfile(props),\n    });\n\n    this.userName = this.getResourceNameAttribute(user.ref);\n    this.userArn = this.getResourceArnAttribute(user.attrArn, {\n      region: '', // IAM is global in each partition\n      service: 'iam',\n      resource: 'user',\n      resourceName: this.physicalName,\n    });\n\n    this.policyFragment = new ArnPrincipal(this.userArn).policyFragment;\n\n    if (props.groups) {\n      props.groups.forEach(g => this.addToGroup(g));\n    }\n  }\n\n  /**\n   * Adds this user to a group.\n   */\n  public addToGroup(group: IGroup) {\n    this.groups.push(group.groupName);\n  }\n\n  /**\n   * Attaches a managed policy to the user.\n   * @param policy The managed policy to attach.\n   */\n  public addManagedPolicy(policy: IManagedPolicy) {\n    if (this.managedPolicies.find(mp => mp === policy)) { return; }\n    this.managedPolicies.push(policy);\n  }\n\n  /**\n   * Attaches a policy to this user.\n   */\n  public attachInlinePolicy(policy: Policy) {\n    this.attachedPolicies.attach(policy);\n    policy.attachToUser(this);\n  }\n\n  /**\n   * Adds an IAM statement to the default policy.\n   *\n   * @returns true\n   */\n  public addToPrincipalPolicy(statement: PolicyStatement): AddToPrincipalPolicyResult {\n    if (!this.defaultPolicy) {\n      this.defaultPolicy = new Policy(this, 'DefaultPolicy');\n      this.defaultPolicy.attachToUser(this);\n    }\n\n    this.defaultPolicy.addStatements(statement);\n    return { statementAdded: true, policyDependable: this.defaultPolicy };\n  }\n\n  public addToPolicy(statement: PolicyStatement): boolean {\n    return this.addToPrincipalPolicy(statement).statementAdded;\n  }\n\n  private parseLoginProfile(props: UserProps): CfnUser.LoginProfileProperty | undefined {\n    if (props.password) {\n      return {\n        password: props.password.toString(),\n        passwordResetRequired: props.passwordResetRequired,\n      };\n    }\n\n    if (props.passwordResetRequired) {\n      throw new Error('Cannot set \"passwordResetRequired\" without specifying \"initialPassword\"');\n    }\n\n    return undefined; // no console access\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
