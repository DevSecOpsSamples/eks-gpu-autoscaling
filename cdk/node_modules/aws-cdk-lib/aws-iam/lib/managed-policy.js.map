{
  "version": 3,
  "sources": ["managed-policy.ts"],
  "sourcesContent": ["import { ArnFormat, Resource, Stack, Arn, Aws } from '../../core';\nimport { Construct } from 'constructs';\nimport { IGroup } from './group';\nimport { CfnManagedPolicy } from './iam.generated';\nimport { PolicyDocument } from './policy-document';\nimport { PolicyStatement } from './policy-statement';\nimport { IRole } from './role';\nimport { IUser } from './user';\nimport { undefinedIfEmpty } from './util';\n\n/**\n * A managed policy\n */\nexport interface IManagedPolicy {\n  /**\n   * The ARN of the managed policy\n   * @attribute\n   */\n  readonly managedPolicyArn: string;\n}\n\n/**\n * Properties for defining an IAM managed policy\n */\nexport interface ManagedPolicyProps {\n  /**\n   * The name of the managed policy. If you specify multiple policies for an entity,\n   * specify unique names. For example, if you specify a list of policies for\n   * an IAM role, each policy must have a unique name.\n   *\n   * @default - A name is automatically generated.\n   */\n  readonly managedPolicyName?: string;\n\n  /**\n   * A description of the managed policy. Typically used to store information about the\n   * permissions defined in the policy. For example, \"Grants access to production DynamoDB tables.\"\n   * The policy description is immutable. After a value is assigned, it cannot be changed.\n   *\n   * @default - empty\n   */\n  readonly description?: string;\n\n  /**\n   * The path for the policy. This parameter allows (through its regex pattern) a string of characters\n   * consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes.\n   * In addition, it can contain any ASCII character from the ! (\\u0021) through the DEL character (\\u007F),\n   * including most punctuation characters, digits, and upper and lowercased letters.\n   *\n   * For more information about paths, see IAM Identifiers in the IAM User Guide.\n   *\n   * @default - \"/\"\n   */\n  readonly path?: string;\n\n  /**\n   * Users to attach this policy to.\n   * You can also use `attachToUser(user)` to attach this policy to a user.\n   *\n   * @default - No users.\n   */\n  readonly users?: IUser[];\n\n  /**\n   * Roles to attach this policy to.\n   * You can also use `attachToRole(role)` to attach this policy to a role.\n   *\n   * @default - No roles.\n   */\n  readonly roles?: IRole[];\n\n  /**\n   * Groups to attach this policy to.\n   * You can also use `attachToGroup(group)` to attach this policy to a group.\n   *\n   * @default - No groups.\n   */\n  readonly groups?: IGroup[];\n\n  /**\n   * Initial set of permissions to add to this policy document.\n   * You can also use `addPermission(statement)` to add permissions later.\n   *\n   * @default - No statements.\n   */\n  readonly statements?: PolicyStatement[];\n\n  /**\n   * Initial PolicyDocument to use for this ManagedPolicy. If omited, any\n   * `PolicyStatement` provided in the `statements` property will be applied\n   * against the empty default `PolicyDocument`.\n   *\n   * @default - An empty policy.\n   */\n  readonly document?: PolicyDocument;\n}\n\n/**\n * Managed policy\n *\n */\nexport class ManagedPolicy extends Resource implements IManagedPolicy {\n  /**\n   * Import a customer managed policy from the managedPolicyName.\n   *\n   * For this managed policy, you only need to know the name to be able to use it.\n   *\n   */\n  public static fromManagedPolicyName(scope: Construct, id: string, managedPolicyName: string): IManagedPolicy {\n    class Import extends Resource implements IManagedPolicy {\n      public readonly managedPolicyArn = Stack.of(scope).formatArn({\n        service: 'iam',\n        region: '', // no region for managed policy\n        account: Stack.of(scope).account, // Can this be something the user specifies?\n        resource: 'policy',\n        resourceName: managedPolicyName,\n      });\n    }\n    return new Import(scope, id);\n  }\n\n  /**\n   * Import an external managed policy by ARN.\n   *\n   * For this managed policy, you only need to know the ARN to be able to use it.\n   * This can be useful if you got the ARN from a CloudFormation Export.\n   *\n   * If the imported Managed Policy ARN is a Token (such as a\n   * `CfnParameter.valueAsString` or a `Fn.importValue()`) *and* the referenced\n   * managed policy has a `path` (like `arn:...:policy/AdminPolicy/AdminAllow`), the\n   * `managedPolicyName` property will not resolve to the correct value. Instead it\n   * will resolve to the first path component. We unfortunately cannot express\n   * the correct calculation of the full path name as a CloudFormation\n   * expression. In this scenario the Managed Policy ARN should be supplied without the\n   * `path` in order to resolve the correct managed policy resource.\n   *\n   * @param scope construct scope\n   * @param id construct id\n   * @param managedPolicyArn the ARN of the managed policy to import\n   */\n  public static fromManagedPolicyArn(scope: Construct, id: string, managedPolicyArn: string): IManagedPolicy {\n    class Import extends Resource implements IManagedPolicy {\n      public readonly managedPolicyArn = managedPolicyArn;\n    }\n    return new Import(scope, id);\n  }\n\n  /**\n   * Import a managed policy from one of the policies that AWS manages.\n   *\n   * For this managed policy, you only need to know the name to be able to use it.\n   *\n   * Some managed policy names start with \"service-role/\", some start with\n   * \"job-function/\", and some don't start with anything. Include the\n   * prefix when constructing this object.\n   */\n  public static fromAwsManagedPolicyName(managedPolicyName: string): IManagedPolicy {\n    class AwsManagedPolicy implements IManagedPolicy {\n      public readonly managedPolicyArn = Arn.format({\n        partition: Aws.PARTITION,\n        service: 'iam',\n        region: '', // no region for managed policy\n        account: 'aws', // the account for a managed policy is 'aws'\n        resource: 'policy',\n        resourceName: managedPolicyName,\n      });\n    }\n    return new AwsManagedPolicy();\n  }\n\n  /**\n   * Returns the ARN of this managed policy.\n   *\n   * @attribute\n   */\n  public readonly managedPolicyArn: string;\n\n  /**\n   * The policy document.\n   */\n  public readonly document = new PolicyDocument();\n\n  /**\n   * The name of this policy.\n   *\n   * @attribute\n   */\n  public readonly managedPolicyName: string;\n\n  /**\n   * The description of this policy.\n   *\n   * @attribute\n   */\n  public readonly description: string;\n\n  /**\n   * The path of this policy.\n   *\n   * @attribute\n   */\n  public readonly path: string;\n\n  private readonly roles = new Array<IRole>();\n  private readonly users = new Array<IUser>();\n  private readonly groups = new Array<IGroup>();\n\n  constructor(scope: Construct, id: string, props: ManagedPolicyProps = {}) {\n    super(scope, id, {\n      physicalName: props.managedPolicyName,\n    });\n\n    this.description = props.description || '';\n    this.path = props.path || '/';\n\n    if (props.document) {\n      this.document = props.document;\n    }\n\n    const resource = new CfnManagedPolicy(this, 'Resource', {\n      policyDocument: this.document,\n      managedPolicyName: this.physicalName,\n      description: this.description,\n      path: this.path,\n      roles: undefinedIfEmpty(() => this.roles.map(r => r.roleName)),\n      users: undefinedIfEmpty(() => this.users.map(u => u.userName)),\n      groups: undefinedIfEmpty(() => this.groups.map(g => g.groupName)),\n    });\n\n    if (props.users) {\n      props.users.forEach(u => this.attachToUser(u));\n    }\n\n    if (props.groups) {\n      props.groups.forEach(g => this.attachToGroup(g));\n    }\n\n    if (props.roles) {\n      props.roles.forEach(r => this.attachToRole(r));\n    }\n\n    if (props.statements) {\n      props.statements.forEach(p => this.addStatements(p));\n    }\n\n    // arn:aws:iam::123456789012:policy/teststack-CreateTestDBPolicy-16M23YE3CS700\n    this.managedPolicyName = this.getResourceNameAttribute(Stack.of(this).splitArn(resource.ref, ArnFormat.SLASH_RESOURCE_NAME).resourceName!);\n    this.managedPolicyArn = this.getResourceArnAttribute(resource.ref, {\n      region: '', // IAM is global in each partition\n      service: 'iam',\n      resource: 'policy',\n      resourceName: this.physicalName,\n    });\n\n    this.node.addValidation({ validate: () => this.validateManagedPolicy() });\n  }\n\n  /**\n   * Adds a statement to the policy document.\n   */\n  public addStatements(...statement: PolicyStatement[]) {\n    this.document.addStatements(...statement);\n  }\n\n  /**\n   * Attaches this policy to a user.\n   */\n  public attachToUser(user: IUser) {\n    if (this.users.find(u => u === user)) { return; }\n    this.users.push(user);\n  }\n\n  /**\n   * Attaches this policy to a role.\n   */\n  public attachToRole(role: IRole) {\n    if (this.roles.find(r => r === role)) { return; }\n    this.roles.push(role);\n  }\n\n  /**\n   * Attaches this policy to a group.\n   */\n  public attachToGroup(group: IGroup) {\n    if (this.groups.find(g => g === group)) { return; }\n    this.groups.push(group);\n  }\n\n  private validateManagedPolicy(): string[] {\n    const result = new Array<string>();\n\n    // validate that the policy document is not empty\n    if (this.document.isEmpty) {\n      result.push('Managed Policy is empty. You must add statements to the policy');\n    }\n\n    result.push(...this.document.validateForIdentityPolicy());\n\n    return result;\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
