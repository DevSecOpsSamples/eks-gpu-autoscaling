"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.mergeStatements=void 0;const util_1=require("../util"),postprocess_policy_document_1=require("./postprocess-policy-document");function mergeStatements(statements){const compStatements=statements.map(makeComparable);for(;onePass(););return compStatements.map(renderComparable);function onePass(){let ret=!1,i=0;for(;i<compStatements.length;){let didMerge=!1;for(let j=i+1;j<compStatements.length;j++){const merged=tryMerge(compStatements[i],compStatements[j]);if(merged){compStatements[i]=merged,compStatements.splice(j,1),ret=didMerge=!0;break}}didMerge||i++}return ret}}exports.mergeStatements=mergeStatements;function tryMerge(a,b){if(!(a.effect!==b.effect||a.sid||b.sid||a.conditionString!==b.conditionString||!setEqual(a.notAction,b.notAction)||!setEqual(a.notResource,b.notResource)||!setEqual(a.notPrincipal,b.notPrincipal)||(setEqual(a.action,b.action)?1:0)+(setEqual(a.resource,b.resource)?1:0)+(setEqual(a.principal,b.principal)?1:0)<2||unmergeablePrincipals(a,b)))return{effect:a.effect,conditionString:a.conditionString,conditionValue:b.conditionValue,notAction:a.notAction,notPrincipal:a.notPrincipal,notResource:a.notResource,action:setMerge(a.action,b.action),resource:setMerge(a.resource,b.resource),principal:setMerge(a.principal,b.principal)}}function makeComparable(s){return{effect:s.Effect,sid:s.Sid,action:iamSet(s.Action),notAction:iamSet(s.NotAction),resource:iamSet(s.Resource),notResource:iamSet(s.NotResource),principal:principalIamSet(s.Principal),notPrincipal:principalIamSet(s.NotPrincipal),conditionString:JSON.stringify(s.Condition),conditionValue:s.Condition};function forceArray(x){return Array.isArray(x)?x:[x]}function iamSet(x){return x==null?{}:mkdict(forceArray(x).map(e=>[JSON.stringify(e),e]))}function principalIamSet(x){if(x===void 0)return{};if((Array.isArray(x)||typeof x=="string")&&(x={[util_1.LITERAL_STRING_KEY]:x}),typeof x=="object"&&x!==null){const individualPrincipals=Object.entries(x).flatMap(([principalType,value])=>forceArray(value).map(v=>({[principalType]:v})));return iamSet(individualPrincipals)}return{}}}function unmergeablePrincipals(a,b){const aHasLiteral=Object.values(a.principal).some(v=>util_1.LITERAL_STRING_KEY in v),bHasLiteral=Object.values(b.principal).some(v=>util_1.LITERAL_STRING_KEY in v);return aHasLiteral!==bHasLiteral}function renderComparable(s){return postprocess_policy_document_1.normalizeStatement({Effect:s.effect,Sid:s.sid,Condition:s.conditionValue,Action:renderSet(s.action),NotAction:renderSet(s.notAction),Resource:renderSet(s.resource),NotResource:renderSet(s.notResource),Principal:renderPrincipalSet(s.principal),NotPrincipal:renderPrincipalSet(s.notPrincipal)});function renderSet(x){const keys=Object.keys(x).sort();return keys.length>0?keys.map(key=>x[key]):void 0}function renderPrincipalSet(x){const keys=Object.keys(x).sort(),ret={};for(const key of keys){const principal=x[key];if(principal==null||typeof principal!="object")throw new Error(`Principal should be an object with a principal type, got: ${principal}`);const principalKeys=Object.keys(principal);if(principalKeys.length!==1)throw new Error(`Principal should be an object with 1 key, found keys: ${principalKeys}`);const pk=principalKeys[0];ret[pk]||(ret[pk]=[]),ret[pk].push(principal[pk])}return ret}}function setEqual(a,b){const keysA=Object.keys(a),keysB=Object.keys(b);return keysA.length===keysB.length&&keysA.every(k=>k in b)}function setMerge(x,y){return{...x,...y}}function mkdict(xs){const ret={};for(const x of xs)ret[x[0]]=x[1];return ret}
//# sourceMappingURL=merge-statements.js.map
