{
  "version": 3,
  "sources": ["merge-statements.ts"],
  "sourcesContent": ["// IAM Statement merging\n//\n// See docs/policy-merging.als for a formal model of the logic\n// implemented here.\n\n\nimport { LITERAL_STRING_KEY } from '../util';\nimport { StatementSchema, normalizeStatement, IamValue } from './postprocess-policy-document';\n\n/**\n * Merge as many statements as possible to shrink the total policy doc, modifying the input array in place\n *\n * We compare and merge all pairs of statements (O(N^2) complexity), opportunistically\n * merging them. This is not guaranteed to produce the optimal output, but it's probably\n * Good Enough(tm). If it merges anything, it's at least going to produce a smaller output\n * than the input.\n */\nexport function mergeStatements(statements: StatementSchema[]): StatementSchema[] {\n  const compStatements = statements.map(makeComparable);\n\n  // Keep trying until nothing changes anymore\n  while (onePass()) { /* again */ }\n  return compStatements.map(renderComparable);\n\n  // Do one optimization pass, return 'true' if we merged anything\n  function onePass() {\n    let ret = false;\n    let i = 0;\n    while (i < compStatements.length) {\n      let didMerge = false;\n\n      for (let j = i + 1; j < compStatements.length; j++) {\n        const merged = tryMerge(compStatements[i], compStatements[j]);\n        if (merged) {\n          compStatements[i] = merged;\n          compStatements.splice(j, 1);\n          ret = didMerge = true;\n          break;\n        }\n      }\n\n      if (!didMerge) {\n        i++;\n      }\n    }\n    return ret;\n  }\n}\n\n/**\n * Given two statements, return their merging (if possible)\n *\n * We can merge two statements if:\n *\n * - Their effects are the same\n * - They don't have Sids (not really a hard requirement, but just a simplification and an escape hatch)\n * - Their Conditions are the same\n * - Their NotAction, NotResource and NotPrincipal sets are the same (empty sets is fine).\n * - From their Action, Resource and Principal sets, 2 are subsets of each other\n *   (empty sets are fine).\n */\nfunction tryMerge(a: ComparableStatement, b: ComparableStatement): ComparableStatement | undefined {\n  // Effects must be the same\n  if (a.effect !== b.effect) { return; }\n  // We don't merge Sids (for now)\n  if (a.sid || b.sid) { return; }\n\n  if (a.conditionString !== b.conditionString) { return; }\n  if (!setEqual(a.notAction, b.notAction) || !setEqual(a.notResource, b.notResource) || !setEqual(a.notPrincipal, b.notPrincipal)) { return; }\n\n  // We can merge these statements if 2 out of the 3 sets of Action, Resource, Principal\n  // are the same.\n  const setsEqual = (setEqual(a.action, b.action) ? 1 : 0) +\n    (setEqual(a.resource, b.resource) ? 1 : 0) +\n    (setEqual(a.principal, b.principal) ? 1 : 0);\n\n  if (setsEqual < 2 || unmergeablePrincipals(a, b)) { return; }\n\n  return {\n    effect: a.effect,\n    conditionString: a.conditionString,\n    conditionValue: b.conditionValue,\n    notAction: a.notAction,\n    notPrincipal: a.notPrincipal,\n    notResource: a.notResource,\n\n    action: setMerge(a.action, b.action),\n    resource: setMerge(a.resource, b.resource),\n    principal: setMerge(a.principal, b.principal),\n  };\n}\n\n/**\n * Calculate and return cached string set representation of the statement elements\n *\n * This is to be able to do comparisons on these sets quickly.\n */\nfunction makeComparable(s: StatementSchema): ComparableStatement {\n  return {\n    effect: s.Effect,\n    sid: s.Sid,\n    action: iamSet(s.Action),\n    notAction: iamSet(s.NotAction),\n    resource: iamSet(s.Resource),\n    notResource: iamSet(s.NotResource),\n    principal: principalIamSet(s.Principal),\n    notPrincipal: principalIamSet(s.NotPrincipal),\n    conditionString: JSON.stringify(s.Condition),\n    conditionValue: s.Condition,\n  };\n\n  function forceArray<A>(x: A | Array<A>): Array<A> {\n    return Array.isArray(x) ? x : [x];\n  }\n\n  function iamSet(x: IamValue | undefined): IamValueSet {\n    if (x == undefined) { return {}; }\n    return mkdict(forceArray(x).map(e => [JSON.stringify(e), e]));\n  }\n\n  function principalIamSet(x: IamValue | Record<string, IamValue> | undefined): IamValueSet {\n    if (x === undefined) { return {}; }\n\n    if (Array.isArray(x) || typeof x === 'string') {\n      x = { [LITERAL_STRING_KEY]: x };\n    }\n\n    if (typeof x === 'object' && x !== null) {\n      // Turn { AWS: [a, b], Service: [c] } into [{ AWS: a }, { AWS: b }, { Service: c }]\n      const individualPrincipals = Object.entries(x).flatMap(([principalType, value]) => forceArray(value).map(v => ({ [principalType]: v })));\n      return iamSet(individualPrincipals);\n    }\n    return {};\n  }\n}\n\n/**\n * Return 'true' if the two principals are unmergeable\n *\n * This only happens if one of them is a literal, untyped principal (typically,\n * `Principal: '*'`) and the other one is typed.\n *\n * `Principal: '*'` behaves subtly different than `Principal: { AWS: '*' }` and must\n * therefore be preserved.\n */\nfunction unmergeablePrincipals(a: ComparableStatement, b: ComparableStatement) {\n  const aHasLiteral = Object.values(a.principal).some(v => LITERAL_STRING_KEY in v);\n  const bHasLiteral = Object.values(b.principal).some(v => LITERAL_STRING_KEY in v);\n  return aHasLiteral !== bHasLiteral;\n}\n\n/**\n * Turn a ComparableStatement back into a StatementSchema\n */\nfunction renderComparable(s: ComparableStatement): StatementSchema {\n  return normalizeStatement({\n    Effect: s.effect,\n    Sid: s.sid,\n    Condition: s.conditionValue,\n    Action: renderSet(s.action),\n    NotAction: renderSet(s.notAction),\n    Resource: renderSet(s.resource),\n    NotResource: renderSet(s.notResource),\n    Principal: renderPrincipalSet(s.principal),\n    NotPrincipal: renderPrincipalSet(s.notPrincipal),\n  });\n\n  function renderSet(x: IamValueSet): IamValue | undefined {\n    // Return as sorted array so that we normalize\n    const keys = Object.keys(x).sort();\n    return keys.length > 0 ? keys.map(key => x[key]) : undefined;\n  }\n\n  function renderPrincipalSet(x: IamValueSet): Record<string, IamValue> {\n    const keys = Object.keys(x).sort();\n    // The first level will be an object\n    const ret: Record<string, IamValue> = {};\n    for (const key of keys) {\n      const principal = x[key];\n      if (principal == null || typeof principal !== 'object') {\n        throw new Error(`Principal should be an object with a principal type, got: ${principal}`);\n      }\n      const principalKeys = Object.keys(principal);\n      if (principalKeys.length !== 1) {\n        throw new Error(`Principal should be an object with 1 key, found keys: ${principalKeys}`);\n      }\n      const pk = principalKeys[0];\n      if (!ret[pk]) {\n        ret[pk] = [];\n      }\n      (ret[pk] as IamValue[]).push(principal[pk]);\n    }\n    return ret;\n  }\n}\n\n/**\n * An analyzed version of a statement that makes it easier to do comparisons and merging on\n *\n * We will stringify parts of the statement: comparisons are done on the strings, the original\n * values are retained so we can stitch them back together into a real policy.\n */\ninterface ComparableStatement {\n  readonly effect?: string;\n  readonly sid?: string;\n\n  readonly principal: IamValueSet;\n  readonly notPrincipal: IamValueSet;\n  readonly action: IamValueSet;\n  readonly notAction: IamValueSet;\n  readonly resource: IamValueSet;\n  readonly notResource: IamValueSet;\n\n  readonly conditionString: string;\n  readonly conditionValue: any;\n}\n\n/**\n * A collection of comparable IAM values\n *\n * Each value is indexed by its stringified value, mapping to its original value.\n * This allows us to compare values quickly and easily (even if they are complex),\n * while also being able to deduplicate the originals.\n */\ntype IamValueSet = Record<string, any>;\n\n/**\n * Whether the given sets are equal\n */\nfunction setEqual(a: IamValueSet, b: IamValueSet) {\n  const keysA = Object.keys(a);\n  const keysB = Object.keys(b);\n  return keysA.length === keysB.length && keysA.every(k => k in b);\n}\n\n/**\n * Merge two IAM value sets\n */\nfunction setMerge(x: IamValueSet, y: IamValueSet): IamValueSet {\n  return { ...x, ...y };\n}\n\nfunction mkdict<A>(xs: Array<[string, A]>): Record<string, A> {\n  const ret: Record<string, A> = {};\n  for (const x of xs) {\n    ret[x[0]] = x[1];\n  }\n  return ret;\n}\n"],
  "mappings": "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",
  "names": []
}
