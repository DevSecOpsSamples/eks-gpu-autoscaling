{
  "version": 3,
  "sources": ["postprocess-policy-document.ts"],
  "sourcesContent": ["import * as cdk from '../../../core';\nimport { LITERAL_STRING_KEY } from '../util';\nimport { mergeStatements } from './merge-statements';\n\n/**\n * A Token postprocesser for policy documents\n *\n * Removes duplicate statements, merges statements, and assign Sids if necessary\n *\n * Because policy documents can contain all kinds of crazy things,\n * we do all the necessary work here after the document has been mostly resolved\n * into a predictable CloudFormation form.\n */\nexport class PostProcessPolicyDocument implements cdk.IPostProcessor {\n  constructor(private readonly autoAssignSids: boolean, private readonly minimize: boolean) {\n  }\n\n  public postProcess(input: any, _context: cdk.IResolveContext): any {\n    if (!input || !input.Statement) {\n      return input;\n    }\n\n    if (this.minimize) {\n      input.Statement = mergeStatements(input.Statement);\n    }\n\n    // Also remove full-on duplicates (this will not be necessary if\n    // we minimized, but it might still dedupe statements we didn't\n    // minimize like 'Deny' statements, and definitely is still necessary\n    // if we didn't minimize)\n    const jsonStatements = new Set<string>();\n    const uniqueStatements: any[] = [];\n\n    for (const statement of input.Statement) {\n      const jsonStatement = JSON.stringify(statement);\n      if (!jsonStatements.has(jsonStatement)) {\n        uniqueStatements.push(statement);\n        jsonStatements.add(jsonStatement);\n      }\n    }\n\n    // assign unique SIDs (the statement index) if `autoAssignSids` is enabled\n    const statements = uniqueStatements.map((s, i) => {\n      if (this.autoAssignSids && !s.Sid) {\n        s.Sid = i.toString();\n      }\n\n      return s;\n    });\n\n    return {\n      ...input,\n      Statement: statements,\n    };\n  }\n}\n\n// An IAM value is a string or a CloudFormation intrinsic\nexport type IamValue = string | Record<string, any> | Array<string | Record<string, any>>;\n\nexport interface StatementSchema {\n  readonly Sid?: string;\n  readonly Effect?: string;\n  readonly Principal?: Record<string, IamValue>;\n  readonly NotPrincipal?: Record<string, IamValue>;\n  readonly Resource?: IamValue;\n  readonly NotResource?: IamValue;\n  readonly Action?: IamValue;\n  readonly NotAction?: IamValue;\n  readonly Condition?: unknown;\n}\n\n\nexport function normalizeStatement(s: StatementSchema) {\n  return noUndef({\n    Action: _norm(s.Action, { unique: true }),\n    NotAction: _norm(s.NotAction, { unique: true }),\n    Condition: _norm(s.Condition),\n    Effect: _norm(s.Effect),\n    Principal: _normPrincipal(s.Principal),\n    NotPrincipal: _normPrincipal(s.NotPrincipal),\n    Resource: _norm(s.Resource, { unique: true }),\n    NotResource: _norm(s.NotResource, { unique: true }),\n    Sid: _norm(s.Sid),\n  });\n\n  function _norm(values: any, { unique = false }: { unique: boolean } = { unique: false }) {\n\n    if (values == null) {\n      return undefined;\n    }\n\n    if (cdk.Token.isUnresolved(values)) {\n      return values;\n    }\n\n    if (Array.isArray(values)) {\n      if (!values || values.length === 0) {\n        return undefined;\n      }\n\n      if (values.length === 1) {\n        return values[0];\n      }\n\n      return unique ? Array.from(new Set(values)) : values;\n    }\n\n    if (values && typeof(values) === 'object') {\n      if (Object.keys(values).length === 0) {\n        return undefined;\n      }\n    }\n\n    return values;\n  }\n\n  function _normPrincipal(principal?: { [key: string]: any }) {\n    if (!principal) { return undefined; }\n\n    const keys = Object.keys(principal);\n    if (keys.length === 0) { return undefined; }\n\n    // This is handling a special case for round-tripping a literal\n    // string principal loaded from JSON.\n    if (LITERAL_STRING_KEY in principal) {\n      return principal[LITERAL_STRING_KEY][0];\n    }\n\n    const result: any = {};\n    for (const key of keys) {\n      const normVal = _norm(principal[key]);\n      if (normVal) {\n        result[key] = normVal;\n      }\n    }\n    return result;\n  }\n}\n\nfunction noUndef(x: any): any {\n  const ret: any = {};\n  for (const [key, value] of Object.entries(x)) {\n    if (value !== undefined) {\n      ret[key] = value;\n    }\n  }\n  return ret;\n}\n"],
  "mappings": "wIAAA,KAAA,KAAA,QAAA,eAAA,EACA,OAAA,QAAA,SAAA,EACA,mBAAA,QAAA,oBAAA,EAWA,MAAa,yBAAyB,CACpC,YAA6B,eAA0C,SAAiB,CAA3D,KAAA,eAAA,eAA0C,KAAA,SAAA,SAGhE,YAAY,MAAY,SAA6B,CAC1D,GAAI,CAAC,OAAS,CAAC,MAAM,UACnB,MAAO,OAGT,AAAI,KAAK,UACP,OAAM,UAAY,mBAAA,gBAAgB,MAAM,SAAS,GAOnD,KAAM,gBAAiB,GAAI,KACrB,iBAA0B,CAAA,EAEhC,SAAW,aAAa,OAAM,UAAW,CACvC,KAAM,eAAgB,KAAK,UAAU,SAAS,EAC9C,AAAK,eAAe,IAAI,aAAa,GACnC,kBAAiB,KAAK,SAAS,EAC/B,eAAe,IAAI,aAAa,GAKpC,KAAM,YAAa,iBAAiB,IAAI,CAAC,EAAG,IACtC,MAAK,gBAAkB,CAAC,EAAE,KAC5B,GAAE,IAAM,EAAE,SAAQ,GAGb,EACR,EAED,MAAO,IACF,MACH,UAAW,aAvCjB,QAAA,0BAAA,0BA4DA,4BAAmC,EAAkB,CACnD,MAAO,SAAQ,CACb,OAAQ,MAAM,EAAE,OAAQ,CAAE,OAAQ,EAAI,CAAE,EACxC,UAAW,MAAM,EAAE,UAAW,CAAE,OAAQ,EAAI,CAAE,EAC9C,UAAW,MAAM,EAAE,SAAS,EAC5B,OAAQ,MAAM,EAAE,MAAM,EACtB,UAAW,eAAe,EAAE,SAAS,EACrC,aAAc,eAAe,EAAE,YAAY,EAC3C,SAAU,MAAM,EAAE,SAAU,CAAE,OAAQ,EAAI,CAAE,EAC5C,YAAa,MAAM,EAAE,YAAa,CAAE,OAAQ,EAAI,CAAE,EAClD,IAAK,MAAM,EAAE,GAAG,EACjB,EAED,eAAe,OAAa,CAAE,OAAS,IAA+B,CAAE,OAAQ,EAAK,EAAE,CAErF,GAAI,QAAU,KAId,IAAI,IAAI,MAAM,aAAa,MAAM,EAC/B,MAAO,QAGT,GAAI,MAAM,QAAQ,MAAM,EACtB,MAAI,CAAC,QAAU,OAAO,SAAW,EAC/B,OAGE,OAAO,SAAW,EACb,OAAO,GAGT,OAAS,MAAM,KAAK,GAAI,KAAI,MAAM,CAAC,EAAI,OAGhD,GAAI,UAAU,MAAO,SAAY,UAC3B,OAAO,KAAK,MAAM,EAAE,SAAW,GAKrC,MAAO,QACT,CAEA,wBAAwB,UAAkC,CACxD,GAAI,CAAC,UAAa,OAElB,KAAM,MAAO,OAAO,KAAK,SAAS,EAClC,GAAI,KAAK,SAAW,EAAK,OAIzB,GAAI,OAAA,qBAAsB,WACxB,MAAO,WAAU,OAAA,oBAAoB,GAGvC,KAAM,QAAc,CAAA,EACpB,SAAW,OAAO,MAAM,CACtB,KAAM,SAAU,MAAM,UAAU,IAAI,EACpC,AAAI,SACF,QAAO,KAAO,SAGlB,MAAO,OACT,CACF,CAjEA,QAAA,mBAAA,mBAmEA,iBAAiB,EAAM,CACrB,KAAM,KAAW,CAAA,EACjB,SAAW,CAAC,IAAK,QAAU,QAAO,QAAQ,CAAC,EACzC,AAAI,QAAU,QACZ,KAAI,KAAO,OAGf,MAAO,IACT",
  "names": []
}
