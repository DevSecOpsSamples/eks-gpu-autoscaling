{
  "version": 3,
  "sources": ["dns-validated-certificate.ts"],
  "sourcesContent": ["import * as path from 'path';\nimport * as iam from '../../aws-iam';\nimport * as lambda from '../../aws-lambda';\nimport * as route53 from '../../aws-route53';\nimport * as cdk from '../../core';\nimport { Construct } from 'constructs';\nimport { CertificateProps, ICertificate } from './certificate';\nimport { CertificateBase } from './certificate-base';\n\n/**\n * Properties to create a DNS validated certificate managed by AWS Certificate Manager\n *\n */\nexport interface DnsValidatedCertificateProps extends CertificateProps {\n  /**\n   * Route 53 Hosted Zone used to perform DNS validation of the request.  The zone\n   * must be authoritative for the domain name specified in the Certificate Request.\n   */\n  readonly hostedZone: route53.IHostedZone;\n  /**\n   * AWS region that will host the certificate. This is needed especially\n   * for certificates used for CloudFront distributions, which require the region\n   * to be us-east-1.\n   *\n   * @default the region the stack is deployed in.\n   */\n  readonly region?: string;\n\n  /**\n   * An endpoint of Route53 service, which is not necessary as AWS SDK could figure\n   * out the right endpoints for most regions, but for some regions such as those in\n   * aws-cn partition, the default endpoint is not working now, hence the right endpoint\n   * need to be specified through this prop.\n   *\n   * Route53 is not been officially launched in China, it is only available for AWS\n   * internal accounts now. To make DnsValidatedCertificate work for internal accounts\n   * now, a special endpoint needs to be provided.\n   *\n   * @default - The AWS SDK will determine the Route53 endpoint to use based on region\n   */\n  readonly route53Endpoint?: string;\n\n  /**\n   * Role to use for the custom resource that creates the validated certificate\n   *\n   * @default - A new role will be created\n   */\n  readonly customResourceRole?: iam.IRole;\n\n  /**\n   * When set to true, when the DnsValidatedCertificate is deleted,\n   * the associated Route53 validation records are removed.\n   *\n   * CAUTION: If multiple certificates share the same domains (and same validation records),\n   * this can cause the other certificates to fail renewal and/or not validate.\n   * Not recommended for production use.\n   *\n   * @default false\n   */\n  readonly cleanupRoute53Records?: boolean;\n}\n\n/**\n * A certificate managed by AWS Certificate Manager.  Will be automatically\n * validated using DNS validation against the specified Route 53 hosted zone.\n *\n * @resource AWS::CertificateManager::Certificate\n */\nexport class DnsValidatedCertificate extends CertificateBase implements ICertificate, cdk.ITaggable {\n  public readonly certificateArn: string;\n\n  /**\n  * Resource Tags.\n  * @see https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-certificatemanager-certificate.html#cfn-certificatemanager-certificate-tags\n  */\n\n  public readonly tags: cdk.TagManager;\n  protected readonly region?: string;\n  private normalizedZoneName: string;\n  private hostedZoneId: string;\n  private domainName: string;\n\n  constructor(scope: Construct, id: string, props: DnsValidatedCertificateProps) {\n    super(scope, id);\n\n    this.region = props.region;\n\n    this.domainName = props.domainName;\n    this.normalizedZoneName = props.hostedZone.zoneName;\n    // Remove trailing `.` from zone name\n    if (this.normalizedZoneName.endsWith('.')) {\n      this.normalizedZoneName = this.normalizedZoneName.substring(0, this.normalizedZoneName.length - 1);\n    }\n\n    // Remove any `/hostedzone/` prefix from the Hosted Zone ID\n    this.hostedZoneId = props.hostedZone.hostedZoneId.replace(/^\\/hostedzone\\//, '');\n    this.tags = new cdk.TagManager(cdk.TagType.MAP, 'AWS::CertificateManager::Certificate');\n\n    const requestorFunction = new lambda.Function(this, 'CertificateRequestorFunction', {\n      code: lambda.Code.fromAsset(path.resolve(__dirname, '..', 'lambda-packages', 'dns_validated_certificate_handler', 'lib')),\n      handler: 'index.certificateRequestHandler',\n      runtime: lambda.Runtime.NODEJS_12_X,\n      timeout: cdk.Duration.minutes(15),\n      role: props.customResourceRole,\n    });\n    requestorFunction.addToRolePolicy(new iam.PolicyStatement({\n      actions: ['acm:RequestCertificate', 'acm:DescribeCertificate', 'acm:DeleteCertificate', 'acm:AddTagsToCertificate'],\n      resources: ['*'],\n    }));\n    requestorFunction.addToRolePolicy(new iam.PolicyStatement({\n      actions: ['route53:GetChange'],\n      resources: ['*'],\n    }));\n    requestorFunction.addToRolePolicy(new iam.PolicyStatement({\n      actions: ['route53:changeResourceRecordSets'],\n      resources: [`arn:${cdk.Stack.of(requestorFunction).partition}:route53:::hostedzone/${this.hostedZoneId}`],\n    }));\n\n    const certificate = new cdk.CustomResource(this, 'CertificateRequestorResource', {\n      serviceToken: requestorFunction.functionArn,\n      properties: {\n        DomainName: props.domainName,\n        SubjectAlternativeNames: cdk.Lazy.list({ produce: () => props.subjectAlternativeNames }, { omitEmpty: true }),\n        HostedZoneId: this.hostedZoneId,\n        Region: props.region,\n        Route53Endpoint: props.route53Endpoint,\n        // Custom resources properties are always converted to strings; might as well be explict here.\n        CleanupRecords: props.cleanupRoute53Records ? 'true' : undefined,\n        Tags: cdk.Lazy.list({ produce: () => this.tags.renderTags() }),\n      },\n    });\n\n    this.certificateArn = certificate.getAtt('Arn').toString();\n\n    this.node.addValidation({ validate: () => this.validateDnsValidatedCertificate() });\n  }\n\n  private validateDnsValidatedCertificate(): string[] {\n    const errors: string[] = [];\n    // Ensure the zone name is a parent zone of the certificate domain name\n    if (!cdk.Token.isUnresolved(this.normalizedZoneName) &&\n      this.domainName !== this.normalizedZoneName &&\n      !this.domainName.endsWith('.' + this.normalizedZoneName)) {\n      errors.push(`DNS zone ${this.normalizedZoneName} is not authoritative for certificate domain name ${this.domainName}`);\n    }\n    return errors;\n  }\n}\n"],
  "mappings": "8NAAA,KAAA,QAAA,MAAA,EACA,IAAA,QAAA,eAAA,EACA,OAAA,QAAA,kBAAA,EAEA,IAAA,QAAA,YAAA,EAGA,mBAAA,QAAA,oBAAA,EA6DA,MAAa,+BAAgC,oBAAA,eAAe,CAc1D,YAAY,MAAkB,GAAY,MAAmC,CAC3E,MAAM,MAAO,EAAE,iGAEf,KAAK,OAAS,MAAM,OAEpB,KAAK,WAAa,MAAM,WACxB,KAAK,mBAAqB,MAAM,WAAW,SAEvC,KAAK,mBAAmB,SAAS,GAAG,GACtC,MAAK,mBAAqB,KAAK,mBAAmB,UAAU,EAAG,KAAK,mBAAmB,OAAS,CAAC,GAInG,KAAK,aAAe,MAAM,WAAW,aAAa,QAAQ,kBAAmB,EAAE,EAC/E,KAAK,KAAO,GAAI,KAAI,WAAW,IAAI,QAAQ,IAAK,sCAAsC,EAEtF,KAAM,mBAAoB,GAAI,QAAO,SAAS,KAAM,+BAAgC,CAClF,KAAM,OAAO,KAAK,UAAU,KAAK,QAAQ,UAAW,KAAM,kBAAmB,oCAAqC,KAAK,CAAC,EACxH,QAAS,kCACT,QAAS,OAAO,QAAQ,YACxB,QAAS,IAAI,SAAS,QAAQ,EAAE,EAChC,KAAM,MAAM,mBACb,EACD,kBAAkB,gBAAgB,GAAI,KAAI,gBAAgB,CACxD,QAAS,CAAC,yBAA0B,0BAA2B,wBAAyB,0BAA0B,EAClH,UAAW,CAAC,GAAG,EAChB,CAAC,EACF,kBAAkB,gBAAgB,GAAI,KAAI,gBAAgB,CACxD,QAAS,CAAC,mBAAmB,EAC7B,UAAW,CAAC,GAAG,EAChB,CAAC,EACF,kBAAkB,gBAAgB,GAAI,KAAI,gBAAgB,CACxD,QAAS,CAAC,kCAAkC,EAC5C,UAAW,CAAC,OAAO,IAAI,MAAM,GAAG,iBAAiB,EAAE,kCAAkC,KAAK,cAAc,EACzG,CAAC,EAEF,KAAM,aAAc,GAAI,KAAI,eAAe,KAAM,+BAAgC,CAC/E,aAAc,kBAAkB,YAChC,WAAY,CACV,WAAY,MAAM,WAClB,wBAAyB,IAAI,KAAK,KAAK,CAAE,QAAS,IAAM,MAAM,uBAAuB,EAAI,CAAE,UAAW,EAAI,CAAE,EAC5G,aAAc,KAAK,aACnB,OAAQ,MAAM,OACd,gBAAiB,MAAM,gBAEvB,eAAgB,MAAM,sBAAwB,OAAS,OACvD,KAAM,IAAI,KAAK,KAAK,CAAE,QAAS,IAAM,KAAK,KAAK,WAAU,CAAE,CAAE,GAEhE,EAED,KAAK,eAAiB,YAAY,OAAO,KAAK,EAAE,SAAQ,EAExD,KAAK,KAAK,cAAc,CAAE,SAAU,IAAM,KAAK,gCAA+B,CAAE,CAAE,EAG5E,iCAA+B,CACrC,KAAM,QAAmB,CAAA,EAEzB,MAAI,CAAC,IAAI,MAAM,aAAa,KAAK,kBAAkB,GACjD,KAAK,aAAe,KAAK,oBACzB,CAAC,KAAK,WAAW,SAAS,IAAM,KAAK,kBAAkB,GACvD,OAAO,KAAK,YAAY,KAAK,uEAAuE,KAAK,YAAY,EAEhH,QA7EX,QAAA,wBAAA",
  "names": []
}
