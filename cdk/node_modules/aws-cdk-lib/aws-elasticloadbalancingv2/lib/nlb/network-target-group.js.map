{
  "version": 3,
  "sources": ["network-target-group.ts"],
  "sourcesContent": ["import * as cloudwatch from '../../../aws-cloudwatch';\nimport * as cdk from '../../../core';\nimport { Construct } from 'constructs';\nimport {\n  BaseTargetGroupProps, HealthCheck, ITargetGroup, loadBalancerNameFromListenerArn, LoadBalancerTargetProps,\n  TargetGroupAttributes, TargetGroupBase, TargetGroupImportProps,\n} from '../shared/base-target-group';\nimport { Protocol } from '../shared/enums';\nimport { ImportedTargetGroupBase } from '../shared/imported';\nimport { validateNetworkProtocol } from '../shared/util';\nimport { INetworkListener } from './network-listener';\n\n/**\n * Properties for a new Network Target Group\n */\nexport interface NetworkTargetGroupProps extends BaseTargetGroupProps {\n  /**\n   * The port on which the listener listens for requests.\n   */\n  readonly port: number;\n\n  /**\n   * Protocol for target group, expects TCP, TLS, UDP, or TCP_UDP.\n   *\n   * @default - TCP\n   */\n  readonly protocol?: Protocol;\n\n  /**\n   * Indicates whether Proxy Protocol version 2 is enabled.\n   *\n   * @default false\n   */\n  readonly proxyProtocolV2?: boolean;\n\n  /**\n   * Indicates whether client IP preservation is enabled.\n   *\n   * @default false if the target group type is IP address and the\n   * target group protocol is TCP or TLS. Otherwise, true.\n   */\n  readonly preserveClientIp?: boolean;\n\n  /**\n   * The targets to add to this target group.\n   *\n   * Can be `Instance`, `IPAddress`, or any self-registering load balancing\n   * target. If you use either `Instance` or `IPAddress` as targets, all\n   * target must be of the same type.\n   *\n   * @default - No targets.\n   */\n  readonly targets?: INetworkLoadBalancerTarget[];\n}\n\n/**\n * Define a Network Target Group\n */\nexport class NetworkTargetGroup extends TargetGroupBase implements INetworkTargetGroup {\n  /**\n   * Import an existing target group\n   */\n  public static fromTargetGroupAttributes(scope: Construct, id: string, attrs: TargetGroupAttributes): INetworkTargetGroup {\n    return new ImportedNetworkTargetGroup(scope, id, attrs);\n  }\n\n  /**\n   * Import an existing listener\n   *\n   * @deprecated Use `fromTargetGroupAttributes` instead\n   */\n  public static import(scope: Construct, id: string, props: TargetGroupImportProps): INetworkTargetGroup {\n    return NetworkTargetGroup.fromTargetGroupAttributes(scope, id, props);\n  }\n\n  private readonly listeners: INetworkListener[];\n\n  constructor(scope: Construct, id: string, props: NetworkTargetGroupProps) {\n    const proto = props.protocol || Protocol.TCP;\n    validateNetworkProtocol(proto);\n\n    super(scope, id, props, {\n      protocol: proto,\n      port: props.port,\n    });\n\n    this.listeners = [];\n\n    if (props.proxyProtocolV2 != null) {\n      this.setAttribute('proxy_protocol_v2.enabled', props.proxyProtocolV2 ? 'true' : 'false');\n    }\n\n    if (props.preserveClientIp !== undefined) {\n      this.setAttribute('preserve_client_ip.enabled', props.preserveClientIp ? 'true' : 'false');\n    }\n\n    this.addTarget(...(props.targets || []));\n  }\n\n  /**\n   * Add a load balancing target to this target group\n   */\n  public addTarget(...targets: INetworkLoadBalancerTarget[]) {\n    for (const target of targets) {\n      const result = target.attachToNetworkTargetGroup(this);\n      this.addLoadBalancerTarget(result);\n    }\n  }\n\n  /**\n   * Register a listener that is load balancing to this target group.\n   *\n   * Don't call this directly. It will be called by listeners.\n   */\n  public registerListener(listener: INetworkListener) {\n    this.loadBalancerAttachedDependencies.add(listener);\n    this.listeners.push(listener);\n  }\n\n  /**\n   * The number of targets that are considered healthy.\n   *\n   * @default Average over 5 minutes\n   */\n  public metricHealthyHostCount(props?: cloudwatch.MetricOptions) {\n    return this.metric('HealthyHostCount', {\n      statistic: 'Average',\n      ...props,\n    });\n  }\n\n  /**\n   * The number of targets that are considered unhealthy.\n   *\n   * @default Average over 5 minutes\n   */\n  public metricUnHealthyHostCount(props?: cloudwatch.MetricOptions) {\n    return this.metric('UnHealthyHostCount', {\n      statistic: 'Average',\n      ...props,\n    });\n  }\n\n  /**\n   * Full name of first load balancer\n   */\n  public get firstLoadBalancerFullName(): string {\n    if (this.listeners.length === 0) {\n      throw new Error('The TargetGroup needs to be attached to a LoadBalancer before you can call this method');\n    }\n    return loadBalancerNameFromListenerArn(this.listeners[0].listenerArn);\n  }\n\n  protected validateTargetGroup(): string[] {\n    const ret = super.validateTargetGroup();\n\n    const healthCheck: HealthCheck = this.healthCheck || {};\n\n    const allowedIntervals = [10, 30];\n    if (healthCheck.interval) {\n      const seconds = healthCheck.interval.toSeconds();\n      if (!cdk.Token.isUnresolved(seconds) && !allowedIntervals.includes(seconds)) {\n        ret.push(`Health check interval '${seconds}' not supported. Must be one of the following values '${allowedIntervals.join(',')}'.`);\n      }\n    }\n\n    if (healthCheck.healthyThresholdCount) {\n      const thresholdCount = healthCheck.healthyThresholdCount;\n      if (thresholdCount < 2 || thresholdCount > 10) {\n        ret.push(`Healthy Threshold Count '${thresholdCount}' not supported. Must be a number between 2 and 10.`);\n      }\n    }\n\n    if (healthCheck.unhealthyThresholdCount) {\n      const thresholdCount = healthCheck.unhealthyThresholdCount;\n      if (thresholdCount < 2 || thresholdCount > 10) {\n        ret.push(`Unhealthy Threshold Count '${thresholdCount}' not supported. Must be a number between 2 and 10.`);\n      }\n    }\n\n    if (healthCheck.healthyThresholdCount && healthCheck.unhealthyThresholdCount &&\n      healthCheck.healthyThresholdCount !== healthCheck.unhealthyThresholdCount) {\n      ret.push([\n        `Healthy and Unhealthy Threshold Counts must be the same: ${healthCheck.healthyThresholdCount}`,\n        `is not equal to ${healthCheck.unhealthyThresholdCount}.`,\n      ].join(' '));\n    }\n\n    if (!healthCheck.protocol) {\n      return ret;\n    }\n\n    if (!NLB_HEALTH_CHECK_PROTOCOLS.includes(healthCheck.protocol)) {\n      ret.push(`Health check protocol '${healthCheck.protocol}' is not supported. Must be one of [${NLB_HEALTH_CHECK_PROTOCOLS.join(', ')}]`);\n    }\n    if (healthCheck.path && !NLB_PATH_HEALTH_CHECK_PROTOCOLS.includes(healthCheck.protocol)) {\n      ret.push([\n        `'${healthCheck.protocol}' health checks do not support the path property.`,\n        `Must be one of [${NLB_PATH_HEALTH_CHECK_PROTOCOLS.join(', ')}]`,\n      ].join(' '));\n    }\n    if (healthCheck.timeout && healthCheck.timeout.toSeconds() !== NLB_HEALTH_CHECK_TIMEOUTS[healthCheck.protocol]) {\n      ret.push([\n        'Custom health check timeouts are not supported for Network Load Balancer health checks.',\n        `Expected ${NLB_HEALTH_CHECK_TIMEOUTS[healthCheck.protocol]} seconds for ${healthCheck.protocol}, got ${healthCheck.timeout.toSeconds()}`,\n      ].join(' '));\n    }\n\n    return ret;\n  }\n\n  private metric(metricName: string, props?: cloudwatch.MetricOptions): cloudwatch.Metric {\n    return new cloudwatch.Metric({\n      namespace: 'AWS/NetworkELB',\n      metricName,\n      dimensionsMap: { LoadBalancer: this.firstLoadBalancerFullName, TargetGroup: this.targetGroupFullName },\n      ...props,\n    }).attachTo(this);\n  }\n}\n\n/**\n * A network target group\n */\nexport interface INetworkTargetGroup extends ITargetGroup {\n  /**\n   * Register a listener that is load balancing to this target group.\n   *\n   * Don't call this directly. It will be called by listeners.\n   */\n  registerListener(listener: INetworkListener): void;\n\n  /**\n   * Add a load balancing target to this target group\n   */\n  addTarget(...targets: INetworkLoadBalancerTarget[]): void;\n}\n\n/**\n * An imported network target group\n */\nclass ImportedNetworkTargetGroup extends ImportedTargetGroupBase implements INetworkTargetGroup {\n  public registerListener(_listener: INetworkListener) {\n    // Nothing to do, we know nothing of our members\n  }\n\n  public addTarget(...targets: INetworkLoadBalancerTarget[]) {\n    for (const target of targets) {\n      const result = target.attachToNetworkTargetGroup(this);\n      if (result.targetJson !== undefined) {\n        throw new Error('Cannot add a non-self registering target to an imported TargetGroup. Create a new TargetGroup instead.');\n      }\n    }\n  }\n}\n\n/**\n * Interface for constructs that can be targets of an network load balancer\n */\nexport interface INetworkLoadBalancerTarget {\n  /**\n   * Attach load-balanced target to a TargetGroup\n   *\n   * May return JSON to directly add to the [Targets] list, or return undefined\n   * if the target will register itself with the load balancer.\n   */\n  attachToNetworkTargetGroup(targetGroup: INetworkTargetGroup): LoadBalancerTargetProps;\n}\n\nconst NLB_HEALTH_CHECK_PROTOCOLS = [Protocol.HTTP, Protocol.HTTPS, Protocol.TCP];\nconst NLB_PATH_HEALTH_CHECK_PROTOCOLS = [Protocol.HTTP, Protocol.HTTPS];\nconst NLB_HEALTH_CHECK_TIMEOUTS: { [protocol in Protocol]?: number } = {\n  [Protocol.HTTP]: 6,\n  [Protocol.HTTPS]: 10,\n  [Protocol.TCP]: 10,\n};\n"],
  "mappings": "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",
  "names": []
}
