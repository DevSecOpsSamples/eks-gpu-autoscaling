{
  "version": 3,
  "sources": ["util.ts"],
  "sourcesContent": ["import * as cxschema from '../../../cloud-assembly-schema';\nimport { ApplicationProtocol, Protocol } from './enums';\n\nexport type Attributes = { [key: string]: string | undefined };\n\n/**\n * Render an attribute dict to a list of { key, value } pairs\n */\nexport function renderAttributes(attributes: Attributes) {\n  const ret: any[] = [];\n  for (const [key, value] of Object.entries(attributes)) {\n    if (value !== undefined) {\n      ret.push({ key, value });\n    }\n  }\n  return ret;\n}\n\n/**\n * Return the appropriate default port for a given protocol\n */\nexport function defaultPortForProtocol(proto: ApplicationProtocol): number {\n  switch (proto) {\n    case ApplicationProtocol.HTTP: return 80;\n    case ApplicationProtocol.HTTPS: return 443;\n    default:\n      throw new Error(`Unrecognized protocol: ${proto}`);\n  }\n}\n\n/**\n * Return the appropriate default protocol for a given port\n */\nexport function defaultProtocolForPort(port: number): ApplicationProtocol {\n  switch (port) {\n    case 80:\n    case 8000:\n    case 8008:\n    case 8080:\n      return ApplicationProtocol.HTTP;\n\n    case 443:\n    case 8443:\n      return ApplicationProtocol.HTTPS;\n\n    default:\n      throw new Error(`Don't know default protocol for port: ${port}; please supply a protocol`);\n  }\n}\n\n/**\n * Given a protocol and a port, try to guess the other one if it's undefined\n */\n// eslint-disable-next-line max-len\nexport function determineProtocolAndPort(protocol: ApplicationProtocol | undefined, port: number | undefined): [ApplicationProtocol | undefined, number | undefined] {\n  if (protocol === undefined && port === undefined) {\n    return [undefined, undefined];\n  }\n\n  if (protocol === undefined) { protocol = defaultProtocolForPort(port!); }\n  if (port === undefined) { port = defaultPortForProtocol(protocol!); }\n\n  return [protocol, port];\n}\n\n/**\n * Helper function to default undefined input props\n */\nexport function ifUndefined<T>(x: T | undefined, def: T) {\n  return x ?? def;\n}\n\n/**\n * Helper function for ensuring network listeners and target groups only accept valid\n * protocols.\n */\nexport function validateNetworkProtocol(protocol: Protocol) {\n  const NLB_PROTOCOLS = [Protocol.TCP, Protocol.TLS, Protocol.UDP, Protocol.TCP_UDP];\n\n  if (NLB_PROTOCOLS.indexOf(protocol) === -1) {\n    throw new Error(`The protocol must be one of ${NLB_PROTOCOLS.join(', ')}. Found ${protocol}`);\n  }\n}\n\n/**\n * Helper to map a map of tags to cxschema tag format.\n * @internal\n */\nexport function mapTagMapToCxschema(tagMap: Record<string, string>): cxschema.Tag[] {\n  return Object.entries(tagMap)\n    .map(([key, value]) => ({ key, value }));\n}\n"],
  "mappings": "mRACA,KAAA,SAAA,QAAA,SAAA,EAOA,0BAAiC,WAAsB,CACrD,KAAM,KAAa,CAAA,EACnB,SAAW,CAAC,IAAK,QAAU,QAAO,QAAQ,UAAU,EAClD,AAAI,QAAU,QACZ,IAAI,KAAK,CAAE,IAAK,KAAK,CAAE,EAG3B,MAAO,IACT,CARA,QAAA,iBAAA,iBAaA,gCAAuC,MAA0B,CAC/D,OAAQ,WACD,SAAA,oBAAoB,KAAM,MAAO,QACjC,SAAA,oBAAoB,MAAO,MAAO,aAErC,KAAM,IAAI,OAAM,0BAA0B,OAAO,EAEvD,CAPA,QAAA,uBAAA,uBAYA,gCAAuC,KAAY,CACjD,OAAQ,UACD,QACA,SACA,UACA,MACH,MAAO,SAAA,oBAAoB,SAExB,SACA,MACH,MAAO,SAAA,oBAAoB,cAG3B,KAAM,IAAI,OAAM,yCAAyC,gCAAgC,EAE/F,CAfA,QAAA,uBAAA,uBAqBA,kCAAyC,SAA2C,KAAwB,CAC1G,MAAI,YAAa,QAAa,OAAS,OAC9B,CAAC,OAAW,MAAS,EAG1B,YAAa,QAAa,UAAW,uBAAuB,IAAK,GACjE,OAAS,QAAa,MAAO,uBAAuB,QAAS,GAE1D,CAAC,SAAU,IAAI,EACxB,CATA,QAAA,yBAAA,yBAcA,qBAA+B,EAAkB,IAAM,CACrD,MAAO,IAAC,KAAD,EAAK,GACd,CAFA,QAAA,YAAA,YAQA,iCAAwC,SAAkB,CACxD,KAAM,eAAgB,CAAC,QAAA,SAAS,IAAK,QAAA,SAAS,IAAK,QAAA,SAAS,IAAK,QAAA,SAAS,OAAO,EAEjF,GAAI,cAAc,QAAQ,QAAQ,IAAM,GACtC,KAAM,IAAI,OAAM,+BAA+B,cAAc,KAAK,IAAI,YAAY,UAAU,CAEhG,CANA,QAAA,wBAAA,wBAYA,6BAAoC,OAA8B,CAChE,MAAO,QAAO,QAAQ,MAAM,EACzB,IAAI,CAAC,CAAC,IAAK,SAAY,EAAE,IAAK,KAAK,EAAG,CAC3C,CAHA,QAAA,oBAAA",
  "names": []
}
