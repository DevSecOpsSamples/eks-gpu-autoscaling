{
  "version": 3,
  "sources": ["application-target-group.ts"],
  "sourcesContent": ["import * as cloudwatch from '../../../aws-cloudwatch';\nimport * as ec2 from '../../../aws-ec2';\nimport { Annotations, Duration, Token } from '../../../core';\nimport { IConstruct, Construct } from 'constructs';\nimport { ApplicationELBMetrics } from '../elasticloadbalancingv2-canned-metrics.generated';\nimport {\n  BaseTargetGroupProps, ITargetGroup, loadBalancerNameFromListenerArn, LoadBalancerTargetProps,\n  TargetGroupAttributes, TargetGroupBase, TargetGroupImportProps,\n} from '../shared/base-target-group';\nimport { ApplicationProtocol, ApplicationProtocolVersion, Protocol, TargetType, TargetGroupLoadBalancingAlgorithmType } from '../shared/enums';\nimport { ImportedTargetGroupBase } from '../shared/imported';\nimport { determineProtocolAndPort } from '../shared/util';\nimport { IApplicationListener } from './application-listener';\nimport { HttpCodeTarget } from './application-load-balancer';\n\n/**\n * Properties for defining an Application Target Group\n */\nexport interface ApplicationTargetGroupProps extends BaseTargetGroupProps {\n  /**\n   * The protocol to use\n   *\n   * @default - Determined from port if known, optional for Lambda targets.\n   */\n  readonly protocol?: ApplicationProtocol;\n\n  /**\n   * The protocol version to use\n   *\n   * @default ApplicationProtocolVersion.HTTP1\n   */\n  readonly protocolVersion?: ApplicationProtocolVersion;\n\n  /**\n   * The port on which the listener listens for requests.\n   *\n   * @default - Determined from protocol if known, optional for Lambda targets.\n   */\n  readonly port?: number;\n\n  /**\n   * The time period during which the load balancer sends a newly registered\n   * target a linearly increasing share of the traffic to the target group.\n   *\n   * The range is 30-900 seconds (15 minutes).\n   *\n   * @default 0\n   */\n  readonly slowStart?: Duration;\n\n  /**\n   * The stickiness cookie expiration period.\n   *\n   * Setting this value enables load balancer stickiness.\n   *\n   * After this period, the cookie is considered stale. The minimum value is\n   * 1 second and the maximum value is 7 days (604800 seconds).\n   *\n   * @default Duration.days(1)\n   */\n  readonly stickinessCookieDuration?: Duration;\n\n  /**\n   * The name of an application-based stickiness cookie.\n   *\n   * Names that start with the following prefixes are not allowed: AWSALB, AWSALBAPP,\n   * and AWSALBTG; they're reserved for use by the load balancer.\n   *\n   * Note: `stickinessCookieName` parameter depends on the presence of `stickinessCookieDuration` parameter.\n   * If `stickinessCookieDuration` is not set, `stickinessCookieName` will be omitted.\n   *\n   * @default - If `stickinessCookieDuration` is set, a load-balancer generated cookie is used. Otherwise, no stickiness is defined.\n   * @see https://docs.aws.amazon.com/elasticloadbalancing/latest/application/sticky-sessions.html\n   */\n  readonly stickinessCookieName?: string;\n\n  /**\n   * The load balancing algorithm to select targets for routing requests.\n   *\n   * @default TargetGroupLoadBalancingAlgorithmType.ROUND_ROBIN\n   */\n  readonly loadBalancingAlgorithmType?: TargetGroupLoadBalancingAlgorithmType;\n\n  /**\n   * The targets to add to this target group.\n   *\n   * Can be `Instance`, `IPAddress`, or any self-registering load balancing\n   * target. If you use either `Instance` or `IPAddress` as targets, all\n   * target must be of the same type.\n   *\n   * @default - No targets.\n   */\n  readonly targets?: IApplicationLoadBalancerTarget[];\n}\n\n/**\n * Define an Application Target Group\n */\nexport class ApplicationTargetGroup extends TargetGroupBase implements IApplicationTargetGroup {\n  /**\n   * Import an existing target group\n   */\n  public static fromTargetGroupAttributes(scope: Construct, id: string, attrs: TargetGroupAttributes): IApplicationTargetGroup {\n    return new ImportedApplicationTargetGroup(scope, id, attrs);\n  }\n\n  /**\n   * Import an existing target group\n   *\n   * @deprecated Use `fromTargetGroupAttributes` instead\n   */\n  public static import(scope: Construct, id: string, props: TargetGroupImportProps): IApplicationTargetGroup {\n    return ApplicationTargetGroup.fromTargetGroupAttributes(scope, id, props);\n  }\n\n  private readonly connectableMembers: ConnectableMember[];\n  private readonly listeners: IApplicationListener[];\n  private readonly protocol?: ApplicationProtocol;\n  private readonly port?: number;\n\n  constructor(scope: Construct, id: string, props: ApplicationTargetGroupProps = {}) {\n    const [protocol, port] = determineProtocolAndPort(props.protocol, props.port);\n    const { protocolVersion } = props;\n    super(scope, id, { ...props }, {\n      protocol,\n      protocolVersion,\n      port,\n    });\n\n    this.protocol = protocol;\n    this.port = port;\n\n    // this.targetType is lazy\n    this.node.addValidation({\n      validate: () => {\n        if (this.targetType === TargetType.LAMBDA && (this.port || this.protocol)) {\n          return ['port/protocol should not be specified for Lambda targets'];\n        } else {\n          return [];\n        }\n      },\n    });\n\n    this.connectableMembers = [];\n    this.listeners = [];\n\n    if (props) {\n      if (props.slowStart !== undefined) {\n        if (props.slowStart.toSeconds() < 30 || props.slowStart.toSeconds() > 900) {\n          throw new Error('Slow start duration value must be between 30 and 900 seconds.');\n        }\n        this.setAttribute('slow_start.duration_seconds', props.slowStart.toSeconds().toString());\n      }\n\n      if (props.stickinessCookieDuration) {\n        this.enableCookieStickiness(props.stickinessCookieDuration, props.stickinessCookieName);\n      } else {\n        this.setAttribute('stickiness.enabled', 'false');\n      }\n\n      if (props.loadBalancingAlgorithmType) {\n        this.setAttribute('load_balancing.algorithm.type', props.loadBalancingAlgorithmType);\n      }\n      this.addTarget(...(props.targets || []));\n    }\n  }\n\n  /**\n   * Add a load balancing target to this target group\n   */\n  public addTarget(...targets: IApplicationLoadBalancerTarget[]) {\n    for (const target of targets) {\n      const result = target.attachToApplicationTargetGroup(this);\n      this.addLoadBalancerTarget(result);\n    }\n\n    if (this.targetType === TargetType.LAMBDA) {\n      this.setAttribute('stickiness.enabled', undefined);\n    }\n  }\n\n  /**\n   * Enable sticky routing via a cookie to members of this target group.\n   *\n   * Note: If the `cookieName` parameter is set, application-based stickiness will be applied,\n   * otherwise it defaults to duration-based stickiness attributes (`lb_cookie`).\n   *\n   * @see https://docs.aws.amazon.com/elasticloadbalancing/latest/application/sticky-sessions.html\n   */\n  public enableCookieStickiness(duration: Duration, cookieName?: string) {\n    if (duration.toSeconds() < 1 || duration.toSeconds() > 604800) {\n      throw new Error('Stickiness cookie duration value must be between 1 second and 7 days (604800 seconds).');\n    }\n    if (cookieName !== undefined) {\n      if (!Token.isUnresolved(cookieName) && (cookieName.startsWith('AWSALB') || cookieName.startsWith('AWSALBAPP') || cookieName.startsWith('AWSALBTG'))) {\n        throw new Error('App cookie names that start with the following prefixes are not allowed: AWSALB, AWSALBAPP, and AWSALBTG; they\\'re reserved for use by the load balancer.');\n      }\n      if (cookieName === '') {\n        throw new Error('App cookie name cannot be an empty string.');\n      }\n    }\n    this.setAttribute('stickiness.enabled', 'true');\n    if (cookieName) {\n      this.setAttribute('stickiness.type', 'app_cookie');\n      this.setAttribute('stickiness.app_cookie.cookie_name', cookieName);\n      this.setAttribute('stickiness.app_cookie.duration_seconds', duration.toSeconds().toString());\n    } else {\n      this.setAttribute('stickiness.type', 'lb_cookie');\n      this.setAttribute('stickiness.lb_cookie.duration_seconds', duration.toSeconds().toString());\n    }\n  }\n\n  /**\n   * Register a connectable as a member of this target group.\n   *\n   * Don't call this directly. It will be called by load balancing targets.\n   */\n  public registerConnectable(connectable: ec2.IConnectable, portRange?: ec2.Port) {\n    portRange = portRange || ec2.Port.tcp(this.defaultPort);\n\n    // Notify all listeners that we already know about of this new connectable.\n    // Then remember for new listeners that might get added later.\n    this.connectableMembers.push({ connectable, portRange });\n    for (const listener of this.listeners) {\n      listener.registerConnectable(connectable, portRange);\n    }\n  }\n\n  /**\n   * Register a listener that is load balancing to this target group.\n   *\n   * Don't call this directly. It will be called by listeners.\n   */\n  public registerListener(listener: IApplicationListener, associatingConstruct?: IConstruct) {\n    // Notify this listener of all connectables that we know about.\n    // Then remember for new connectables that might get added later.\n    for (const member of this.connectableMembers) {\n      listener.registerConnectable(member.connectable, member.portRange);\n    }\n    this.listeners.push(listener);\n    this.loadBalancerAttachedDependencies.add(associatingConstruct ?? listener);\n  }\n\n  /**\n   * Full name of first load balancer\n   */\n  public get firstLoadBalancerFullName(): string {\n    if (this.listeners.length === 0) {\n      throw new Error('The TargetGroup needs to be attached to a LoadBalancer before you can call this method');\n    }\n    return loadBalancerNameFromListenerArn(this.listeners[0].listenerArn);\n  }\n\n  /**\n   * Return the given named metric for this Application Load Balancer Target Group\n   *\n   * Returns the metric for this target group from the point of view of the first\n   * load balancer load balancing to it. If you have multiple load balancers load\n   * sending traffic to the same target group, you will have to override the dimensions\n   * on this metric.\n   *\n   * @default Average over 5 minutes\n   */\n  public metric(metricName: string, props?: cloudwatch.MetricOptions): cloudwatch.Metric {\n    return new cloudwatch.Metric({\n      namespace: 'AWS/ApplicationELB',\n      metricName,\n      dimensionsMap: {\n        TargetGroup: this.targetGroupFullName,\n        LoadBalancer: this.firstLoadBalancerFullName,\n      },\n      ...props,\n    }).attachTo(this);\n  }\n\n  /**\n   * The number of IPv6 requests received by the target group\n   *\n   * @default Sum over 5 minutes\n   */\n  public metricIpv6RequestCount(props?: cloudwatch.MetricOptions) {\n    return this.cannedMetric(ApplicationELBMetrics.iPv6RequestCountSum, props);\n  }\n\n  /**\n   * The number of requests processed over IPv4 and IPv6.\n   *\n   * This count includes only the requests with a response generated by a target of the load balancer.\n   *\n   * @default Sum over 5 minutes\n   */\n  public metricRequestCount(props?: cloudwatch.MetricOptions) {\n    return this.cannedMetric(ApplicationELBMetrics.requestCountSum, props);\n  }\n\n  /**\n   * The number of healthy hosts in the target group\n   *\n   * @default Average over 5 minutes\n   */\n  public metricHealthyHostCount(props?: cloudwatch.MetricOptions) {\n    return this.metric('HealthyHostCount', {\n      statistic: 'Average',\n      ...props,\n    });\n  }\n\n  /**\n   * The number of unhealthy hosts in the target group\n   *\n   * @default Average over 5 minutes\n   */\n  public metricUnhealthyHostCount(props?: cloudwatch.MetricOptions) {\n    return this.metric('UnHealthyHostCount', {\n      statistic: 'Average',\n      ...props,\n    });\n  }\n\n  /**\n   * The number of HTTP 2xx/3xx/4xx/5xx response codes generated by all targets in this target group.\n   *\n   * This does not include any response codes generated by the load balancer.\n   *\n   * @default Sum over 5 minutes\n   */\n  public metricHttpCodeTarget(code: HttpCodeTarget, props?: cloudwatch.MetricOptions) {\n    return this.metric(code, {\n      statistic: 'Sum',\n      ...props,\n    });\n  }\n\n  /**\n   * The average number of requests received by each target in a target group.\n   *\n   * The only valid statistic is Sum. Note that this represents the average not the sum.\n   *\n   * @default Sum over 5 minutes\n   */\n  public metricRequestCountPerTarget(props?: cloudwatch.MetricOptions) {\n    return this.metric('RequestCountPerTarget', {\n      statistic: 'Sum',\n      ...props,\n    });\n  }\n\n  /**\n   * The number of connections that were not successfully established between the load balancer and target.\n   *\n   * @default Sum over 5 minutes\n   */\n  public metricTargetConnectionErrorCount(props?: cloudwatch.MetricOptions) {\n    return this.metric('TargetConnectionErrorCount', {\n      statistic: 'Sum',\n      ...props,\n    });\n  }\n\n  /**\n   * The time elapsed, in seconds, after the request leaves the load balancer until a response from the target is received.\n   *\n   * @default Average over 5 minutes\n   */\n  public metricTargetResponseTime(props?: cloudwatch.MetricOptions) {\n    return this.metric('TargetResponseTime', {\n      statistic: 'Average',\n      ...props,\n    });\n  }\n\n  /**\n   * The number of TLS connections initiated by the load balancer that did not establish a session with the target.\n   *\n   * Possible causes include a mismatch of ciphers or protocols.\n   *\n   * @default Sum over 5 minutes\n   */\n  public metricTargetTLSNegotiationErrorCount(props?: cloudwatch.MetricOptions) {\n    return this.metric('TargetTLSNegotiationErrorCount', {\n      statistic: 'Sum',\n      ...props,\n    });\n  }\n\n  protected validateTargetGroup(): string[] {\n    const ret = super.validateTargetGroup();\n\n    if (this.targetType !== undefined && this.targetType !== TargetType.LAMBDA\n      && (this.protocol === undefined || this.port === undefined)) {\n      ret.push('At least one of \\'port\\' or \\'protocol\\' is required for a non-Lambda TargetGroup');\n    }\n\n    if (this.healthCheck && this.healthCheck.protocol) {\n\n      if (ALB_HEALTH_CHECK_PROTOCOLS.includes(this.healthCheck.protocol)) {\n        if (this.healthCheck.interval && this.healthCheck.timeout &&\n          this.healthCheck.interval.toMilliseconds() <= this.healthCheck.timeout.toMilliseconds()) {\n          ret.push(`Healthcheck interval ${this.healthCheck.interval.toHumanString()} must be greater than the timeout ${this.healthCheck.timeout.toHumanString()}`);\n        }\n      }\n\n      if (!ALB_HEALTH_CHECK_PROTOCOLS.includes(this.healthCheck.protocol)) {\n        ret.push([\n          `Health check protocol '${this.healthCheck.protocol}' is not supported. `,\n          `Must be one of [${ALB_HEALTH_CHECK_PROTOCOLS.join(', ')}]`,\n        ].join(''));\n      }\n    }\n\n    return ret;\n  }\n\n  private cannedMetric(\n    fn: (dims: { LoadBalancer: string, TargetGroup: string }) => cloudwatch.MetricProps,\n    props?: cloudwatch.MetricOptions): cloudwatch.Metric {\n    return new cloudwatch.Metric({\n      ...fn({\n        LoadBalancer: this.firstLoadBalancerFullName,\n        TargetGroup: this.targetGroupFullName,\n      }),\n      ...props,\n    }).attachTo(this);\n  }\n}\n\n/**\n * A connectable member of a target group\n */\ninterface ConnectableMember {\n  /**\n   * The connectable member\n   */\n  connectable: ec2.IConnectable;\n\n  /**\n   * The port (range) the member is listening on\n   */\n  portRange: ec2.Port;\n}\n\n/**\n * A Target Group for Application Load Balancers\n */\nexport interface IApplicationTargetGroup extends ITargetGroup {\n  /**\n   * Register a listener that is load balancing to this target group.\n   *\n   * Don't call this directly. It will be called by listeners.\n   */\n  registerListener(listener: IApplicationListener, associatingConstruct?: IConstruct): void;\n\n  /**\n   * Register a connectable as a member of this target group.\n   *\n   * Don't call this directly. It will be called by load balancing targets.\n   */\n  registerConnectable(connectable: ec2.IConnectable, portRange?: ec2.Port): void;\n\n  /**\n   * Add a load balancing target to this target group\n   */\n  addTarget(...targets: IApplicationLoadBalancerTarget[]): void;\n}\n\n/**\n * An imported application target group\n */\nclass ImportedApplicationTargetGroup extends ImportedTargetGroupBase implements IApplicationTargetGroup {\n  public registerListener(_listener: IApplicationListener, _associatingConstruct?: IConstruct) {\n    // Nothing to do, we know nothing of our members\n    Annotations.of(this).addWarning('Cannot register listener on imported target group -- security groups might need to be updated manually');\n  }\n\n  public registerConnectable(_connectable: ec2.IConnectable, _portRange?: ec2.Port | undefined): void {\n    Annotations.of(this).addWarning('Cannot register connectable on imported target group -- security groups might need to be updated manually');\n  }\n\n  public addTarget(...targets: IApplicationLoadBalancerTarget[]) {\n    for (const target of targets) {\n      const result = target.attachToApplicationTargetGroup(this);\n\n      if (result.targetJson !== undefined) {\n        throw new Error('Cannot add a non-self registering target to an imported TargetGroup. Create a new TargetGroup instead.');\n      }\n    }\n  }\n}\n\n/**\n * Interface for constructs that can be targets of an application load balancer\n */\nexport interface IApplicationLoadBalancerTarget {\n  /**\n   * Attach load-balanced target to a TargetGroup\n   *\n   * May return JSON to directly add to the [Targets] list, or return undefined\n   * if the target will register itself with the load balancer.\n   */\n  attachToApplicationTargetGroup(targetGroup: IApplicationTargetGroup): LoadBalancerTargetProps;\n}\n\nconst ALB_HEALTH_CHECK_PROTOCOLS = [Protocol.HTTP, Protocol.HTTPS];\n"],
  "mappings": "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",
  "names": []
}
