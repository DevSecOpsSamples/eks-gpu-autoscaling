{
  "version": 3,
  "sources": ["build-spec.ts"],
  "sourcesContent": ["import { IResolveContext, Lazy, Stack } from '../../core';\nimport * as yaml_cfn from './private/yaml-cfn';\n\n/**\n * BuildSpec for CodeBuild projects\n */\nexport abstract class BuildSpec {\n  public static fromObject(value: { [key: string]: any }): BuildSpec {\n    return new ObjectBuildSpec(value);\n  }\n\n  /**\n   * Create a buildspec from an object that will be rendered as YAML in the resulting CloudFormation template.\n   *\n   * @param value the object containing the buildspec that will be rendered as YAML\n   */\n  public static fromObjectToYaml(value: { [key: string]: any }): BuildSpec {\n    return new YamlBuildSpec(value);\n  }\n\n  /**\n   * Use a file from the source as buildspec\n   *\n   * Use this if you want to use a file different from 'buildspec.yml'`\n   */\n  public static fromSourceFilename(filename: string): BuildSpec {\n    return new FilenameBuildSpec(filename);\n  }\n\n  /**\n   * Whether the buildspec is directly available or deferred until build-time\n   */\n  public abstract readonly isImmediate: boolean;\n\n  protected constructor() {\n  }\n\n  /**\n   * Render the represented BuildSpec\n   */\n  public abstract toBuildSpec(): string;\n}\n\n/**\n * BuildSpec that just returns the input unchanged\n */\nclass FilenameBuildSpec extends BuildSpec {\n  public readonly isImmediate: boolean = false;\n\n  constructor(private readonly filename: string) {\n    super();\n  }\n\n  public toBuildSpec(): string {\n    return this.filename;\n  }\n\n  public toString() {\n    return `<buildspec file: ${this.filename}>`;\n  }\n}\n\n/**\n * BuildSpec that understands about structure\n */\nclass ObjectBuildSpec extends BuildSpec {\n  public readonly isImmediate: boolean = true;\n\n  constructor(public readonly spec: { [key: string]: any }) {\n    super();\n  }\n\n  public toBuildSpec(): string {\n    // We have to pretty-print the buildspec, otherwise\n    // CodeBuild will not recognize it as an inline buildspec.\n    return Lazy.uncachedString({\n      produce: (ctx: IResolveContext) =>\n        Stack.of(ctx.scope).toJsonString(this.spec, 2),\n    });\n  }\n}\n\n/**\n * BuildSpec that exports into YAML format\n */\nclass YamlBuildSpec extends BuildSpec {\n  public readonly isImmediate: boolean = true;\n\n  constructor(public readonly spec: { [key: string]: any }) {\n    super();\n  }\n\n  public toBuildSpec(): string {\n    return yaml_cfn.serialize(this.spec);\n  }\n}\n\n/**\n * Merge two buildspecs into a new BuildSpec by doing a deep merge\n *\n * We decided to disallow merging of artifact specs, which is\n * actually impossible since we can't merge two buildspecs with a\n * single primary output into a buildspec with multiple outputs.\n * In case of multiple outputs they must have identifiers but we won't have that information.\n *\n * In case of test reports we replace the whole object with the RHS (instead of recursively merging)\n*/\nexport function mergeBuildSpecs(lhs: BuildSpec, rhs: BuildSpec): BuildSpec {\n  if (!(lhs instanceof ObjectBuildSpec) || !(rhs instanceof ObjectBuildSpec)) {\n    throw new Error('Can only merge buildspecs created using BuildSpec.fromObject()');\n  }\n\n  if (lhs.spec.version === '0.1') {\n    throw new Error('Cannot extend buildspec at version \"0.1\". Set the version to \"0.2\" or higher instead.');\n  }\n  if (lhs.spec.artifacts && rhs.spec.artifacts) {\n    // We decided to disallow merging of artifact specs, which is\n    // actually impossible since we can't merge two buildspecs with a\n    // single primary output into a buildspec with multiple outputs.\n    // In case of multiple outputs they must have identifiers but we won't have that information.\n    throw new Error('Only one build spec is allowed to specify artifacts.');\n  }\n\n  const lhsSpec = JSON.parse(JSON.stringify(lhs.spec));\n  const rhsSpec = JSON.parse(JSON.stringify(rhs.spec));\n\n  normalizeSpec(lhsSpec);\n  normalizeSpec(rhsSpec);\n\n  const merged = mergeDeep(lhsSpec, rhsSpec);\n\n  // In case of test reports we replace the whole object with the RHS (instead of recursively merging)\n  if (lhsSpec.reports && rhsSpec.reports) {\n    merged.reports = { ...lhsSpec.reports, ...rhsSpec.reports };\n  }\n\n  return new ObjectBuildSpec(merged);\n}\n\n/*\n * Normalizes the build spec\n * The CodeBuild runtime allows fields that are defined as string[] to be strings\n * and interprets them as singleton lists.\n * When merging we need to normalize this to have the correct concat semantics\n */\nfunction normalizeSpec(spec: { [key: string]: any }): void {\n  if (spec.env && typeof spec.env['exported-variables'] === 'string') {\n    spec.env['exported-variables'] = [spec.env['exported-variables']];\n  }\n  for (const key in spec.phases) {\n    if (Object.prototype.hasOwnProperty.call(spec.phases, key)) {\n      normalizeSpecPhase(spec.phases[key]);\n    }\n  }\n  if (spec.reports) {\n    for (const key in spec.reports) {\n      if (Object.prototype.hasOwnProperty.call(spec.reports, key)) {\n        const report = spec.reports[key];\n        if (typeof report.files === 'string') {\n          report.files = [report.files];\n        }\n      }\n    }\n  }\n  if (spec.artifacts) {\n    if (typeof spec.artifacts.files === 'string') {\n      spec.artifacts.files = [spec.artifacts.files];\n    }\n    for (const key in spec.artifacts['secondary-artifacts']) {\n      if (Object.prototype.hasOwnProperty.call(spec.artifacts['secondary-artifacts'], key)) {\n        const secArtifact = spec.artifacts['secondary-artifacts'][key];\n        if (typeof secArtifact.files === 'string') {\n          secArtifact.files = [secArtifact.files];\n        }\n      }\n    }\n  }\n  if (spec.cache && typeof spec.cache.paths === 'string') {\n    spec.cache.paths = [spec.cache.paths];\n  }\n}\n\nfunction normalizeSpecPhase(phase: { [key: string]: any }): void {\n  if (phase.commands && typeof phase.commands === 'string') {\n    phase.commands = [phase.commands];\n  }\n  if (phase.finally && typeof phase.finally === 'string') {\n    phase.finally = [phase.finally];\n  }\n}\n\nfunction mergeDeep(lhs: any, rhs: any): any {\n  if (Array.isArray(lhs) && Array.isArray(rhs)) {\n    return [...lhs, ...rhs];\n  }\n  if (Array.isArray(lhs) || Array.isArray(rhs)) {\n    return rhs;\n  }\n\n  const isObject = (obj: any) => obj && typeof obj === 'object';\n\n  if (isObject(lhs) && isObject(rhs)) {\n    const ret: any = { ...lhs };\n    for (const k of Object.keys(rhs)) {\n      ret[k] = k in lhs ? mergeDeep(lhs[k], rhs[k]) : rhs[k];\n    }\n    return ret;\n  }\n\n  return rhs;\n};"],
  "mappings": "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",
  "names": []
}
