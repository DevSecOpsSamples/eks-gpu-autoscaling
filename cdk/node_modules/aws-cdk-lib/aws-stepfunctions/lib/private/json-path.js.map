{
  "version": 3,
  "sources": ["json-path.ts"],
  "sourcesContent": ["import { captureStackTrace, IResolvable, IResolveContext, Token, Tokenization } from '../../../core';\nimport { IntrinsicParser, IntrinsicExpression } from './intrinstics';\n\nconst JSON_PATH_TOKEN_SYMBOL = Symbol.for('@aws-cdk/aws-stepfunctions.JsonPathToken');\n\nexport class JsonPathToken implements IResolvable {\n  public static isJsonPathToken(x: IResolvable): x is JsonPathToken {\n    return (x as any)[JSON_PATH_TOKEN_SYMBOL] === true;\n  }\n\n  public readonly creationStack: string[];\n  public displayHint: string;\n\n  constructor(public readonly path: string) {\n    this.creationStack = captureStackTrace();\n    this.displayHint = path.replace(/^[^a-zA-Z]+/, '');\n    Object.defineProperty(this, JSON_PATH_TOKEN_SYMBOL, { value: true });\n  }\n\n  public resolve(_ctx: IResolveContext): any {\n    return this.path;\n  }\n\n  public toString() {\n    return Token.asString(this, { displayHint: this.displayHint });\n  }\n\n  public toJSON() {\n    return `<path:${this.path}>`;\n  }\n}\n\n/**\n * Deep render a JSON object to expand JSON path fields, updating the key to end in '.$'\n */\nexport function renderObject(obj: object | undefined): object | undefined {\n  return recurseObject(obj, {\n    handleString: renderString,\n    handleList: renderStringList,\n    handleNumber: renderNumber,\n    handleBoolean: renderBoolean,\n    handleResolvable: renderResolvable,\n  });\n}\n\n/**\n * Return all JSON paths that are used in the given structure\n */\nexport function findReferencedPaths(obj: object | undefined): Set<string> {\n  const found = new Set<string>();\n\n  recurseObject(obj, {\n    handleString(_key: string, x: string) {\n      for (const p of findPathsInIntrinsicFunctions(jsonPathString(x))) {\n        found.add(p);\n      }\n      return {};\n    },\n\n    handleList(_key: string, x: string[]) {\n      for (const p of findPathsInIntrinsicFunctions(jsonPathStringList(x))) {\n        found.add(p);\n      }\n      return {};\n    },\n\n    handleNumber(_key: string, x: number) {\n      for (const p of findPathsInIntrinsicFunctions(jsonPathNumber(x))) {\n        found.add(p);\n      }\n      return {};\n    },\n\n    handleBoolean(_key: string, _x: boolean) {\n      return {};\n    },\n\n    handleResolvable(_key: string, x: IResolvable) {\n      for (const p of findPathsInIntrinsicFunctions(jsonPathFromAny(x))) {\n        found.add(p);\n      }\n      return {};\n    },\n  });\n\n  return found;\n}\n\n/**\n * From an expression, return the list of JSON paths referenced in it\n */\nfunction findPathsInIntrinsicFunctions(expression?: string): string[] {\n  if (!expression) { return []; }\n\n  const ret = new Array<string>();\n\n  try {\n    const parsed = new IntrinsicParser(expression).parseTopLevelIntrinsic();\n    recurse(parsed);\n    return ret;\n  } catch (e) {\n    // Not sure that our parsing is 100% correct. We don't want to break anyone, so\n    // fall back to legacy behavior if we can't parse this string.\n    return [expression];\n  }\n\n  function recurse(p: IntrinsicExpression) {\n    switch (p.type) {\n      case 'path':\n        ret.push(p.path);\n        break;\n\n      case 'fncall':\n        for (const arg of p.arguments) {\n          recurse(arg);\n        }\n    }\n  }\n}\n\ninterface FieldHandlers {\n  handleString(key: string, x: string): {[key: string]: string};\n  handleList(key: string, x: string[]): {[key: string]: string[] | string };\n  handleNumber(key: string, x: number): {[key: string]: number | string};\n  handleBoolean(key: string, x: boolean): {[key: string]: boolean};\n  handleResolvable(key: string, x: IResolvable): {[key: string]: any};\n}\n\nexport function recurseObject(obj: object | undefined, handlers: FieldHandlers, visited: object[] = []): object | undefined {\n  // If the argument received is not actually an object (string, number, boolean, undefined, ...) or null\n  // just return it as is as there's nothing to be rendered. This should only happen in the original call to\n  // recurseObject as any recursive calls to it are checking for typeof value === 'object' && value !== null\n  if (typeof obj !== 'object' || obj === null) {\n    return obj;\n  }\n\n  // Avoiding infinite recursion\n  if (visited.includes(obj)) { return {}; }\n\n  // Marking current object as visited for the current recursion path\n  visited.push(obj);\n\n  const ret: any = {};\n  for (const [key, value] of Object.entries(obj)) {\n    if (typeof value === 'string') {\n      Object.assign(ret, handlers.handleString(key, value));\n    } else if (typeof value === 'number') {\n      Object.assign(ret, handlers.handleNumber(key, value));\n    } else if (Array.isArray(value)) {\n      Object.assign(ret, recurseArray(key, value, handlers, visited));\n    } else if (typeof value === 'boolean') {\n      Object.assign(ret, handlers.handleBoolean(key, value));\n    } else if (value === null || value === undefined) {\n      // Nothing\n    } else if (typeof value === 'object') {\n      if (Tokenization.isResolvable(value)) {\n        Object.assign(ret, handlers.handleResolvable(key, value));\n      } else {\n        ret[key] = recurseObject(value, handlers, visited);\n      }\n    }\n  }\n\n  // Removing from visited after leaving the current recursion path\n  // Allowing it to be visited again if it's not causing a recursion (circular reference)\n  visited.pop();\n\n  return ret;\n}\n\n/**\n * Render an array that may or may not contain a string list token\n */\nfunction recurseArray(key: string, arr: any[], handlers: FieldHandlers, visited: object[] = []): {[key: string]: any[] | string} {\n  if (isStringArray(arr)) {\n    const path = jsonPathStringList(arr);\n    if (path !== undefined) {\n      return handlers.handleList(key, arr);\n    }\n\n    // Fall through to correctly reject encoded strings inside an array.\n    // They cannot be represented because there is no key to append a '.$' to.\n  }\n\n  return {\n    [key]: arr.map(value => {\n      if ((typeof value === 'string' && jsonPathString(value) !== undefined)\n        || (typeof value === 'number' && jsonPathNumber(value) !== undefined)\n        || (isStringArray(value) && jsonPathStringList(value) !== undefined)) {\n        throw new Error('Cannot use JsonPath fields in an array, they must be used in objects');\n      }\n      if (typeof value === 'object' && value !== null) {\n        return recurseObject(value, handlers, visited);\n      }\n      return value;\n    }),\n  };\n}\n\nfunction isStringArray(x: any): x is string[] {\n  return Array.isArray(x) && x.every(el => typeof el === 'string');\n}\n\n/**\n * Render a parameter string\n *\n * If the string value starts with '$.', render it as a path string, otherwise as a direct string.\n */\nfunction renderString(key: string, value: string): {[key: string]: string} {\n  const path = jsonPathString(value);\n  if (path !== undefined) {\n    return { [key + '.$']: path };\n  } else {\n    return { [key]: value };\n  }\n}\n\n/**\n * Render a resolvable\n *\n * If we can extract a Path from it, render as a path string, otherwise as itself (will\n * be resolved later\n */\nfunction renderResolvable(key: string, value: IResolvable): {[key: string]: any} {\n  const path = jsonPathFromAny(value);\n  if (path !== undefined) {\n    return { [key + '.$']: path };\n  } else {\n    return { [key]: value };\n  }\n}\n\n/**\n * Render a parameter string list\n *\n * If the string value starts with '$.', render it as a path string, otherwise as a direct string.\n */\nfunction renderStringList(key: string, value: string[]): {[key: string]: string[] | string} {\n  const path = jsonPathStringList(value);\n  if (path !== undefined) {\n    return { [key + '.$']: path };\n  } else {\n    return { [key]: value };\n  }\n}\n\n/**\n * Render a parameter number\n *\n * If the string value starts with '$.', render it as a path string, otherwise as a direct string.\n */\nfunction renderNumber(key: string, value: number): {[key: string]: number | string} {\n  const path = jsonPathNumber(value);\n  if (path !== undefined) {\n    return { [key + '.$']: path };\n  } else {\n    return { [key]: value };\n  }\n}\n\n/**\n * Render a parameter boolean\n */\nfunction renderBoolean(key: string, value: boolean): {[key: string]: boolean} {\n  return { [key]: value };\n}\n\n/**\n * If the indicated string is an encoded JSON path, return the path\n *\n * Otherwise return undefined.\n */\nexport function jsonPathString(x: string): string | undefined {\n  const fragments = Tokenization.reverseString(x);\n  const jsonPathTokens = fragments.tokens.filter(JsonPathToken.isJsonPathToken);\n\n  if (jsonPathTokens.length > 0 && fragments.length > 1) {\n    throw new Error(`Field references must be the entire string, cannot concatenate them (found '${x}')`);\n  }\n  if (jsonPathTokens.length > 0) {\n    return jsonPathTokens[0].path;\n  }\n  return undefined;\n}\n\nexport function jsonPathFromAny(x: any) {\n  if (!x) { return undefined; }\n  if (typeof x === 'string') { return jsonPathString(x); }\n  return pathFromToken(Tokenization.reverse(x));\n}\n\n/**\n * If the indicated string list is an encoded JSON path, return the path\n *\n * Otherwise return undefined.\n */\nfunction jsonPathStringList(x: string[]): string | undefined {\n  return pathFromToken(Tokenization.reverseList(x));\n}\n\n/**\n * If the indicated number is an encoded JSON path, return the path\n *\n * Otherwise return undefined.\n */\nfunction jsonPathNumber(x: number): string | undefined {\n  return pathFromToken(Tokenization.reverseNumber(x));\n}\n\nfunction pathFromToken(token: IResolvable | undefined) {\n  return token && (JsonPathToken.isJsonPathToken(token) ? token.path : undefined);\n}\n\n/**\n * Render the string in a valid JSON Path expression.\n *\n * If the string is a Tokenized JSON path reference -- return the JSON path reference inside it.\n * Otherwise, single-quote it.\n *\n * Call this function whenever you're building compound JSONPath expressions, in\n * order to avoid having tokens-in-tokens-in-tokens which become very hard to parse.\n */\nexport function renderInExpression(x: string) {\n  const path = jsonPathString(x);\n  return path ?? singleQuotestring(x);\n}\n\nfunction singleQuotestring(x: string) {\n  const ret = new Array<string>();\n  ret.push(\"'\");\n  for (const c of x) {\n    if (c === \"'\") {\n      ret.push(\"\\\\'\");\n    } else if (c === '\\\\') {\n      ret.push('\\\\\\\\');\n    } else if (c === '\\n') {\n      ret.push('\\\\n');\n    } else {\n      ret.push(c);\n    }\n  }\n  ret.push(\"'\");\n  return ret.join('');\n}"],
  "mappings": "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",
  "names": []
}
