{
  "version": 3,
  "sources": ["intrinstics.ts"],
  "sourcesContent": ["export type IntrinsicExpression = StringLiteralExpression | PathExpression | FnCallExpression;\nexport type TopLevelIntrinsic = PathExpression | FnCallExpression;\n\nexport interface StringLiteralExpression {\n  readonly type: 'string-literal';\n  readonly literal: string;\n}\n\nexport interface PathExpression {\n  readonly type: 'path';\n  readonly path: string;\n}\n\nexport interface FnCallExpression {\n  readonly type: 'fncall';\n  readonly functionName: string;\n  readonly arguments: IntrinsicExpression[];\n}\n\n\n/**\n * LL(1) parser for StepFunctions intrinsics\n *\n * The parser implements a state machine over a cursor into an expression\n * string. The cusor gets moved, the character at the cursor gets inspected\n * and based on the character we accumulate some value and potentially move\n * to a different state.\n *\n * Literal strings are not allowed at the top level, but are allowed inside\n * function calls.\n */\nexport class IntrinsicParser {\n  private i: number = 0;\n\n  constructor(private readonly expression: string) {\n  }\n\n  public parseTopLevelIntrinsic(): TopLevelIntrinsic {\n    this.ws();\n\n    let ret;\n    if (this.char() === '$') {\n      ret = this.parsePath();\n    } else if (isAlphaNum(this.char())) {\n      ret = this.parseFnCall();\n    } else {\n      this.raiseError(\"expected '$' or a function call\");\n    }\n\n    this.ws();\n\n    if (!this.eof) {\n      this.raiseError('unexpected trailing characters');\n    }\n\n    return ret;\n  }\n\n  private parseIntrinsic(): IntrinsicExpression {\n    this.ws();\n\n    if (this.char() === '$') {\n      return this.parsePath();\n    }\n\n    if (isAlphaNum(this.char())) {\n      return this.parseFnCall();\n    }\n\n    if (this.char() === \"'\") {\n      return this.parseStringLiteral();\n    }\n\n    this.raiseError('expected $, function or single-quoted string');\n  }\n\n  /**\n   * Simplified path parsing\n   *\n   * JSON path can actually be quite complicated, but we don't need to validate\n   * it precisely. We just need to know how far it extends.\n   *\n   * Therefore, we only care about:\n   *\n   * - Starts with a $\n   * - Accept ., $ and alphanums\n   * - Accept single-quoted strings ('...')\n   * - Accept anything between matched square brackets ([...])\n   */\n  private parsePath(): PathExpression {\n    const pathString = new Array<string>();\n    if (this.char() !== '$') {\n      this.raiseError('expected \\'$\\'');\n    }\n    pathString.push(this.consume());\n\n    let done = false;\n    while (!done && !this.eof) {\n      switch (this.char()) {\n        case '.':\n        case '$':\n          pathString.push(this.consume());\n          break;\n        case \"'\":\n          const { quoted } = this.consumeQuotedString();\n          pathString.push(quoted);\n          break;\n\n        case '[':\n          pathString.push(this.consumeBracketedExpression(']'));\n          break;\n\n        default:\n          if (isAlphaNum(this.char())) {\n            pathString.push(this.consume());\n            break;\n          }\n\n          // Not alphanum, end of path expression\n          done = true;\n      }\n    }\n\n    return { type: 'path', path: pathString.join('') };\n  }\n\n  /**\n   * Parse a fncall\n   *\n   * Cursor should be on call identifier. Afterwards, cursor will be on closing\n   * quote.\n   */\n  private parseFnCall(): FnCallExpression {\n    const name = new Array<string>();\n    while (this.char() !== '(') {\n      name.push(this.consume());\n    }\n\n    this.next(); // Consume the '('\n    this.ws();\n\n    const args = [];\n    while (this.char() !== ')') {\n      args.push(this.parseIntrinsic());\n      this.ws();\n\n      if (this.char() === ',') {\n        this.next();\n        continue;\n      } else if (this.char() === ')') {\n        continue;\n      } else {\n        this.raiseError('expected , or )');\n      }\n    }\n    this.next(); // Consume ')'\n\n    return {\n      type: 'fncall',\n      arguments: args,\n      functionName: name.join(''),\n    };\n  }\n\n  /**\n   * Parse a string literal\n   *\n   * Cursor is expected to be on the first opening quote. Afterwards,\n   * cursor will be after the closing quote.\n   */\n  private parseStringLiteral(): StringLiteralExpression {\n    const { unquoted } = this.consumeQuotedString();\n    return { type: 'string-literal', literal: unquoted };\n  }\n\n  /**\n   * Parse a bracketed expression\n   *\n   * Cursor is expected to be on the opening brace. Afterwards,\n   * the cursor will be after the closing brace.\n   */\n  private consumeBracketedExpression(closingBrace: string): string {\n    const ret = new Array<string>();\n    ret.push(this.consume());\n    while (this.char() !== closingBrace) {\n      if (this.char() === '[') {\n        ret.push(this.consumeBracketedExpression(']'));\n      } else if (this.char() === '{') {\n        ret.push(this.consumeBracketedExpression('}'));\n      } else {\n        ret.push(this.consume());\n      }\n    }\n    ret.push(this.consume());\n    return ret.join('');\n  }\n\n  /**\n   * Parse a string literal\n   *\n   * Cursor is expected to be on the first opening quote. Afterwards,\n   * cursor will be after the closing quote.\n   */\n  private consumeQuotedString(): { readonly quoted: string; unquoted: string } {\n    const quoted = new Array<string>();\n    const unquoted = new Array<string>();\n\n    quoted.push(this.consume());\n    while (this.char() !== \"'\") {\n      if (this.char() === '\\\\') {\n        // Advance and add next character literally, whatever it is\n        quoted.push(this.consume());\n      }\n      quoted.push(this.char());\n      unquoted.push(this.char());\n      this.next();\n    }\n    quoted.push(this.consume());\n    return { quoted: quoted.join(''), unquoted: unquoted.join('') };\n  }\n\n  /**\n   * Consume whitespace if it exists\n   *\n   * Move the cursor to the next non-whitespace character.\n   */\n  private ws() {\n    while (!this.eof && [' ', '\\t', '\\n'].includes(this.char())) {\n      this.next();\n    }\n  }\n\n  private get eof() {\n    return this.i >= this.expression.length;\n  }\n\n  private char(): string {\n    if (this.eof) {\n      this.raiseError('unexpected end of string');\n    }\n\n    return this.expression[this.i];\n  }\n\n  private next() {\n    this.i++;\n  }\n\n  private consume() {\n    const ret = this.char();\n    this.next();\n    return ret;\n  }\n\n  private raiseError(message: string): never {\n    throw new Error(`Invalid JSONPath expression: ${message} at index ${this.i} in ${JSON.stringify(this.expression)}`);\n  }\n}\n\nfunction isAlphaNum(x: string) {\n  return x.match(/^[a-zA-Z0-9]$/);\n}\n"],
  "mappings": "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",
  "names": []
}
