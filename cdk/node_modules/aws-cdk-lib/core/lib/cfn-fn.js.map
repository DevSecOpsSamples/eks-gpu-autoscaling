{
  "version": 3,
  "sources": ["cfn-fn.ts"],
  "sourcesContent": ["import { ICfnConditionExpression, ICfnRuleConditionExpression } from './cfn-condition';\nimport { minimalCloudFormationJoin } from './private/cloudformation-lang';\nimport { Intrinsic } from './private/intrinsic';\nimport { Reference } from './reference';\nimport { IResolvable, IResolveContext } from './resolvable';\nimport { captureStackTrace } from './stack-trace';\nimport { Token } from './token';\n\n/* eslint-disable max-len */\n\n/**\n * CloudFormation intrinsic functions.\n * http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/intrinsic-function-reference.html\n */\nexport class Fn {\n  /**\n   * The ``Ref`` intrinsic function returns the value of the specified parameter or resource.\n   * Note that it doesn't validate the logicalName, it mainly serves paremeter/resource reference defined in a ``CfnInclude`` template.\n   * @param logicalName The logical name of a parameter/resource for which you want to retrieve its value.\n   */\n  public static ref(logicalName: string): string {\n    return new FnRef(logicalName).toString();\n  }\n\n  /**\n   * The ``Fn::GetAtt`` intrinsic function returns the value of an attribute\n   * from a resource in the template.\n   * @param logicalNameOfResource The logical name (also called logical ID) of\n   * the resource that contains the attribute that you want.\n   * @param attributeName The name of the resource-specific attribute whose\n   * value you want. See the resource's reference page for details about the\n   * attributes available for that resource type.\n   * @returns an IResolvable object\n   */\n  public static getAtt(logicalNameOfResource: string, attributeName: string): IResolvable {\n    return new FnGetAtt(logicalNameOfResource, attributeName);\n  }\n\n  /**\n   * The intrinsic function ``Fn::Join`` appends a set of values into a single\n   * value, separated by the specified delimiter. If a delimiter is the empty\n   * string, the set of values are concatenated with no delimiter.\n   * @param delimiter The value you want to occur between fragments. The\n   * delimiter will occur between fragments only. It will not terminate the\n   * final value.\n   * @param listOfValues The list of values you want combined.\n   * @returns a token represented as a string\n   */\n  public static join(delimiter: string, listOfValues: string[]): string {\n    if (listOfValues.length === 0) {\n      throw new Error('FnJoin requires at least one value to be provided');\n    }\n\n    return new FnJoin(delimiter, listOfValues).toString();\n  }\n\n  /**\n   * Split a string token into a token list of string values.\n   *\n   * Specify the location of splits with a delimiter such as ',' (a comma).\n   * Renders to the `Fn::Split` intrinsic function.\n   *\n   * Lists with unknown lengths (default)\n   * -------------------------------------\n   *\n   * Since this function is used to work with deploy-time values, if `assumedLength`\n   * is not given the CDK cannot know the length of the resulting list at synthesis time.\n   * This brings the following restrictions:\n   *\n   * - You must use `Fn.select(i, list)` to pick elements out of the list (you must not use\n   *   `list[i]`).\n   * - You cannot add elements to the list, remove elements from the list,\n   *   combine two such lists together, or take a slice of the list.\n   * - You cannot pass the list to constructs that do any of the above.\n   *\n   * The only valid operation with such a tokenized list is to pass it unmodified to a\n   * CloudFormation Resource construct.\n   *\n   * Lists with assumed lengths\n   * --------------------------\n   *\n   * Pass `assumedLength` if you know the length of the list that will be\n   * produced by splitting. The actual list length at deploy time may be\n   * *longer* than the number you pass, but not *shorter*.\n   *\n   * The returned list will look like:\n   *\n   * ```\n   * [Fn.select(0, split), Fn.select(1, split), Fn.select(2, split), ...]\n   * ```\n   *\n   * The restrictions from the section \"Lists with unknown lengths\" will now be lifted,\n   * at the expense of having to know and fix the length of the list.\n   *\n   * @param delimiter A string value that determines where the source string is divided.\n   * @param source The string value that you want to split.\n   * @param assumedLength The length of the list that will be produced by splitting\n   * @returns a token represented as a string array\n   */\n  public static split(delimiter: string, source: string, assumedLength?: number): string[] {\n    // short-circut if source is not a token\n    if (!Token.isUnresolved(source)) {\n      return source.split(delimiter);\n    }\n\n    if (Token.isUnresolved(delimiter)) {\n      // Limitation of CloudFormation\n      throw new Error('Fn.split: \\'delimiter\\' may not be a token value');\n    }\n\n    const split = Token.asList(new FnSplit(delimiter, source));\n    if (assumedLength === undefined) {\n      return split;\n    }\n\n    if (Token.isUnresolved(assumedLength)) {\n      throw new Error('Fn.split: \\'assumedLength\\' may not be a token value');\n    }\n\n    return range(assumedLength).map(i => Fn.select(i, split));\n  }\n\n  /**\n   * The intrinsic function ``Fn::Select`` returns a single object from a list of objects by index.\n   * @param index The index of the object to retrieve. This must be a value from zero to N-1, where N represents the number of elements in the array.\n   * @param array The list of objects to select from. This list must not be null, nor can it have null entries.\n   * @returns a token represented as a string\n   */\n  public static select(index: number, array: string[]): string {\n    if (!Token.isUnresolved(index) && !Token.isUnresolved(array) && !array.some(Token.isUnresolved)) {\n      return array[index];\n    }\n\n    return new FnSelect(index, array).toString();\n  }\n\n  /**\n   * The intrinsic function ``Fn::Sub`` substitutes variables in an input string\n   * with values that you specify. In your templates, you can use this function\n   * to construct commands or outputs that include values that aren't available\n   * until you create or update a stack.\n   * @param body A string with variables that AWS CloudFormation substitutes\n   * with their associated values at runtime. Write variables as ${MyVarName}.\n   * Variables can be template parameter names, resource logical IDs, resource\n   * attributes, or a variable in a key-value map. If you specify only template\n   * parameter names, resource logical IDs, and resource attributes, don't\n   * specify a key-value map.\n   * @param variables The name of a variable that you included in the String\n   * parameter. The value that AWS CloudFormation substitutes for the associated\n   * variable name at runtime.\n   * @returns a token represented as a string\n   */\n  public static sub(body: string, variables?: { [key: string]: string }): string {\n    return new FnSub(body, variables).toString();\n  }\n\n  /**\n   * The intrinsic function ``Fn::Base64`` returns the Base64 representation of\n   * the input string. This function is typically used to pass encoded data to\n   * Amazon EC2 instances by way of the UserData property.\n   * @param data The string value you want to convert to Base64.\n   * @returns a token represented as a string\n   */\n  public static base64(data: string): string {\n    return new FnBase64(data).toString();\n  }\n\n  /**\n   * The intrinsic function ``Fn::Cidr`` returns the specified Cidr address block.\n   * @param ipBlock  The user-specified default Cidr address block.\n   * @param count  The number of subnets' Cidr block wanted. Count can be 1 to 256.\n   * @param sizeMask The digit covered in the subnet.\n   * @returns a token represented as a string\n   */\n  public static cidr(ipBlock: string, count: number, sizeMask?: string): string[] {\n    return Token.asList(new FnCidr(ipBlock, count, sizeMask));\n  }\n\n  /**\n   * Given an url, parse the domain name\n   * @param url the url to parse\n   */\n  public static parseDomainName(url: string): string {\n    const noHttps = Fn.select(1, Fn.split('//', url));\n    return Fn.select(0, Fn.split('/', noHttps));\n  }\n\n  /**\n   * The intrinsic function ``Fn::GetAZs`` returns an array that lists\n   * Availability Zones for a specified region. Because customers have access to\n   * different Availability Zones, the intrinsic function ``Fn::GetAZs`` enables\n   * template authors to write templates that adapt to the calling user's\n   * access. That way you don't have to hard-code a full list of Availability\n   * Zones for a specified region.\n   * @param region The name of the region for which you want to get the\n   * Availability Zones. You can use the AWS::Region pseudo parameter to specify\n   * the region in which the stack is created. Specifying an empty string is\n   * equivalent to specifying AWS::Region.\n   * @returns a token represented as a string array\n   */\n  public static getAzs(region?: string): string[] {\n    return Token.asList(new FnGetAZs(region));\n  }\n\n  /**\n   * The intrinsic function ``Fn::ImportValue`` returns the value of an output\n   * exported by another stack. You typically use this function to create\n   * cross-stack references. In the following example template snippets, Stack A\n   * exports VPC security group values and Stack B imports them.\n   * @param sharedValueToImport The stack output value that you want to import.\n   * @returns a token represented as a string\n   */\n  public static importValue(sharedValueToImport: string): string {\n    return new FnImportValue(sharedValueToImport).toString();\n  }\n\n  /**\n   * Like `Fn.importValue`, but import a list with a known length\n   *\n   * If you explicitly want a list with an unknown length, call `Fn.split(',',\n   * Fn.importValue(exportName))`. See the documentation of `Fn.split` to read\n   * more about the limitations of using lists of unknown length.\n   *\n   * `Fn.importListValue(exportName, assumedLength)` is the same as\n   * `Fn.split(',', Fn.importValue(exportName), assumedLength)`,\n   * but easier to read and impossible to forget to pass `assumedLength`.\n   */\n  public static importListValue(sharedValueToImport: string, assumedLength: number, delimiter = ','): string[] {\n    return Fn.split(delimiter, Fn.importValue(sharedValueToImport), assumedLength);\n  }\n\n  /**\n   * The intrinsic function ``Fn::FindInMap`` returns the value corresponding to\n   * keys in a two-level map that is declared in the Mappings section.\n   * @returns a token represented as a string\n   */\n  public static findInMap(mapName: string, topLevelKey: string, secondLevelKey: string): string {\n    return Fn._findInMap(mapName, topLevelKey, secondLevelKey).toString();\n  }\n\n  /**\n   * An additional function used in CfnParser,\n   * as Fn::FindInMap does not always return a string.\n   *\n   * @internal\n   */\n  public static _findInMap(mapName: string, topLevelKey: string, secondLevelKey: string): IResolvable {\n    return new FnFindInMap(mapName, topLevelKey, secondLevelKey);\n  }\n\n  /**\n   * Creates a token representing the ``Fn::Transform`` expression\n   * @see https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/intrinsic-function-reference-transform.html\n   * @param macroName The name of the macro to perform the processing\n   * @param parameters The parameters to be passed to the macro\n   * @returns a token representing the transform expression\n   */\n  public static transform(macroName: string, parameters: { [name: string]: any }): IResolvable {\n    return new FnTransform(macroName, parameters);\n  }\n\n  /**\n   * Returns true if all the specified conditions evaluate to true, or returns\n   * false if any one of the conditions evaluates to false. ``Fn::And`` acts as\n   * an AND operator. The minimum number of conditions that you can include is\n   * 1.\n   * @param conditions conditions to AND\n   * @returns an FnCondition token\n   */\n  public static conditionAnd(...conditions: ICfnConditionExpression[]): ICfnRuleConditionExpression {\n    if (conditions.length === 0) {\n      throw new Error('Fn.conditionAnd() needs at least one argument');\n    }\n    if (conditions.length === 1) {\n      return conditions[0] as ICfnRuleConditionExpression;\n    }\n    return Fn.conditionAnd(..._inGroupsOf(conditions, 10).map(group => new FnAnd(...group)));\n  }\n\n  /**\n   * Compares if two values are equal. Returns true if the two values are equal\n   * or false if they aren't.\n   * @param lhs A value of any type that you want to compare.\n   * @param rhs A value of any type that you want to compare.\n   * @returns an FnCondition token\n   */\n  public static conditionEquals(lhs: any, rhs: any): ICfnRuleConditionExpression {\n    return new FnEquals(lhs, rhs);\n  }\n\n  /**\n   * Returns one value if the specified condition evaluates to true and another\n   * value if the specified condition evaluates to false. Currently, AWS\n   * CloudFormation supports the ``Fn::If`` intrinsic function in the metadata\n   * attribute, update policy attribute, and property values in the Resources\n   * section and Outputs sections of a template. You can use the AWS::NoValue\n   * pseudo parameter as a return value to remove the corresponding property.\n   * @param conditionId A reference to a condition in the Conditions section. Use\n   * the condition's name to reference it.\n   * @param valueIfTrue A value to be returned if the specified condition\n   * evaluates to true.\n   * @param valueIfFalse A value to be returned if the specified condition\n   * evaluates to false.\n   * @returns an FnCondition token\n   */\n  public static conditionIf(conditionId: string, valueIfTrue: any, valueIfFalse: any): ICfnRuleConditionExpression {\n    return new FnIf(conditionId, valueIfTrue, valueIfFalse);\n  }\n\n  /**\n   * Returns true for a condition that evaluates to false or returns false for a\n   * condition that evaluates to true. ``Fn::Not`` acts as a NOT operator.\n   * @param condition A condition such as ``Fn::Equals`` that evaluates to true\n   * or false.\n   * @returns an FnCondition token\n   */\n  public static conditionNot(condition: ICfnConditionExpression): ICfnRuleConditionExpression {\n    return new FnNot(condition);\n  }\n\n  /**\n   * Returns true if any one of the specified conditions evaluate to true, or\n   * returns false if all of the conditions evaluates to false. ``Fn::Or`` acts\n   * as an OR operator. The minimum number of conditions that you can include is\n   * 1.\n   * @param conditions conditions that evaluates to true or false.\n   * @returns an FnCondition token\n   */\n  public static conditionOr(...conditions: ICfnConditionExpression[]): ICfnRuleConditionExpression {\n    if (conditions.length === 0) {\n      throw new Error('Fn.conditionOr() needs at least one argument');\n    }\n    if (conditions.length === 1) {\n      return conditions[0] as ICfnRuleConditionExpression;\n    }\n    return Fn.conditionOr(..._inGroupsOf(conditions, 10).map(group => new FnOr(...group)));\n  }\n\n  /**\n   * Returns true if a specified string matches at least one value in a list of\n   * strings.\n   * @param listOfStrings A list of strings, such as \"A\", \"B\", \"C\".\n   * @param value A string, such as \"A\", that you want to compare against a list of strings.\n   * @returns an FnCondition token\n   */\n  public static conditionContains(listOfStrings: string[], value: string): ICfnRuleConditionExpression {\n    return new FnContains(listOfStrings, value);\n  }\n\n  /**\n   * Returns true if a specified string matches all values in a list.\n   * @param listOfStrings A list of strings, such as \"A\", \"B\", \"C\".\n   * @param value A string, such as \"A\", that you want to compare against a list\n   * of strings.\n   * @returns an FnCondition token\n   */\n  public static conditionEachMemberEquals(listOfStrings: string[], value: string): ICfnRuleConditionExpression {\n    return new FnEachMemberEquals(listOfStrings, value);\n  }\n\n  /**\n   * Returns true if each member in a list of strings matches at least one value\n   * in a second list of strings.\n   * @param stringsToCheck A list of strings, such as \"A\", \"B\", \"C\". AWS\n   * CloudFormation checks whether each member in the strings_to_check parameter\n   * is in the strings_to_match parameter.\n   * @param stringsToMatch A list of strings, such as \"A\", \"B\", \"C\". Each member\n   * in the strings_to_match parameter is compared against the members of the\n   * strings_to_check parameter.\n   * @returns an FnCondition token\n   */\n  public static conditionEachMemberIn(stringsToCheck: string[], stringsToMatch: string[]): ICfnRuleConditionExpression {\n    return new FnEachMemberIn(stringsToCheck, stringsToMatch);\n  }\n\n  /**\n   * Returns all values for a specified parameter type.\n   * @param parameterType An AWS-specific parameter type, such as\n   * AWS::EC2::SecurityGroup::Id or AWS::EC2::VPC::Id. For more information, see\n   * Parameters in the AWS CloudFormation User Guide.\n   * @returns a token represented as a string array\n   */\n  public static refAll(parameterType: string): string[] {\n    return Token.asList(new FnRefAll(parameterType));\n  }\n\n  /**\n   * Returns an attribute value or list of values for a specific parameter and\n   * attribute.\n   * @param parameterOrLogicalId The name of a parameter for which you want to\n   * retrieve attribute values. The parameter must be declared in the Parameters\n   * section of the template.\n   * @param attribute The name of an attribute from which you want to retrieve a\n   * value.\n   * @returns a token represented as a string\n   */\n  public static valueOf(parameterOrLogicalId: string, attribute: string): string {\n    return new FnValueOf(parameterOrLogicalId, attribute).toString();\n  }\n\n  /**\n   * Returns a list of all attribute values for a given parameter type and\n   * attribute.\n   * @param parameterType An AWS-specific parameter type, such as\n   * AWS::EC2::SecurityGroup::Id or AWS::EC2::VPC::Id. For more information, see\n   * Parameters in the AWS CloudFormation User Guide.\n   * @param attribute The name of an attribute from which you want to retrieve a\n   * value. For more information about attributes, see Supported Attributes.\n   * @returns a token represented as a string array\n   */\n  public static valueOfAll(parameterType: string, attribute: string): string[] {\n    return Token.asList(new FnValueOfAll(parameterType, attribute));\n  }\n\n  private constructor() { }\n}\n\n/**\n * Base class for tokens that represent CloudFormation intrinsic functions.\n */\nclass FnBase extends Intrinsic {\n  constructor(name: string, value: any) {\n    super({ [name]: value });\n  }\n}\n\n/**\n * The intrinsic function ``Ref`` returns the value of the specified parameter or resource.\n * When you specify a parameter's logical name, it returns the value of the parameter.\n * When you specify a resource's logical name, it returns a value that you can typically use to refer to that resource, such as a physical ID.\n */\nclass FnRef extends FnBase {\n  /**\n   * Creates an ``Ref`` function.\n   * @param logicalName The logical name of a parameter/resource for which you want to retrieve its value.\n   */\n  constructor(logicalName: string) {\n    super('Ref', logicalName);\n  }\n}\n\n/**\n * The intrinsic function ``Fn::FindInMap`` returns the value corresponding to keys in a two-level\n * map that is declared in the Mappings section.\n */\nclass FnFindInMap extends FnBase {\n  /**\n   * Creates an ``Fn::FindInMap`` function.\n   * @param mapName The logical name of a mapping declared in the Mappings section that contains the keys and values.\n   * @param topLevelKey The top-level key name. Its value is a list of key-value pairs.\n   * @param secondLevelKey The second-level key name, which is set to one of the keys from the list assigned to TopLevelKey.\n   */\n  constructor(mapName: string, topLevelKey: any, secondLevelKey: any) {\n    super('Fn::FindInMap', [mapName, topLevelKey, secondLevelKey]);\n  }\n}\n\n/**\n * The intrinsic function ``Fn::Transform`` specifies a macro to perform custom processing on part of a stack template.\n */\nclass FnTransform extends FnBase {\n  /**\n   * creates an ``Fn::Transform`` function.\n   * @param macroName The name of the macro to be invoked\n   * @param parameters the parameters to pass to it\n   */\n  constructor(macroName: string, parameters: { [name: string]: any }) {\n    super('Fn::Transform', { Name: macroName, Parameters: parameters });\n  }\n}\n\n/**\n * The ``Fn::GetAtt`` intrinsic function returns the value of an attribute from a resource in the template.\n */\nclass FnGetAtt extends FnBase {\n  /**\n   * Creates a ``Fn::GetAtt`` function.\n   * @param logicalNameOfResource The logical name (also called logical ID) of the resource that contains the attribute that you want.\n   * @param attributeName The name of the resource-specific attribute whose value you want. See the resource's reference page for details about the attributes available for that resource type.\n   */\n  constructor(logicalNameOfResource: string, attributeName: string) {\n    super('Fn::GetAtt', [logicalNameOfResource, attributeName]);\n  }\n}\n\n/**\n * The intrinsic function ``Fn::GetAZs`` returns an array that lists Availability Zones for a\n * specified region. Because customers have access to different Availability Zones, the intrinsic\n * function ``Fn::GetAZs`` enables template authors to write templates that adapt to the calling\n * user's access. That way you don't have to hard-code a full list of Availability Zones for a\n * specified region.\n */\nclass FnGetAZs extends FnBase {\n  /**\n   * Creates an ``Fn::GetAZs`` function.\n   * @param region The name of the region for which you want to get the Availability Zones.\n   *         You can use the AWS::Region pseudo parameter to specify the region in\n   *         which the stack is created. Specifying an empty string is equivalent to\n   *         specifying AWS::Region.\n   */\n  constructor(region?: string) {\n    super('Fn::GetAZs', region || '');\n  }\n}\n\n/**\n * The intrinsic function ``Fn::ImportValue`` returns the value of an output exported by another stack.\n * You typically use this function to create cross-stack references. In the following example\n * template snippets, Stack A exports VPC security group values and Stack B imports them.\n */\nclass FnImportValue extends FnBase {\n  /**\n   * Creates an ``Fn::ImportValue`` function.\n   * @param sharedValueToImport The stack output value that you want to import.\n   */\n  constructor(sharedValueToImport: string) {\n    super('Fn::ImportValue', sharedValueToImport);\n  }\n}\n\n/**\n * The intrinsic function ``Fn::Select`` returns a single object from a list of objects by index.\n */\nclass FnSelect extends FnBase {\n  /**\n   * Creates an ``Fn::Select`` function.\n   * @param index The index of the object to retrieve. This must be a value from zero to N-1, where N represents the number of elements in the array.\n   * @param array The list of objects to select from. This list must not be null, nor can it have null entries.\n   */\n  constructor(index: number, array: any) {\n    super('Fn::Select', [index, array]);\n  }\n}\n\n/**\n * To split a string into a list of string values so that you can select an element from the\n * resulting string list, use the ``Fn::Split`` intrinsic function. Specify the location of splits\n * with a delimiter, such as , (a comma). After you split a string, use the ``Fn::Select`` function\n * to pick a specific element.\n */\nclass FnSplit extends FnBase {\n  /**\n   * Create an ``Fn::Split`` function.\n   * @param delimiter A string value that determines where the source string is divided.\n   * @param source The string value that you want to split.\n   */\n  constructor(delimiter: string, source: any) {\n    super('Fn::Split', [delimiter, source]);\n  }\n}\n\n/**\n * The intrinsic function ``Fn::Sub`` substitutes variables in an input string with values that\n * you specify. In your templates, you can use this function to construct commands or outputs\n * that include values that aren't available until you create or update a stack.\n */\nclass FnSub extends FnBase {\n  /**\n   * Creates an ``Fn::Sub`` function.\n   * @param body A string with variables that AWS CloudFormation substitutes with their\n   *       associated values at runtime. Write variables as ${MyVarName}. Variables\n   *       can be template parameter names, resource logical IDs, resource attributes,\n   *       or a variable in a key-value map. If you specify only template parameter names,\n   *       resource logical IDs, and resource attributes, don't specify a key-value map.\n   * @param variables The name of a variable that you included in the String parameter.\n   *          The value that AWS CloudFormation substitutes for the associated variable name at runtime.\n   */\n  constructor(body: string, variables?: { [key: string]: any }) {\n    super('Fn::Sub', variables ? [body, variables] : body);\n  }\n}\n\n/**\n * The intrinsic function ``Fn::Base64`` returns the Base64 representation of the input string.\n * This function is typically used to pass encoded data to Amazon EC2 instances by way of\n * the UserData property.\n */\nclass FnBase64 extends FnBase {\n\n  /**\n   * Creates an ``Fn::Base64`` function.\n   * @param data The string value you want to convert to Base64.\n   */\n  constructor(data: any) {\n    super('Fn::Base64', data);\n  }\n}\n\n/**\n * The intrinsic function ``Fn::Cidr`` returns the specified Cidr address block.\n */\nclass FnCidr extends FnBase {\n  /**\n   * Creates an ``Fn::Cidr`` function.\n   * @param ipBlock  The user-specified default Cidr address block.\n   * @param count  The number of subnets' Cidr block wanted. Count can be 1 to 256.\n   * @param sizeMask The digit covered in the subnet.\n   */\n  constructor(ipBlock: any, count: any, sizeMask?: any) {\n    if (count < 1 || count > 256) {\n      throw new Error(`Fn::Cidr's count attribute must be betwen 1 and 256, ${count} was provided.`);\n    }\n    super('Fn::Cidr', [ipBlock, count, sizeMask]);\n  }\n}\n\nclass FnConditionBase extends Intrinsic implements ICfnRuleConditionExpression {\n  readonly disambiguator = true;\n  constructor(type: string, value: any) {\n    super({ [type]: value });\n  }\n}\n\n/**\n * Returns true if all the specified conditions evaluate to true, or returns false if any one\n *  of the conditions evaluates to false. ``Fn::And`` acts as an AND operator. The minimum number of\n * conditions that you can include is 2, and the maximum is 10.\n */\nclass FnAnd extends FnConditionBase {\n  constructor(...condition: ICfnConditionExpression[]) {\n    super('Fn::And', condition);\n  }\n}\n\n/**\n * Compares if two values are equal. Returns true if the two values are equal or false\n * if they aren't.\n */\nclass FnEquals extends FnConditionBase {\n  /**\n   * Creates an ``Fn::Equals`` condition function.\n   * @param lhs A value of any type that you want to compare.\n   * @param rhs A value of any type that you want to compare.\n   */\n  constructor(lhs: any, rhs: any) {\n    super('Fn::Equals', [lhs, rhs]);\n  }\n}\n\n/**\n * Returns one value if the specified condition evaluates to true and another value if the\n * specified condition evaluates to false. Currently, AWS CloudFormation supports the ``Fn::If``\n * intrinsic function in the metadata attribute, update policy attribute, and property values\n * in the Resources section and Outputs sections of a template. You can use the AWS::NoValue\n * pseudo parameter as a return value to remove the corresponding property.\n */\nclass FnIf extends FnConditionBase {\n  /**\n   * Creates an ``Fn::If`` condition function.\n   * @param condition A reference to a condition in the Conditions section. Use the condition's name to reference it.\n   * @param valueIfTrue A value to be returned if the specified condition evaluates to true.\n   * @param valueIfFalse A value to be returned if the specified condition evaluates to false.\n   */\n  constructor(condition: string, valueIfTrue: any, valueIfFalse: any) {\n    super('Fn::If', [condition, valueIfTrue, valueIfFalse]);\n  }\n}\n\n/**\n * Returns true for a condition that evaluates to false or returns false for a condition that evaluates to true.\n * ``Fn::Not`` acts as a NOT operator.\n */\nclass FnNot extends FnConditionBase {\n  /**\n   * Creates an ``Fn::Not`` condition function.\n   * @param condition A condition such as ``Fn::Equals`` that evaluates to true or false.\n   */\n  constructor(condition: ICfnConditionExpression) {\n    super('Fn::Not', [condition]);\n  }\n}\n\n/**\n * Returns true if any one of the specified conditions evaluate to true, or returns false if\n * all of the conditions evaluates to false. ``Fn::Or`` acts as an OR operator. The minimum number\n * of conditions that you can include is 2, and the maximum is 10.\n */\nclass FnOr extends FnConditionBase {\n  /**\n   * Creates an ``Fn::Or`` condition function.\n   * @param condition A condition that evaluates to true or false.\n   */\n  constructor(...condition: ICfnConditionExpression[]) {\n    super('Fn::Or', condition);\n  }\n}\n\n/**\n * Returns true if a specified string matches at least one value in a list of strings.\n */\nclass FnContains extends FnConditionBase {\n  /**\n   * Creates an ``Fn::Contains`` function.\n   * @param listOfStrings A list of strings, such as \"A\", \"B\", \"C\".\n   * @param value A string, such as \"A\", that you want to compare against a list of strings.\n   */\n  constructor(listOfStrings: any, value: string) {\n    super('Fn::Contains', [listOfStrings, value]);\n  }\n}\n\n/**\n * Returns true if a specified string matches all values in a list.\n */\nclass FnEachMemberEquals extends FnConditionBase {\n  /**\n   * Creates an ``Fn::EachMemberEquals`` function.\n   * @param listOfStrings A list of strings, such as \"A\", \"B\", \"C\".\n   * @param value A string, such as \"A\", that you want to compare against a list of strings.\n   */\n  constructor(listOfStrings: any, value: string) {\n    super('Fn::EachMemberEquals', [listOfStrings, value]);\n  }\n}\n\n/**\n * Returns true if each member in a list of strings matches at least one value in a second\n * list of strings.\n */\nclass FnEachMemberIn extends FnConditionBase {\n  /**\n   * Creates an ``Fn::EachMemberIn`` function.\n   * @param stringsToCheck A list of strings, such as \"A\", \"B\", \"C\". AWS CloudFormation checks whether each member in the strings_to_check parameter is in the strings_to_match parameter.\n   * @param stringsToMatch A list of strings, such as \"A\", \"B\", \"C\". Each member in the strings_to_match parameter is compared against the members of the strings_to_check parameter.\n   */\n  constructor(stringsToCheck: string[], stringsToMatch: string[]) {\n    super('Fn::EachMemberIn', [stringsToCheck, stringsToMatch]);\n  }\n}\n\n/**\n * Returns all values for a specified parameter type.\n */\nclass FnRefAll extends FnBase {\n  /**\n   * Creates an ``Fn::RefAll`` function.\n   * @param parameterType An AWS-specific parameter type, such as AWS::EC2::SecurityGroup::Id or\n   *            AWS::EC2::VPC::Id. For more information, see Parameters in the AWS\n   *            CloudFormation User Guide.\n   */\n  constructor(parameterType: string) {\n    super('Fn::RefAll', parameterType);\n  }\n}\n\n/**\n * Returns an attribute value or list of values for a specific parameter and attribute.\n */\nclass FnValueOf extends FnBase {\n  /**\n   * Creates an ``Fn::ValueOf`` function.\n   * @param parameterOrLogicalId The name of a parameter for which you want to retrieve attribute values. The parameter must be declared in the Parameters section of the template.\n   * @param attribute The name of an attribute from which you want to retrieve a value.\n   */\n  constructor(parameterOrLogicalId: string, attribute: string) {\n    super('Fn::ValueOf', [parameterOrLogicalId, attribute]);\n  }\n}\n\n/**\n * Returns a list of all attribute values for a given parameter type and attribute.\n */\nclass FnValueOfAll extends FnBase {\n  /**\n   * Creates an ``Fn::ValueOfAll`` function.\n   * @param parameterType An AWS-specific parameter type, such as AWS::EC2::SecurityGroup::Id or AWS::EC2::VPC::Id. For more information, see Parameters in the AWS CloudFormation User Guide.\n   * @param attribute The name of an attribute from which you want to retrieve a value. For more information about attributes, see Supported Attributes.\n   */\n  constructor(parameterType: string, attribute: string) {\n    super('Fn::ValueOfAll', [parameterType, attribute]);\n  }\n}\n\n/**\n * The intrinsic function ``Fn::Join`` appends a set of values into a single value, separated by\n * the specified delimiter. If a delimiter is the empty string, the set of values are concatenated\n * with no delimiter.\n */\nclass FnJoin implements IResolvable {\n  public readonly creationStack: string[];\n\n  private readonly delimiter: string;\n  private readonly listOfValues: any[];\n\n  /**\n   * Creates an ``Fn::Join`` function.\n   * @param delimiter The value you want to occur between fragments. The delimiter will occur between fragments only.\n   *          It will not terminate the final value.\n   * @param listOfValues The list of values you want combined.\n   */\n  constructor(delimiter: string, listOfValues: any[]) {\n    if (listOfValues.length === 0) {\n      throw new Error('FnJoin requires at least one value to be provided');\n    }\n\n    this.delimiter = delimiter;\n    this.listOfValues = listOfValues;\n    this.creationStack = captureStackTrace();\n  }\n\n  public resolve(context: IResolveContext): any {\n    if (Token.isUnresolved(this.listOfValues)) {\n      // This is a list token, don't try to do smart things with it.\n      return { 'Fn::Join': [this.delimiter, this.listOfValues] };\n    }\n    const resolved = this.resolveValues(context);\n    if (resolved.length === 1) {\n      return resolved[0];\n    }\n    return { 'Fn::Join': [this.delimiter, resolved] };\n  }\n\n  public toString() {\n    return Token.asString(this, { displayHint: 'Fn::Join' });\n  }\n\n  public toJSON() {\n    return '<Fn::Join>';\n  }\n\n  /**\n   * Optimization: if an Fn::Join is nested in another one and they share the same delimiter, then flatten it up. Also,\n   * if two concatenated elements are literal strings (not tokens), then pre-concatenate them with the delimiter, to\n   * generate shorter output.\n   */\n  private resolveValues(context: IResolveContext) {\n    const resolvedValues = this.listOfValues.map(x => Reference.isReference(x) ? x : context.resolve(x));\n    return minimalCloudFormationJoin(this.delimiter, resolvedValues);\n  }\n}\n\nfunction _inGroupsOf<T>(array: T[], maxGroup: number): T[][] {\n  const result = new Array<T[]>();\n  for (let i = 0; i < array.length; i += maxGroup) {\n    result.push(array.slice(i, i + maxGroup));\n  }\n  return result;\n}\n\nfunction range(n: number): number[] {\n  const ret = [];\n  for (let i = 0; i < n; i++) {\n    ret.push(i);\n  }\n  return ret;\n}"],
  "mappings": "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",
  "names": []
}
