{
  "version": 3,
  "sources": ["string-fragments.ts"],
  "sourcesContent": ["import { IFragmentConcatenator, IResolvable } from './resolvable';\nimport { isResolvableObject, Token } from './token';\n\n/**\n * Result of the split of a string with Tokens\n *\n * Either a literal part of the string, or an unresolved Token.\n */\ntype LiteralFragment = { type: 'literal'; lit: any; };\ntype TokenFragment = { type: 'token'; token: IResolvable; };\ntype IntrinsicFragment = { type: 'intrinsic'; value: any; };\ntype Fragment = LiteralFragment | TokenFragment | IntrinsicFragment;\n\n/**\n * Fragments of a concatenated string containing stringified Tokens\n */\nexport class TokenizedStringFragments {\n  private readonly fragments = new Array<Fragment>();\n\n  public get firstToken(): IResolvable | undefined {\n    const first = this.fragments[0];\n    if (first.type === 'token') { return first.token; }\n    return undefined;\n  }\n\n  public get firstValue(): any {\n    return fragmentValue(this.fragments[0]);\n  }\n\n  public get length() {\n    return this.fragments.length;\n  }\n\n  public addLiteral(lit: any) {\n    this.fragments.push({ type: 'literal', lit });\n  }\n\n  public addToken(token: IResolvable) {\n    this.fragments.push({ type: 'token', token });\n  }\n\n  public addIntrinsic(value: any) {\n    this.fragments.push({ type: 'intrinsic', value });\n  }\n\n  /**\n   * Return all Tokens from this string\n   */\n  public get tokens(): IResolvable[] {\n    const ret = new Array<IResolvable>();\n    for (const f of this.fragments) {\n      if (f.type === 'token') {\n        ret.push(f.token);\n      }\n    }\n    return ret;\n  }\n\n  /**\n   * Apply a transformation function to all tokens in the string\n   */\n  public mapTokens(mapper: ITokenMapper): TokenizedStringFragments {\n    const ret = new TokenizedStringFragments();\n\n    for (const f of this.fragments) {\n      switch (f.type) {\n        case 'literal':\n          ret.addLiteral(f.lit);\n          break;\n        case 'token':\n          const mapped = mapper.mapToken(f.token);\n          if (isResolvableObject(mapped)) {\n            ret.addToken(mapped);\n          } else if (Token.isUnresolved(mapped)) {\n            ret.addIntrinsic(mapped);\n          } else {\n            ret.addLiteral(mapped);\n          }\n          break;\n        case 'intrinsic':\n          ret.addIntrinsic(f.value);\n          break;\n      }\n    }\n\n    return ret;\n  }\n\n  /**\n   * Combine the string fragments using the given joiner.\n   *\n   * If there are any\n   */\n  public join(concat: IFragmentConcatenator): any {\n    if (this.fragments.length === 0) { return concat.join(undefined, undefined); }\n    if (this.fragments.length === 1) { return this.firstValue; }\n\n    const values = this.fragments.map(fragmentValue);\n\n    while (values.length > 1) {\n      const prefix = values.splice(0, 2);\n      values.splice(0, 0, concat.join(prefix[0], prefix[1]));\n    }\n\n    return values[0];\n  }\n}\n\n/**\n * Interface to apply operation to tokens in a string\n *\n * Interface so it can be exported via jsii.\n */\nexport interface ITokenMapper {\n  /**\n   * Replace a single token\n   */\n  mapToken(t: IResolvable): any;\n}\n\n/**\n * Resolve the value from a single fragment\n *\n * If the fragment is a Token, return the string encoding of the Token.\n */\nfunction fragmentValue(fragment: Fragment): any {\n  switch (fragment.type) {\n    case 'literal': return fragment.lit;\n    case 'token': return fragment.token.toString();\n    case 'intrinsic': return fragment.value;\n  }\n}\n"],
  "mappings": "+NACA,QAAA,QAAA,SAAA,EAeA,MAAa,wBAAwB,CAArC,aAAA,CACmB,KAAA,UAAY,GAAI,UAEtB,aAAU,CACnB,KAAM,OAAQ,KAAK,UAAU,GAC7B,GAAI,MAAM,OAAS,QAAW,MAAO,OAAM,SAIlC,aAAU,CACnB,MAAO,eAAc,KAAK,UAAU,EAAE,KAG7B,SAAM,CACf,MAAO,MAAK,UAAU,OAGjB,WAAW,IAAQ,CACxB,KAAK,UAAU,KAAK,CAAE,KAAM,UAAW,GAAG,CAAE,EAGvC,SAAS,MAAkB,wDAChC,KAAK,UAAU,KAAK,CAAE,KAAM,QAAS,KAAK,CAAE,EAGvC,aAAa,MAAU,CAC5B,KAAK,UAAU,KAAK,CAAE,KAAM,YAAa,KAAK,CAAE,KAMvC,SAAM,CACf,KAAM,KAAM,GAAI,OAChB,SAAW,KAAK,MAAK,UACnB,AAAI,EAAE,OAAS,SACb,IAAI,KAAK,EAAE,KAAK,EAGpB,MAAO,KAMF,UAAU,OAAoB,0DACnC,KAAM,KAAM,GAAI,0BAEhB,SAAW,KAAK,MAAK,UACnB,OAAQ,EAAE,UACH,UACH,IAAI,WAAW,EAAE,GAAG,EACpB,UACG,QACH,KAAM,QAAS,OAAO,SAAS,EAAE,KAAK,EACtC,AAAI,QAAA,mBAAmB,MAAM,EAC3B,IAAI,SAAS,MAAM,EACd,AAAI,QAAA,MAAM,aAAa,MAAM,EAClC,IAAI,aAAa,MAAM,EAEvB,IAAI,WAAW,MAAM,EAEvB,UACG,YACH,IAAI,aAAa,EAAE,KAAK,EACxB,MAIN,MAAO,KAQF,KAAK,OAA6B,CACvC,qEAAI,KAAK,UAAU,SAAW,EAAK,MAAO,QAAO,KAAK,OAAW,MAAS,EAC1E,GAAI,KAAK,UAAU,SAAW,EAAK,MAAO,MAAK,WAE/C,KAAM,QAAS,KAAK,UAAU,IAAI,aAAa,EAE/C,KAAO,OAAO,OAAS,GAAG,CACxB,KAAM,QAAS,OAAO,OAAO,EAAG,CAAC,EACjC,OAAO,OAAO,EAAG,EAAG,OAAO,KAAK,OAAO,GAAI,OAAO,EAAE,CAAC,EAGvD,MAAO,QAAO,IAxFlB,QAAA,yBAAA,0IA6GA,uBAAuB,SAAkB,CACvC,OAAQ,SAAS,UACV,UAAW,MAAO,UAAS,QAC3B,QAAS,MAAO,UAAS,MAAM,SAAQ,MACvC,YAAa,MAAO,UAAS,MAEtC",
  "names": []
}
