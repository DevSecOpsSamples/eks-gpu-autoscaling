{
  "version": 3,
  "sources": ["fingerprint.ts"],
  "sourcesContent": ["import * as crypto from 'crypto';\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport { IgnoreStrategy } from './ignore';\nimport { FingerprintOptions, IgnoreMode, SymlinkFollowMode } from './options';\nimport { shouldFollow } from './utils';\n\nconst BUFFER_SIZE = 8 * 1024;\nconst CTRL_SOH = '\\x01';\nconst CTRL_SOT = '\\x02';\nconst CTRL_ETX = '\\x03';\nconst CR = '\\r';\nconst LF = '\\n';\nconst CRLF = `${CR}${LF}`;\n\n/**\n * Produces fingerprint based on the contents of a single file or an entire directory tree.\n *\n * Line endings are converted from CRLF to LF.\n *\n * The fingerprint will also include:\n * 1. An extra string if defined in `options.extra`.\n * 2. The symlink follow mode value.\n *\n * @param fileOrDirectory The directory or file to fingerprint\n * @param options Fingerprinting options\n */\nexport function fingerprint(fileOrDirectory: string, options: FingerprintOptions = { }) {\n  const hash = crypto.createHash('sha256');\n  _hashField(hash, 'options.extra', options.extraHash || '');\n  const follow = options.follow || SymlinkFollowMode.EXTERNAL;\n  _hashField(hash, 'options.follow', follow);\n\n  // Resolve symlinks in the initial path (for example, the root directory\n  // might be symlinked). It's important that we know the absolute path, so we\n  // can judge if further symlinks inside the target directory are within the\n  // target or not (if we don't resolve, we would test w.r.t. the wrong path).\n  fileOrDirectory = fs.realpathSync(fileOrDirectory);\n\n  const isDir = fs.statSync(fileOrDirectory).isDirectory();\n  const rootDirectory = isDir\n    ? fileOrDirectory\n    : path.dirname(fileOrDirectory);\n\n  const ignoreMode = options.ignoreMode || IgnoreMode.GLOB;\n  if (ignoreMode != IgnoreMode.GLOB) {\n    _hashField(hash, 'options.ignoreMode', ignoreMode);\n  }\n\n  const ignoreStrategy = IgnoreStrategy.fromCopyOptions(options, fileOrDirectory);\n  _processFileOrDirectory(fileOrDirectory, isDir);\n\n  return hash.digest('hex');\n\n  function _processFileOrDirectory(symbolicPath: string, isRootDir: boolean = false, realPath = symbolicPath) {\n    if (!isRootDir && ignoreStrategy.ignores(symbolicPath)) {\n      return;\n    }\n\n    const stat = fs.lstatSync(realPath);\n\n    // Use relative path as hash component. Normalize it with forward slashes to ensure\n    // same hash on Windows and Linux.\n    const hashComponent = path.relative(fileOrDirectory, symbolicPath).replace(/\\\\/g, '/');\n\n    if (stat.isSymbolicLink()) {\n      const linkTarget = fs.readlinkSync(realPath);\n      const resolvedLinkTarget = path.resolve(path.dirname(realPath), linkTarget);\n      if (shouldFollow(follow, rootDirectory, resolvedLinkTarget)) {\n        _processFileOrDirectory(symbolicPath, false, resolvedLinkTarget);\n      } else {\n        _hashField(hash, `link:${hashComponent}`, linkTarget);\n      }\n    } else if (stat.isFile()) {\n      _hashField(hash, `file:${hashComponent}`, contentFingerprint(realPath));\n    } else if (stat.isDirectory()) {\n      for (const item of fs.readdirSync(realPath).sort()) {\n        _processFileOrDirectory(path.join(symbolicPath, item), false, path.join(realPath, item));\n      }\n    } else {\n      throw new Error(`Unable to hash ${symbolicPath}: it is neither a file nor a directory`);\n    }\n  }\n}\n\nexport function contentFingerprint(file: string): string {\n  const hash = crypto.createHash('sha256');\n  const buffer = Buffer.alloc(BUFFER_SIZE);\n  // eslint-disable-next-line no-bitwise\n  const fd = fs.openSync(file, fs.constants.O_DSYNC | fs.constants.O_RDONLY | fs.constants.O_SYNC);\n  let size = 0;\n  let isBinary = false;\n  let lastStr = '';\n  let read = 0;\n  try {\n    while ((read = fs.readSync(fd, buffer, 0, BUFFER_SIZE, null)) !== 0) {\n      const slicedBuffer = buffer.slice(0, read);\n\n      // Detect if file is binary by checking the first 8k bytes for the\n      // null character (git like implementation)\n      if (size === 0) {\n        isBinary = slicedBuffer.indexOf(0) !== -1;\n      }\n\n      let dataBuffer = slicedBuffer;\n      if (!isBinary) { // Line endings normalization (CRLF -> LF)\n        const str = buffer.slice(0, read).toString();\n\n        // We are going to normalize line endings to LF. So if the current\n        // buffer ends with CR, it could be that the next one starts with\n        // LF so we need to save it for later use.\n        if (new RegExp(`${CR}$`).test(str)) {\n          lastStr += str;\n          continue;\n        }\n\n        const data = lastStr + str;\n        const normalizedData = data.replace(new RegExp(CRLF, 'g'), LF);\n        dataBuffer = Buffer.from(normalizedData);\n        lastStr = '';\n      }\n\n      size += dataBuffer.length;\n      hash.update(dataBuffer);\n    }\n\n    if (lastStr) {\n      hash.update(Buffer.from(lastStr));\n    }\n  } finally {\n    fs.closeSync(fd);\n  }\n  return `${size}:${hash.digest('hex')}`;\n}\n\nfunction _hashField(hash: crypto.Hash, header: string, value: string | Buffer | DataView) {\n  hash.update(CTRL_SOH).update(header).update(CTRL_SOT).update(value).update(CTRL_ETX);\n}\n"],
  "mappings": "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",
  "names": []
}
