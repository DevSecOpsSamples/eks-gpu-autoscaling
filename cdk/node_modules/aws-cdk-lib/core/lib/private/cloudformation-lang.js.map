{
  "version": 3,
  "sources": ["cloudformation-lang.ts"],
  "sourcesContent": ["import { Lazy } from '../lazy';\nimport { DefaultTokenResolver, IFragmentConcatenator, IResolveContext } from '../resolvable';\nimport { Stack } from '../stack';\nimport { Token } from '../token';\nimport { CfnUtils } from './cfn-utils-provider';\nimport { INTRINSIC_KEY_PREFIX, ResolutionTypeHint, resolvedTypeHint } from './resolve';\n\n/**\n * Routines that know how to do operations at the CloudFormation document language level\n */\nexport class CloudFormationLang {\n  /**\n   * Turn an arbitrary structure potentially containing Tokens into a JSON string.\n   *\n   * Returns a Token which will evaluate to CloudFormation expression that\n   * will be evaluated by CloudFormation to the JSON representation of the\n   * input structure.\n   *\n   * All Tokens substituted in this way must return strings, or the evaluation\n   * in CloudFormation will fail.\n   *\n   * @param obj The object to stringify\n   * @param space Indentation to use (default: no pretty-printing)\n   */\n  public static toJSON(obj: any, space?: number): string {\n    return Lazy.uncachedString({\n      // We used to do this by hooking into `JSON.stringify()` by adding in objects\n      // with custom `toJSON()` functions, but it's ultimately simpler just to\n      // reimplement the `stringify()` function from scratch.\n      produce: (ctx) => tokenAwareStringify(obj, space ?? 0, ctx),\n    });\n  }\n\n  /**\n   * Produce a CloudFormation expression to concat two arbitrary expressions when resolving\n   */\n  public static concat(left: any | undefined, right: any | undefined): any {\n    if (left === undefined && right === undefined) { return ''; }\n\n    const parts = new Array<any>();\n    if (left !== undefined) { parts.push(left); }\n    if (right !== undefined) { parts.push(right); }\n\n    // Some case analysis to produce minimal expressions\n    if (parts.length === 1) { return parts[0]; }\n    if (parts.length === 2 && isConcatable(parts[0]) && isConcatable(parts[1])) {\n      return `${parts[0]}${parts[1]}`;\n    }\n\n    // Otherwise return a Join intrinsic (already in the target document language to avoid taking\n    // circular dependencies on FnJoin & friends)\n    return fnJoinConcat(parts);\n  }\n}\n\n/**\n * Return a CFN intrinsic mass concatting any number of CloudFormation expressions\n */\nfunction fnJoinConcat(parts: any[]) {\n  return { 'Fn::Join': ['', minimalCloudFormationJoin('', parts)] };\n}\n\n/**\n * Perform a JSON.stringify()-like operation, except aware of Tokens and CloudFormation intrincics\n *\n * Tokens will be resolved and if any resolve to CloudFormation intrinsics, the intrinsics\n * will be lifted to the top of a giant `{ Fn::Join }` expression.\n *\n * If Tokens resolve to primitive types (for example, by using Lazies), we'll\n * use the primitive type to determine how to encode the value into the JSON.\n *\n * If Tokens resolve to CloudFormation intrinsics, we'll use the type of the encoded\n * value as a type hint to determine how to encode the value into the JSON. The difference\n * is that we add quotes (\") around strings, and don't add anything around non-strings.\n *\n * The following structure:\n *\n *    { SomeAttr: resource.someAttr }\n *\n * Will JSONify to either:\n *\n *    '{ \"SomeAttr\": \"' ++ { Fn::GetAtt: [Resource, SomeAttr] } ++ '\" }'\n * or '{ \"SomeAttr\": ' ++ { Fn::GetAtt: [Resource, SomeAttr] } ++ ' }'\n *\n * Depending on whether `someAttr` is type-hinted to be a string or not.\n *\n * (Where ++ is the CloudFormation string-concat operation (`{ Fn::Join }`).\n *\n * -----------------------\n *\n * This work requires 2 features from the `resolve()` function:\n *\n * - INTRINSICS TYPE HINTS: intrinsics are represented by values like\n *   `{ Ref: 'XYZ' }`. These values can reference either a string or a list/number at\n *   deploy time, and from the value alone there's no way to know which. We need\n *   to know the type to know whether to JSONify this reference to:\n *\n *      '{ \"referencedValue\": \"' ++ { Ref: XYZ } ++ '\"}'\n *   or '{ \"referencedValue\": ' ++ { Ref: XYZ } ++ '}'\n *\n *   I.e., whether or not we need to enclose the reference in quotes or not.\n *\n *   We COULD have done this by resolving one token at a time, and looking at the\n *   type of the encoded token we were resolving to obtain a type hint. However,\n *   the `resolve()` and Token system resist a level-at-a-time resolve\n *   operation: because of the existence of post-processors, we must have done a\n *   complete recursive resolution of a token before we can look at its result\n *   (after which any type information about the sources of nested resolved\n *   values is lost).\n *\n *   To fix this, \"type hints\" have been added to the `resolve()` function,\n *   giving an idea of the type of the source value for compplex result values.\n *   This only works for objects (not strings and numbers) but fortunately\n *   we only care about the types of intrinsics, which are always complex values.\n *\n *   Type hinting could have been added to the `IResolvable` protocol as well,\n *   but for now we just use the type of an encoded value as a type hint. That way\n *   we don't need to annotate anything more at the L1 level--we will use the type\n *   encodings added by construct authors at the L2 levels. L1 users can escape the\n *   default decision of \"string\" by using `Token.asList()`.\n *\n * - COMPLEX KEYS: since tokens can be string-encoded, we can use string-encoded tokens\n *   as the keys in JavaScript objects. However, after resolution, those string-encoded\n *   tokens could resolve to intrinsics (`{ Ref: ... }`), which CANNOT be stored in\n *   JavaScript objects anymore.\n *\n *   We therefore need a protocol to store the resolved values somewhere in the JavaScript\n *   type model,  which can be returned by `resolve()`, and interpreted by `tokenAwareStringify()`\n *   to produce the correct JSON.\n *\n *   And example will quickly show the point:\n *\n *    User writes:\n *       { [resource.resourceName]: 'SomeValue' }\n *    ------ string actually looks like ------>\n *       { '${Token[1234]}': 'SomeValue' }\n *    ------ resolve ------->\n *       { '$IntrinsicKey$0': [ {Ref: Resource}, 'SomeValue' ] }\n *    ------ tokenAwareStringify ------->\n *       '{ \"' ++ { Ref: Resource } ++ '\": \"SomeValue\" }'\n */\nfunction tokenAwareStringify(root: any, space: number, ctx: IResolveContext) {\n  let indent = 0;\n\n  const ret = new Array<Segment>();\n\n  // First completely resolve the tree, then encode to JSON while respecting the type\n  // hints we got for the resolved intrinsics.\n  recurse(ctx.resolve(root, { allowIntrinsicKeys: true }));\n\n  switch (ret.length) {\n    case 0: return undefined;\n    case 1: return renderSegment(ret[0]);\n    default:\n      return fnJoinConcat(ret.map(renderSegment));\n  }\n\n  /**\n   * Stringify a JSON element\n   */\n  function recurse(obj: any): void {\n    if (obj === undefined) { return; }\n\n    if (Token.isUnresolved(obj)) {\n      throw new Error('This shouldnt happen anymore');\n    }\n    if (Array.isArray(obj)) {\n      return renderCollection('[', ']', obj, recurse);\n    }\n    if (typeof obj === 'object' && obj != null && !(obj instanceof Date)) {\n      // Treat as an intrinsic if this LOOKS like a CFN intrinsic (`{ Ref: ... }`)\n      // AND it's the result of a token resolution. Otherwise, we just treat this\n      // value as a regular old JSON object (that happens to look a lot like an intrinsic).\n      if (isIntrinsic(obj) && resolvedTypeHint(obj)) {\n        renderIntrinsic(obj);\n        return;\n      }\n\n      return renderCollection('{', '}', definedEntries(obj), ([key, value]) => {\n        if (key.startsWith(INTRINSIC_KEY_PREFIX)) {\n          [key, value] = value;\n        }\n\n        recurse(key);\n        pushLiteral(prettyPunctuation(':'));\n        recurse(value);\n      });\n    }\n    // Otherwise we have a scalar, defer to JSON.stringify()s serialization\n    pushLiteral(JSON.stringify(obj));\n  }\n\n  /**\n   * Render an object or list\n   */\n  function renderCollection<A>(pre: string, post: string, xs: Iterable<A>, each: (x: A) => void) {\n    pushLiteral(pre);\n    indent += space;\n    let atLeastOne = false;\n    for (const [comma, item] of sepIter(xs)) {\n      if (comma) { pushLiteral(','); }\n      pushLineBreak();\n      each(item);\n      atLeastOne = true;\n    }\n    indent -= space;\n    if (atLeastOne) { pushLineBreak(); }\n    pushLiteral(post);\n  }\n\n  function renderIntrinsic(intrinsic: any) {\n    switch (resolvedTypeHint(intrinsic)) {\n      case ResolutionTypeHint.STRING:\n        pushLiteral('\"');\n        pushIntrinsic(deepQuoteStringLiterals(intrinsic));\n        pushLiteral('\"');\n        return;\n\n      case ResolutionTypeHint.LIST:\n        // We need this to look like:\n        //\n        //    '{\"listValue\":' ++ STRINGIFY(CFN_EVAL({ Ref: MyList })) ++ '}'\n        //\n        // However, STRINGIFY would need to execute at CloudFormation deployment time, and that doesn't exist.\n        //\n        // We could *ALMOST* use:\n        //\n        //   '{\"listValue\":[\"' ++ JOIN('\",\"', { Ref: MyList }) ++ '\"]}'\n        //\n        // But that has the unfortunate side effect that if `CFN_EVAL({ Ref: MyList }) == []`, then it would\n        // evaluate to `[\"\"]`, which is a different value. Since CloudFormation does not have arbitrary\n        // conditionals there's no way to deal with this case properly.\n        //\n        // Therefore, if we encounter lists we need to defer to a custom resource to handle\n        // them properly at deploy time.\n        const stack = Stack.of(ctx.scope);\n\n        // Because this will be called twice (once during `prepare`, once during `resolve`),\n        // we need to make sure to be idempotent, so use a cache.\n        const stringifyResponse = stringifyCache.obtain(stack, JSON.stringify(intrinsic), () =>\n          CfnUtils.stringify(stack, `CdkJsonStringify${stringifyCounter++}`, intrinsic),\n        );\n\n        pushIntrinsic(stringifyResponse);\n        return;\n\n      case ResolutionTypeHint.NUMBER:\n        pushIntrinsic(intrinsic);\n        return;\n    }\n\n    throw new Error(`Unexpected type hint: ${resolvedTypeHint(intrinsic)}`);\n  }\n\n  /**\n   * Push a literal onto the current segment if it's also a literal, otherwise open a new Segment\n   */\n  function pushLiteral(lit: string) {\n    let last = ret[ret.length - 1];\n    if (last?.type !== 'literal') {\n      last = { type: 'literal', parts: [] };\n      ret.push(last);\n    }\n    last.parts.push(lit);\n  }\n\n  /**\n   * Add a new intrinsic segment\n   */\n  function pushIntrinsic(intrinsic: any) {\n    ret.push({ type: 'intrinsic', intrinsic });\n  }\n\n  /**\n   * Push a line break if we are pretty-printing, otherwise don't\n   */\n  function pushLineBreak() {\n    if (space > 0) {\n      pushLiteral(`\\n${' '.repeat(indent)}`);\n    }\n  }\n\n  /**\n   * Add a space after the punctuation if we are pretty-printing, no space if not\n   */\n  function prettyPunctuation(punc: string) {\n    return space > 0 ? `${punc} ` : punc;\n  }\n}\n\n/**\n * A Segment is either a literal string or a CloudFormation intrinsic\n */\ntype Segment = { type: 'literal'; parts: string[] } | { type: 'intrinsic'; intrinsic: any };\n\n/**\n * Render a segment\n */\nfunction renderSegment(s: Segment): NonNullable<any> {\n  switch (s.type) {\n    case 'literal': return s.parts.join('');\n    case 'intrinsic': return s.intrinsic;\n  }\n}\n\nconst CLOUDFORMATION_CONCAT: IFragmentConcatenator = {\n  join(left: any, right: any) {\n    return CloudFormationLang.concat(left, right);\n  },\n};\n\n/**\n * Default Token resolver for CloudFormation templates\n */\nexport const CLOUDFORMATION_TOKEN_RESOLVER = new DefaultTokenResolver(CLOUDFORMATION_CONCAT);\n\n/**\n * Do an intelligent CloudFormation join on the given values, producing a minimal expression\n */\nexport function minimalCloudFormationJoin(delimiter: string, values: any[]): any[] {\n  let i = 0;\n  while (i < values.length) {\n    const el = values[i];\n    if (isSplicableFnJoinIntrinsic(el)) {\n      values.splice(i, 1, ...el['Fn::Join'][1]);\n    } else if (i > 0 && isConcatable(values[i - 1]) && isConcatable(values[i])) {\n      values[i - 1] = `${values[i-1]}${delimiter}${values[i]}`;\n      values.splice(i, 1);\n    } else {\n      i += 1;\n    }\n  }\n\n  return values;\n\n  function isSplicableFnJoinIntrinsic(obj: any): boolean {\n    if (!isIntrinsic(obj)) { return false; }\n    if (Object.keys(obj)[0] !== 'Fn::Join') { return false; }\n\n    const [delim, list] = obj['Fn::Join'];\n    if (delim !== delimiter) { return false; }\n\n    if (Token.isUnresolved(list)) { return false; }\n    if (!Array.isArray(list)) { return false; }\n\n    return true;\n  }\n}\n\nfunction isConcatable(obj: any): boolean {\n  return ['string', 'number'].includes(typeof obj) && !Token.isUnresolved(obj);\n}\n\n\n/**\n * Return whether the given value represents a CloudFormation intrinsic\n */\nfunction isIntrinsic(x: any) {\n  if (Array.isArray(x) || x === null || typeof x !== 'object') { return false; }\n\n  const keys = Object.keys(x);\n  if (keys.length !== 1) { return false; }\n\n  return keys[0] === 'Ref' || isNameOfCloudFormationIntrinsic(keys[0]);\n}\n\nexport function isNameOfCloudFormationIntrinsic(name: string): boolean {\n  if (!name.startsWith('Fn::')) {\n    return false;\n  }\n  // these are 'fake' intrinsics, only usable inside the parameter overrides of a CFN CodePipeline Action\n  return name !== 'Fn::GetArtifactAtt' && name !== 'Fn::GetParam';\n}\n\n/**\n * Separated iterator\n */\nfunction* sepIter<A>(xs: Iterable<A>): IterableIterator<[boolean, A]> {\n  let comma = false;\n  for (const item of xs) {\n    yield [comma, item];\n    comma = true;\n  }\n}\n\n/**\n * Object.entries() but skipping undefined values\n */\nfunction* definedEntries<A extends object>(xs: A): IterableIterator<[string, any]> {\n  for (const [key, value] of Object.entries(xs)) {\n    if (value !== undefined) {\n      yield [key, value];\n    }\n  }\n}\n\n/**\n * Quote string literals inside an intrinsic\n *\n * Formally, this should only match string literals that will be interpreted as\n * string literals. Fortunately, the strings that should NOT be quoted are\n * Logical IDs and attribute names, which cannot contain quotes anyway. Hence,\n * we can get away not caring about the distinction and just quoting everything.\n */\nfunction deepQuoteStringLiterals(x: any): any {\n  if (Array.isArray(x)) {\n    return x.map(deepQuoteStringLiterals);\n  }\n  if (typeof x === 'object' && x != null) {\n    const ret: any = {};\n    for (const [key, value] of Object.entries(x)) {\n      ret[deepQuoteStringLiterals(key)] = deepQuoteStringLiterals(value);\n    }\n    return ret;\n  }\n  if (typeof x === 'string') {\n    return quoteString(x);\n  }\n  return x;\n}\n\n/**\n * Quote the characters inside a string, for use inside toJSON\n */\nfunction quoteString(s: string) {\n  s = JSON.stringify(s);\n  return s.substring(1, s.length - 1);\n}\n\nlet stringifyCounter = 1;\n\n/**\n * A cache scoped to object instances, that's maintained externally to the object instances\n */\nclass ScopedCache<O extends object, K, V> {\n  private cache = new WeakMap<O, Map<K, V>>();\n\n  public obtain(object: O, key: K, init: () => V): V {\n    let kvMap = this.cache.get(object);\n    if (!kvMap) {\n      kvMap = new Map();\n      this.cache.set(object, kvMap);\n    }\n\n    let ret = kvMap.get(key);\n    if (ret === undefined) {\n      ret = init();\n      kvMap.set(key, ret);\n    }\n    return ret;\n  }\n}\n\nconst stringifyCache = new ScopedCache<Stack, string, string>();"],
  "mappings": "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",
  "names": []
}
