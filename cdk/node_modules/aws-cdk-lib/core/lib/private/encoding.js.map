{
  "version": 3,
  "sources": ["encoding.ts"],
  "sourcesContent": ["import { IFragmentConcatenator, IResolvable } from '../resolvable';\nimport { TokenizedStringFragments } from '../string-fragments';\nimport { isResolvableObject } from '../token';\n\n// Details for encoding and decoding Tokens into native types; should not be exported\n\nexport const BEGIN_STRING_TOKEN_MARKER = '${Token[';\nexport const BEGIN_LIST_TOKEN_MARKER = '#{Token[';\nexport const END_TOKEN_MARKER = ']}';\n\nexport const VALID_KEY_CHARS = 'a-zA-Z0-9:._-';\n\nconst QUOTED_BEGIN_STRING_TOKEN_MARKER = regexQuote(BEGIN_STRING_TOKEN_MARKER);\nconst QUOTED_BEGIN_LIST_TOKEN_MARKER = regexQuote(BEGIN_LIST_TOKEN_MARKER);\nconst QUOTED_END_TOKEN_MARKER = regexQuote(END_TOKEN_MARKER);\n\n// Sometimes the number of digits is different\nexport const STRINGIFIED_NUMBER_PATTERN = '-1\\\\.\\\\d{10,16}e\\\\+289';\n\nconst STRING_TOKEN_REGEX = new RegExp(`${QUOTED_BEGIN_STRING_TOKEN_MARKER}([${VALID_KEY_CHARS}]+)${QUOTED_END_TOKEN_MARKER}|(${STRINGIFIED_NUMBER_PATTERN})`, 'g');\nconst LIST_TOKEN_REGEX = new RegExp(`${QUOTED_BEGIN_LIST_TOKEN_MARKER}([${VALID_KEY_CHARS}]+)${QUOTED_END_TOKEN_MARKER}`, 'g');\n\n/**\n * A string with markers in it that can be resolved to external values\n */\nexport class TokenString {\n  /**\n   * Returns a `TokenString` for this string.\n   */\n  public static forString(s: string) {\n    return new TokenString(s, STRING_TOKEN_REGEX);\n  }\n\n  /**\n   * Returns a `TokenString` for this string (must be the first string element of the list)\n   */\n  public static forListToken(s: string) {\n    return new TokenString(s, LIST_TOKEN_REGEX);\n  }\n\n  constructor(private readonly str: string, private readonly re: RegExp) {\n  }\n\n  /**\n   * Split string on markers, substituting markers with Tokens\n   */\n  public split(lookup: (id: string) => IResolvable): TokenizedStringFragments {\n    const ret = new TokenizedStringFragments();\n\n    let rest = 0;\n    this.re.lastIndex = 0; // Reset\n    let m = this.re.exec(this.str);\n    while (m) {\n      if (m.index > rest) {\n        ret.addLiteral(this.str.substring(rest, m.index));\n      }\n\n      ret.addToken(lookup(m[1] ?? m[2]));\n\n      rest = this.re.lastIndex;\n      m = this.re.exec(this.str);\n    }\n\n    if (rest < this.str.length) {\n      ret.addLiteral(this.str.substring(rest));\n    }\n\n    return ret;\n  }\n\n  /**\n   * Indicates if this string includes tokens.\n   */\n  public test(): boolean {\n    this.re.lastIndex = 0; // Reset\n    return this.re.test(this.str);\n  }\n}\n\n/**\n * Quote a string for use in a regex\n */\nexport function regexQuote(s: string) {\n  return s.replace(/[.?*+^$[\\]\\\\(){}|-]/g, '\\\\$&');\n}\n\n/**\n * Concatenator that disregards the input\n *\n * Can be used when traversing the tokens is important, but the\n * result isn't.\n */\nexport class NullConcat implements IFragmentConcatenator {\n  public join(_left: any | undefined, _right: any | undefined): any {\n    return undefined;\n  }\n}\n\nexport function containsListTokenElement(xs: any[]) {\n  return xs.some(x => typeof(x) === 'string' && TokenString.forListToken(x).test());\n}\n\n/**\n * Returns true if obj is a token (i.e. has the resolve() method or is a string\n * that includes token markers), or it's a listifictaion of a Token string.\n *\n * @param obj The object to test.\n */\nexport function unresolved(obj: any): boolean {\n  if (typeof(obj) === 'string') {\n    return TokenString.forString(obj).test();\n  } else if (typeof obj === 'number') {\n    return extractTokenDouble(obj) !== undefined;\n  } else if (Array.isArray(obj) && obj.length === 1) {\n    return typeof(obj[0]) === 'string' && TokenString.forListToken(obj[0]).test();\n  } else {\n    return isResolvableObject(obj);\n  }\n}\n\n/**\n * Bit pattern in the top 16 bits of a double to indicate a Token\n *\n * An IEEE double in LE memory order looks like this (grouped\n * into octets, then grouped into 32-bit words):\n *\n * mmmmmmmm.mmmmmmmm.mmmmmmmm.mmmmmmmm | mmmmmmmm.mmmmmmmm.EEEEmmmm.sEEEEEEE\n *\n * - m: mantissa (52 bits)\n * - E: exponent (11 bits)\n * - s: sign (1 bit)\n *\n * We put the following marker into the top 16 bits (exponent and sign), and\n * use the mantissa part to encode the token index. To save some bit twiddling\n * we use all top 16 bits for the tag. That loses us 4 mantissa bits to store\n * information in but we still have 48, which is going to be plenty for any\n * number of tokens to be created during the lifetime of any CDK application.\n *\n * Can't have all bits set because that makes a NaN, so unset the least\n * significant exponent bit.\n *\n * Currently not supporting BE architectures.\n */\n// eslint-disable-next-line no-bitwise\nconst DOUBLE_TOKEN_MARKER_BITS = 0xFBFF << 16;\n\n/**\n * Highest encodable number\n */\nconst MAX_ENCODABLE_INTEGER = Math.pow(2, 48) - 1;\n\n/**\n * Get 2^32 as a number, so we can do multiplication and div instead of bit shifting\n *\n * Necessary because in JavaScript, bit operations implicitly convert\n * to int32 and we need them to work on \"int64\"s.\n *\n * So instead of x >> 32, we do Math.floor(x / 2^32), and vice versa.\n */\nconst BITS32 = Math.pow(2, 32);\n\n/**\n * Return a special Double value that encodes the given nonnegative integer\n *\n * We use this to encode Token ordinals.\n */\nexport function createTokenDouble(x: number) {\n  if (Math.floor(x) !== x || x < 0) {\n    throw new Error('Can only encode positive integers');\n  }\n  if (x > MAX_ENCODABLE_INTEGER) {\n    throw new Error(`Got an index too large to encode: ${x}`);\n  }\n\n  const buf = new ArrayBuffer(8);\n  const ints = new Uint32Array(buf);\n\n  /* eslint-disable no-bitwise */\n  ints[0] = x & 0x0000FFFFFFFF; // Bottom 32 bits of number\n\n  // This needs an \"x >> 32\" but that will make it a 32-bit number instead\n  // of a 64-bit number.\n  ints[1] = (shr32(x) & 0xFFFF) | DOUBLE_TOKEN_MARKER_BITS; // Top 16 bits of number and the mask\n  /* eslint-enable no-bitwise */\n\n  return (new Float64Array(buf))[0];\n}\n\n/**\n * Shift a 64-bit int right 32 bits\n */\nfunction shr32(x: number) {\n  return Math.floor(x / BITS32);\n}\n\n/**\n * Shift a 64-bit left 32 bits\n */\nfunction shl32(x: number) {\n  return x * BITS32;\n}\n\n/**\n * Extract the encoded integer out of the special Double value\n *\n * Returns undefined if the float is a not an encoded token.\n */\nexport function extractTokenDouble(encoded: number): number | undefined {\n  const buf = new ArrayBuffer(8);\n  (new Float64Array(buf))[0] = encoded;\n\n  const ints = new Uint32Array(buf);\n\n  /* eslint-disable no-bitwise */\n  if ((ints[1] & 0xFFFF0000) !== DOUBLE_TOKEN_MARKER_BITS) {\n    return undefined;\n  }\n\n  // Must use + instead of | here (bitwise operations\n  // will force 32-bits integer arithmetic, + will not).\n  return ints[0] + shl32(ints[1] & 0xFFFF);\n  /* eslint-enable no-bitwise */\n}\n\nconst STRINGIFIED_NUMBER_REGEX = new RegExp(STRINGIFIED_NUMBER_PATTERN);\n\n/**\n * Return whether the given string contains accidentally stringified number tokens\n */\nexport function stringContainsNumberTokens(x: string) {\n  return !!x.match(STRINGIFIED_NUMBER_REGEX);\n}\n"],
  "mappings": "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",
  "names": []
}
