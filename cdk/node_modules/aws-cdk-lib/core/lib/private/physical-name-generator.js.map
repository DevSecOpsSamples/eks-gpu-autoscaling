{
  "version": 3,
  "sources": ["physical-name-generator.ts"],
  "sourcesContent": ["import * as crypto from 'crypto';\nimport { Node } from 'constructs';\nimport { Names } from '../names';\nimport { IResolvable, IResolveContext } from '../resolvable';\nimport { IResource } from '../resource';\nimport { Stack } from '../stack';\nimport { Token } from '../token';\nimport { TokenMap } from './token-map';\n\nexport function generatePhysicalName(resource: IResource): string {\n  const stack = Stack.of(resource);\n  const stackPart = new PrefixNamePart(stack.stackName, 25);\n  const idPart = new SuffixNamePart(Names.nodeUniqueId(resource.node), 24);\n\n  const region: string = stack.region;\n  if (Token.isUnresolved(region) || !region) {\n    throw new Error(`Cannot generate a physical name for ${Node.of(resource).path}, because the region is un-resolved or missing`);\n  }\n\n  const account: string = stack.account;\n  if (Token.isUnresolved(account) || !account) {\n    throw new Error(`Cannot generate a physical name for ${Node.of(resource).path}, because the account is un-resolved or missing`);\n  }\n\n  const parts = [stackPart, idPart]\n    .map(part => part.generate());\n\n  const hashLength = 12;\n  const sha256 = crypto.createHash('sha256')\n    .update(stackPart.bareStr)\n    .update(idPart.bareStr)\n    .update(region)\n    .update(account);\n  const hash = sha256.digest('hex').slice(0, hashLength);\n\n  const ret = [...parts, hash].join('');\n\n  return ret.toLowerCase();\n}\n\nabstract class NamePart {\n  public readonly bareStr: string;\n\n  constructor(bareStr: string) {\n    this.bareStr = bareStr;\n  }\n\n  public abstract generate(): string;\n}\n\nclass PrefixNamePart extends NamePart {\n  constructor(bareStr: string, private readonly prefixLength: number) {\n    super(bareStr);\n  }\n\n  public generate(): string {\n    return this.bareStr.slice(0, this.prefixLength);\n  }\n}\n\nclass SuffixNamePart extends NamePart {\n  constructor(str: string, private readonly suffixLength: number) {\n    super(str);\n  }\n\n  public generate(): string {\n    const strLen = this.bareStr.length;\n    const startIndex = Math.max(strLen - this.suffixLength, 0);\n    return this.bareStr.slice(startIndex, strLen);\n  }\n}\n\nconst GENERATE_IF_NEEDED_SYMBOL = Symbol.for('@aws-cdk/core.<private>.GenerateIfNeeded');\n\n/**\n * This marker token is used by PhysicalName.GENERATE_IF_NEEDED. When that token is passed to the\n * physicalName property of a Resource, it triggers different behavior in the Resource constructor\n * that will allow emission of a generated physical name (when the resource is used across\n * environments) or undefined (when the resource is not shared).\n *\n * This token throws an Error when it is resolved, as a way to prevent inadvertent mis-uses of it.\n */\nexport class GeneratedWhenNeededMarker implements IResolvable {\n  public readonly creationStack: string[] = [];\n\n  constructor() {\n    Object.defineProperty(this, GENERATE_IF_NEEDED_SYMBOL, { value: true });\n  }\n\n  public resolve(_ctx: IResolveContext): never {\n    throw new Error('Invalid physical name passed to CloudFormation. Use \"this.physicalName\" instead');\n  }\n\n  public toString(): string {\n    return 'PhysicalName.GENERATE_IF_NEEDED';\n  }\n}\n\n/**\n * Checks whether a stringified token resolves to a `GeneratedWhenNeededMarker`.\n */\nexport function isGeneratedWhenNeededMarker(val: string): boolean {\n  const token = TokenMap.instance().lookupString(val);\n  return !!token && GENERATE_IF_NEEDED_SYMBOL in token;\n}\n"],
  "mappings": "8KAAA,KAAA,QAAA,QAAA,QAAA,EACA,aAAA,QAAA,YAAA,EACA,QAAA,QAAA,UAAA,EAGA,QAAA,QAAA,UAAA,EACA,QAAA,QAAA,UAAA,EACA,YAAA,QAAA,aAAA,EAEA,8BAAqC,SAAmB,CACtD,KAAM,OAAQ,QAAA,MAAM,GAAG,QAAQ,EACzB,UAAY,GAAI,gBAAe,MAAM,UAAW,EAAE,EAClD,OAAS,GAAI,gBAAe,QAAA,MAAM,aAAa,SAAS,IAAI,EAAG,EAAE,EAEjE,OAAiB,MAAM,OAC7B,GAAI,QAAA,MAAM,aAAa,MAAM,GAAK,CAAC,OACjC,KAAM,IAAI,OAAM,uCAAuC,aAAA,KAAK,GAAG,QAAQ,EAAE,oDAAoD,EAG/H,KAAM,SAAkB,MAAM,QAC9B,GAAI,QAAA,MAAM,aAAa,OAAO,GAAK,CAAC,QAClC,KAAM,IAAI,OAAM,uCAAuC,aAAA,KAAK,GAAG,QAAQ,EAAE,qDAAqD,EAGhI,KAAM,OAAQ,CAAC,UAAW,MAAM,EAC7B,IAAI,MAAQ,KAAK,SAAQ,CAAE,EAExB,WAAa,GAMb,KAAO,AALE,OAAO,WAAW,QAAQ,EACtC,OAAO,UAAU,OAAO,EACxB,OAAO,OAAO,OAAO,EACrB,OAAO,MAAM,EACb,OAAO,OAAO,EACG,OAAO,KAAK,EAAE,MAAM,EAAG,UAAU,EAIrD,MAAO,AAFK,CAAC,GAAG,MAAO,IAAI,EAAE,KAAK,EAAE,EAEzB,YAAW,CACxB,CA7BA,QAAA,qBAAA,qBA+BA,MAAe,QAAQ,CAGrB,YAAY,QAAe,CACzB,KAAK,QAAU,SAMnB,MAAM,sBAAuB,SAAQ,CACnC,YAAY,QAAkC,aAAoB,CAChE,MAAM,OAAO,EAD+B,KAAA,aAAA,aAIvC,UAAQ,CACb,MAAO,MAAK,QAAQ,MAAM,EAAG,KAAK,YAAY,GAIlD,MAAM,sBAAuB,SAAQ,CACnC,YAAY,IAA8B,aAAoB,CAC5D,MAAM,GAAG,EAD+B,KAAA,aAAA,aAInC,UAAQ,CACb,KAAM,QAAS,KAAK,QAAQ,OACtB,WAAa,KAAK,IAAI,OAAS,KAAK,aAAc,CAAC,EACzD,MAAO,MAAK,QAAQ,MAAM,WAAY,MAAM,GAIhD,KAAM,2BAA4B,OAAO,IAAI,0CAA0C,EAUvF,MAAa,yBAAyB,CAGpC,aAAA,CAFgB,KAAA,cAA0B,CAAA,EAGxC,OAAO,eAAe,KAAM,0BAA2B,CAAE,MAAO,EAAI,CAAE,EAGjE,QAAQ,KAAqB,CAClC,KAAM,IAAI,OAAM,iFAAiF,EAG5F,UAAQ,CACb,MAAO,mCAZX,QAAA,0BAAA,0BAmBA,qCAA4C,IAAW,CACrD,KAAM,OAAQ,YAAA,SAAS,SAAQ,EAAG,aAAa,GAAG,EAClD,MAAO,CAAC,CAAC,OAAS,4BAA6B,MACjD,CAHA,QAAA,4BAAA",
  "names": []
}
