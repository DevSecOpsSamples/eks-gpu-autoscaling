{
  "version": 3,
  "sources": ["metadata-resource.ts"],
  "sourcesContent": ["import * as zlib from 'zlib';\nimport { RegionInfo } from '../../../region-info';\nimport { Construct } from 'constructs';\nimport { CfnCondition } from '../cfn-condition';\nimport { Fn } from '../cfn-fn';\nimport { Aws } from '../cfn-pseudo';\nimport { CfnResource } from '../cfn-resource';\nimport { Lazy } from '../lazy';\nimport { Stack } from '../stack';\nimport { Token } from '../token';\nimport { ConstructInfo, constructInfoFromStack } from './runtime-info';\n\n/**\n * Construct that will render the metadata resource\n */\nexport class MetadataResource extends Construct {\n  constructor(scope: Stack, id: string) {\n    super(scope, id);\n\n    const metadataServiceExists = Token.isUnresolved(scope.region) || RegionInfo.get(scope.region).cdkMetadataResourceAvailable;\n    if (metadataServiceExists) {\n      const resource = new CfnResource(this, 'Default', {\n        type: 'AWS::CDK::Metadata',\n        properties: {\n          Analytics: Lazy.string({ produce: () => formatAnalytics(constructInfoFromStack(scope)) }),\n        },\n      });\n\n      // In case we don't actually know the region, add a condition to determine it at deploy time\n      if (Token.isUnresolved(scope.region)) {\n        const condition = new CfnCondition(this, 'Condition', {\n          expression: makeCdkMetadataAvailableCondition(),\n        });\n\n        // To not cause undue template changes\n        condition.overrideLogicalId('CDKMetadataAvailable');\n\n        resource.cfnOptions.condition = condition;\n      }\n    }\n  }\n}\n\nfunction makeCdkMetadataAvailableCondition() {\n  return Fn.conditionOr(...RegionInfo.regions\n    .filter(ri => ri.cdkMetadataResourceAvailable)\n    .map(ri => Fn.conditionEquals(Aws.REGION, ri.name)));\n}\n\n/** Convenience type for arbitrarily-nested map */\nclass Trie extends Map<string, Trie> { }\n\n/**\n * Formats a list of construct fully-qualified names (FQNs) and versions into a (possibly compressed) prefix-encoded string.\n *\n * The list of ConstructInfos is logically formatted into:\n * ${version}!${fqn} (e.g., \"1.90.0!aws-cdk-lib.Stack\")\n * and then all of the construct-versions are grouped with common prefixes together, grouping common parts in '{}' and separating items with ','.\n *\n * Example:\n * [1.90.0!aws-cdk-lib.Stack, 1.90.0!aws-cdk-lib.Construct, 1.90.0!aws-cdk-lib.service.Resource, 0.42.1!aws-cdk-lib-experiments.NewStuff]\n * Becomes:\n * 1.90.0!aws-cdk-lib.{Stack,Construct,service.Resource},0.42.1!aws-cdk-lib-experiments.NewStuff\n *\n * The whole thing is then either included directly as plaintext as:\n * v2:plaintext:{prefixEncodedList}\n * Or is compressed and base64-encoded, and then formatted as:\n * v2:deflate64:{prefixEncodedListCompressedAndEncoded}\n *\n * Exported/visible for ease of testing.\n */\nexport function formatAnalytics(infos: ConstructInfo[]) {\n  const trie = new Trie();\n  infos.forEach(info => insertFqnInTrie(`${info.version}!${info.fqn}`, trie));\n\n  const plaintextEncodedConstructs = prefixEncodeTrie(trie);\n  const compressedConstructsBuffer = zlib.gzipSync(Buffer.from(plaintextEncodedConstructs));\n\n  // set OS flag to \"unknown\" in order to ensure we get consistent results across operating systems\n  // see https://github.com/aws/aws-cdk/issues/15322\n  setGzipOperatingSystemToUnknown(compressedConstructsBuffer);\n\n  const compressedConstructs = compressedConstructsBuffer.toString('base64');\n  return `v2:deflate64:${compressedConstructs}`;\n}\n\n/**\n * Splits after non-alphanumeric characters (e.g., '.', '/') in the FQN\n * and insert each piece of the FQN in nested map (i.e., simple trie).\n */\nfunction insertFqnInTrie(fqn: string, trie: Trie) {\n  for (const fqnPart of fqn.replace(/[^a-z0-9]/gi, '$& ').split(' ')) {\n    const nextLevelTreeRef = trie.get(fqnPart) ?? new Trie();\n    trie.set(fqnPart, nextLevelTreeRef);\n    trie = nextLevelTreeRef;\n  }\n  return trie;\n}\n\n/**\n * Prefix-encodes a \"trie-ish\" structure, using '{}' to group and ',' to separate siblings.\n *\n * Example input:\n * ABC,ABD,AEF\n *\n * Example trie:\n * A --> B --> C\n *  |     \\--> D\n *  \\--> E --> F\n *\n * Becomes:\n * A{B{C,D},EF}\n */\nfunction prefixEncodeTrie(trie: Trie) {\n  let prefixEncoded = '';\n  let isFirstEntryAtLevel = true;\n  [...trie.entries()].forEach(([key, value]) => {\n    if (!isFirstEntryAtLevel) {\n      prefixEncoded += ',';\n    }\n    isFirstEntryAtLevel = false;\n    prefixEncoded += key;\n    if (value.size > 1) {\n      prefixEncoded += '{';\n      prefixEncoded += prefixEncodeTrie(value);\n      prefixEncoded += '}';\n    } else {\n      prefixEncoded += prefixEncodeTrie(value);\n    }\n  });\n  return prefixEncoded;\n}\n\n/**\n * Sets the OS flag to \"unknown\" in order to ensure we get consistent results across operating systems.\n *\n * @see https://datatracker.ietf.org/doc/html/rfc1952#page-5\n *\n *   +---+---+---+---+---+---+---+---+---+---+\n *   |ID1|ID2|CM |FLG|     MTIME     |XFL|OS |\n *   +---+---+---+---+---+---+---+---+---+---+\n *   | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |\n *   +---+---+---+---+---+---+---+---+---+---+\n *\n * OS (Operating System)\n * =====================\n * This identifies the type of file system on which compression\n * took place.  This may be useful in determining end-of-line\n * convention for text files.  The currently defined values are\n * as follows:\n *      0 - FAT filesystem (MS-DOS, OS/2, NT/Win32)\n *      1 - Amiga\n *      2 - VMS (or OpenVMS)\n *      3 - Unix\n *      4 - VM/CMS\n *      5 - Atari TOS\n *      6 - HPFS filesystem (OS/2, NT)\n *      7 - Macintosh\n *      8 - Z-System\n *      9 - CP/M\n *     10 - TOPS-20\n *     11 - NTFS filesystem (NT)\n *     12 - QDOS\n *     13 - Acorn RISCOS\n *    255 - unknown\n *\n * @param gzipBuffer A gzip buffer\n */\nfunction setGzipOperatingSystemToUnknown(gzipBuffer: Buffer) {\n  // check that this is indeed a gzip buffer (https://datatracker.ietf.org/doc/html/rfc1952#page-6)\n  if (gzipBuffer[0] !== 0x1f || gzipBuffer[1] !== 0x8b) {\n    throw new Error('Expecting a gzip buffer (must start with 0x1f8b)');\n  }\n\n  gzipBuffer[9] = 255;\n}"],
  "mappings": "4HAAA,KAAA,MAAA,QAAA,MAAA,EACA,cAAA,QAAA,sBAAA,EACA,aAAA,QAAA,YAAA,EACA,gBAAA,QAAA,kBAAA,EACA,SAAA,QAAA,WAAA,EACA,aAAA,QAAA,eAAA,EACA,eAAA,QAAA,iBAAA,EACA,OAAA,QAAA,SAAA,EAEA,QAAA,QAAA,UAAA,EACA,eAAA,QAAA,gBAAA,EAKA,MAAa,wBAAyB,cAAA,SAAS,CAC7C,YAAY,MAAc,GAAU,CAClC,MAAM,MAAO,EAAE,EAGf,GAD8B,QAAA,MAAM,aAAa,MAAM,MAAM,GAAK,cAAA,WAAW,IAAI,MAAM,MAAM,EAAE,6BACpE,CACzB,KAAM,UAAW,GAAI,gBAAA,YAAY,KAAM,UAAW,CAChD,KAAM,qBACN,WAAY,CACV,UAAW,OAAA,KAAK,OAAO,CAAE,QAAS,IAAM,gBAAgB,eAAA,uBAAuB,KAAK,CAAC,CAAC,CAAE,GAE3F,EAGD,GAAI,QAAA,MAAM,aAAa,MAAM,MAAM,EAAG,CACpC,KAAM,WAAY,GAAI,iBAAA,aAAa,KAAM,YAAa,CACpD,WAAY,kCAAiC,EAC9C,EAGD,UAAU,kBAAkB,sBAAsB,EAElD,SAAS,WAAW,UAAY,aAtBxC,QAAA,iBAAA,iBA4BA,4CAA0C,CACxC,MAAO,UAAA,GAAG,YAAY,GAAG,cAAA,WAAW,QACjC,OAAO,IAAM,GAAG,4BAA4B,EAC5C,IAAI,IAAM,SAAA,GAAG,gBAAgB,aAAA,IAAI,OAAQ,GAAG,IAAI,CAAC,CAAC,CACvD,CAGA,MAAM,YAAa,IAAiB,EAqBpC,yBAAgC,MAAsB,CACpD,KAAM,MAAO,GAAI,MACjB,MAAM,QAAQ,MAAQ,gBAAgB,GAAG,KAAK,WAAW,KAAK,MAAO,IAAI,CAAC,EAE1E,KAAM,4BAA6B,iBAAiB,IAAI,EAClD,2BAA6B,KAAK,SAAS,OAAO,KAAK,0BAA0B,CAAC,EAIxF,uCAAgC,0BAA0B,EAGnD,gBADsB,2BAA2B,SAAS,QAAQ,GAE3E,CAbA,QAAA,gBAAA,gBAmBA,yBAAyB,IAAa,KAAU,QAC9C,SAAW,WAAW,KAAI,QAAQ,cAAe,KAAK,EAAE,MAAM,GAAG,EAAG,CAClE,KAAM,kBAAgB,IAAG,KAAK,IAAI,OAAO,KAAC,MAAA,KAAA,OAAA,GAAI,GAAI,MAClD,KAAK,IAAI,QAAS,gBAAgB,EAClC,KAAO,iBAET,MAAO,KACT,CAgBA,0BAA0B,KAAU,CAClC,GAAI,eAAgB,GAChB,oBAAsB,GAC1B,OAAC,GAAG,KAAK,QAAO,CAAE,EAAE,QAAQ,CAAC,CAAC,IAAK,SAAU,CAC3C,AAAK,qBACH,gBAAiB,KAEnB,oBAAsB,GACtB,eAAiB,IACjB,AAAI,MAAM,KAAO,EACf,gBAAiB,IACjB,eAAiB,iBAAiB,KAAK,EACvC,eAAiB,KAEjB,eAAiB,iBAAiB,KAAK,CAE3C,CAAC,EACM,aACT,CAqCA,yCAAyC,WAAkB,CAEzD,GAAI,WAAW,KAAO,IAAQ,WAAW,KAAO,IAC9C,KAAM,IAAI,OAAM,kDAAkD,EAGpE,WAAW,GAAK,GAClB",
  "names": []
}
