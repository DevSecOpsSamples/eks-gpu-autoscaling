{
  "version": 3,
  "sources": ["region-lookup.ts"],
  "sourcesContent": ["import * as cxapi from '../../../cx-api';\nimport { RegionInfo } from '../../../region-info';\nimport { CfnMapping } from '../cfn-mapping';\nimport { Aws } from '../cfn-pseudo';\nimport { Stack } from '../stack';\n\n/**\n * Make sure a CfnMapping exists in the given stack with the lookup values for the given fact\n *\n * Add to an existing CfnMapping if possible.\n */\nexport function deployTimeLookup(stack: Stack, factName: string, lookupMap: Record<string, string>, defaultValue?: string) {\n  // If there are no lookups, just return the default\n  if (Object.values(lookupMap).length === 0) {\n    if (defaultValue === undefined) {\n      throw new Error(`region-info: don't have any information for ${factName}. Use 'Fact.register' to provide values, or add partitions to the '${cxapi.TARGET_PARTITIONS}' context value.`);\n    }\n    return defaultValue;\n  }\n\n  // If the tokenized representation of all values is the same, we can just\n  // return the value directly and don't need to produce an actual map.\n  const pattern = findValuePattern(lookupMap);\n  if (pattern !== undefined) {\n    return pattern;\n  }\n\n  // Derive map name and lookup key from the factName, splitting on ':' if it exists\n  const [factClass, factParam] = factName.includes(':')\n    ? factName.split(':')\n    : [factName, 'value'] as const;\n\n  const mapId = `${ucfirst(factClass)}Map`;\n  const factKey = factParam.replace(/[^a-zA-Z0-9]/g, 'x');\n\n  let mapping = stack.node.tryFindChild(mapId) as CfnMapping | undefined;\n  if (!mapping) {\n    mapping = new CfnMapping(stack, mapId);\n  }\n  for (const [region, value] of Object.entries(lookupMap)) {\n    mapping.setValue(region, factKey, value);\n  }\n  return mapping.findInMap(Aws.REGION, factKey);\n}\n\nfunction ucfirst(x: string) {\n  return `${x.slice(0, 1).toUpperCase()}${x.slice(1)}`;\n}\n\n/**\n * Try to detect if all values in the map follow the same pattern\n *\n * Do this by replacing region and URLSuffix values in the found strings\n * with their token variant. If at the end all strings have the same format,\n * we can simplify to just the single value.\n *\n * This wouldn't have been necessary if the region-info library had encoded the\n * pattern information instead of the literal values... but let's do it here now.\n */\nfunction findValuePattern(regionMap: Record<string, string>): string | undefined {\n  const simplified: Record<string, string> = { ...regionMap };\n\n  // If they all contain URL_SUFFIX, substitute it, but only if the value is different\n  // among some values in the list (we don't want to tokenize unnecessarily, i.e. we don't\n  // want to replace `amazonaws.com` with URL_SUFFIX if it's not necessary)\n  const urlSuffixes = Object.keys(simplified).map(urlSuffix);\n  if (!allSame(urlSuffixes) && Object.entries(simplified).every(([region, value]) => value.includes(urlSuffix(region)))) {\n    for (const region in simplified) {\n      simplified[region] = replaceAll(simplified[region], urlSuffix(region), Aws.URL_SUFFIX);\n    }\n  }\n\n  // If they all contain REGION, substitute it (no need to do the \"is everything different\"\n  // check, this is true by design for these values)\n  if (Object.entries(simplified).every(([region, value]) => value.includes(region))) {\n    for (const region in simplified) {\n      simplified[region] = replaceAll(simplified[region], region, Aws.REGION);\n    }\n  }\n\n  // If the values are now all the same, return the singleton value\n  const values = Object.values(simplified);\n  if (allSame(values)) {\n    return values[0];\n  }\n\n  // Otherwise we failed\n  return undefined;\n}\n\nfunction allSame(xs: string[]) {\n  return xs.every((x) => x === xs[0]);\n}\n\nfunction urlSuffix(region: string) {\n  return RegionInfo.get(region)?.domainSuffix ?? 'amazonaws.com';\n}\n\nfunction replaceAll(x: string, pat: string, replacement: string) {\n  return x.split(pat).join(replacement);\n}\n\n"],
  "mappings": "oGAAA,KAAA,OAAA,QAAA,iBAAA,EACA,cAAA,QAAA,sBAAA,EACA,cAAA,QAAA,gBAAA,EACA,aAAA,QAAA,eAAA,EAQA,0BAAiC,MAAc,SAAkB,UAAmC,aAAqB,CAEvH,GAAI,OAAO,OAAO,SAAS,EAAE,SAAW,EAAG,CACzC,GAAI,eAAiB,OACnB,KAAM,IAAI,OAAM,+CAA+C,8EAA8E,MAAM,mCAAmC,EAExL,MAAO,cAKT,KAAM,SAAU,iBAAiB,SAAS,EAC1C,GAAI,UAAY,OACd,MAAO,SAIT,KAAM,CAAC,UAAW,WAAa,SAAS,SAAS,GAAG,EAChD,SAAS,MAAM,GAAG,EAClB,CAAC,SAAU,OAAO,EAEhB,MAAQ,GAAG,QAAQ,SAAS,OAC5B,QAAU,UAAU,QAAQ,gBAAiB,GAAG,EAEtD,GAAI,SAAU,MAAM,KAAK,aAAa,KAAK,EAC3C,AAAK,SACH,SAAU,GAAI,eAAA,WAAW,MAAO,KAAK,GAEvC,SAAW,CAAC,OAAQ,QAAU,QAAO,QAAQ,SAAS,EACpD,QAAQ,SAAS,OAAQ,QAAS,KAAK,EAEzC,MAAO,SAAQ,UAAU,aAAA,IAAI,OAAQ,OAAO,CAC9C,CAhCA,QAAA,iBAAA,iBAkCA,iBAAiB,EAAS,CACxB,MAAO,GAAG,EAAE,MAAM,EAAG,CAAC,EAAE,YAAW,IAAK,EAAE,MAAM,CAAC,GACnD,CAYA,0BAA0B,UAAiC,CACzD,KAAM,YAAqC,IAAK,SAAS,EAKnD,YAAc,OAAO,KAAK,UAAU,EAAE,IAAI,SAAS,EACzD,GAAI,CAAC,QAAQ,WAAW,GAAK,OAAO,QAAQ,UAAU,EAAE,MAAM,CAAC,CAAC,OAAQ,SAAW,MAAM,SAAS,UAAU,MAAM,CAAC,CAAC,EAClH,SAAW,UAAU,YACnB,WAAW,QAAU,WAAW,WAAW,QAAS,UAAU,MAAM,EAAG,aAAA,IAAI,UAAU,EAMzF,GAAI,OAAO,QAAQ,UAAU,EAAE,MAAM,CAAC,CAAC,OAAQ,SAAW,MAAM,SAAS,MAAM,CAAC,EAC9E,SAAW,UAAU,YACnB,WAAW,QAAU,WAAW,WAAW,QAAS,OAAQ,aAAA,IAAI,MAAM,EAK1E,KAAM,QAAS,OAAO,OAAO,UAAU,EACvC,GAAI,QAAQ,MAAM,EAChB,MAAO,QAAO,EAKlB,CAEA,iBAAiB,GAAY,CAC3B,MAAO,IAAG,MAAM,AAAC,GAAM,IAAM,GAAG,EAAE,CACpC,CAEA,mBAAmB,OAAc,WAC/B,MAAA,IAAA,IAAO,cAAA,WAAW,IAAI,MAAM,KAAC,MAAA,KAAA,OAAA,OAAA,GAAE,gBAAY,MAAA,KAAA,OAAA,GAAI,eACjD,CAEA,oBAAoB,EAAW,IAAa,YAAmB,CAC7D,MAAO,GAAE,MAAM,GAAG,EAAE,KAAK,WAAW,CACtC",
  "names": []
}
