{
  "version": 3,
  "sources": ["synthesis.ts"],
  "sourcesContent": ["import * as cxapi from '../../../cx-api';\nimport { IConstruct } from 'constructs';\nimport { Annotations } from '../annotations';\nimport { Aspects, IAspect } from '../aspect';\nimport { Stack } from '../stack';\nimport { ISynthesisSession } from '../stack-synthesizers/types';\nimport { Stage, StageSynthesisOptions } from '../stage';\nimport { MetadataResource } from './metadata-resource';\nimport { prepareApp } from './prepare-app';\nimport { TreeMetadata } from './tree-metadata';\n\n/**\n * Options for `synthesize()`\n */\nexport interface SynthesisOptions extends StageSynthesisOptions {\n  /**\n   * The output directory into which to synthesize the cloud assembly.\n   * @default - creates a temporary directory\n   */\n  readonly outdir?: string;\n}\n\nexport function synthesize(root: IConstruct, options: SynthesisOptions = { }): cxapi.CloudAssembly {\n  // we start by calling \"synth\" on all nested assemblies (which will take care of all their children)\n  synthNestedAssemblies(root, options);\n\n  invokeAspects(root);\n\n  injectMetadataResources(root);\n\n  // resolve references\n  prepareApp(root);\n\n  // give all children an opportunity to validate now that we've finished prepare\n  if (!options.skipValidation) {\n    validateTree(root);\n  }\n\n  // in unit tests, we support creating free-standing stacks, so we create the\n  // assembly builder here.\n  const builder = Stage.isStage(root)\n    ? root._assemblyBuilder\n    : new cxapi.CloudAssemblyBuilder(options.outdir);\n\n  // next, we invoke \"onSynthesize\" on all of our children. this will allow\n  // stacks to add themselves to the synthesized cloud assembly.\n  synthesizeTree(root, builder, options.validateOnSynthesis);\n\n  return builder.buildAssembly();\n}\n\nconst CUSTOM_SYNTHESIS_SYM = Symbol.for('@aws-cdk/core:customSynthesis');\n\n/**\n * Interface for constructs that want to do something custom during synthesis\n *\n * This feature is intended for use by official AWS CDK libraries only; 3rd party\n * library authors and CDK users should not use this function.\n */\nexport interface ICustomSynthesis {\n  /**\n   * Called when the construct is synthesized\n   */\n  onSynthesize(session: ISynthesisSession): void;\n}\n\nexport function addCustomSynthesis(construct: IConstruct, synthesis: ICustomSynthesis): void {\n  Object.defineProperty(construct, CUSTOM_SYNTHESIS_SYM, {\n    value: synthesis,\n    enumerable: false,\n  });\n}\n\nfunction getCustomSynthesis(construct: IConstruct): ICustomSynthesis | undefined {\n  return (construct as any)[CUSTOM_SYNTHESIS_SYM];\n}\n\n/**\n * Find Assemblies inside the construct and call 'synth' on them\n *\n * (They will in turn recurse again)\n */\nfunction synthNestedAssemblies(root: IConstruct, options: StageSynthesisOptions) {\n  for (const child of root.node.children) {\n    if (Stage.isStage(child)) {\n      child.synth(options);\n    } else {\n      synthNestedAssemblies(child, options);\n    }\n  }\n}\n\n/**\n * Invoke aspects on the given construct tree.\n *\n * Aspects are not propagated across Assembly boundaries. The same Aspect will not be invoked\n * twice for the same construct.\n */\nfunction invokeAspects(root: IConstruct) {\n  const invokedByPath: { [nodePath: string]: IAspect[] } = { };\n\n  let nestedAspectWarning = false;\n  recurse(root, []);\n\n  function recurse(construct: IConstruct, inheritedAspects: IAspect[]) {\n    const node = construct.node;\n    const aspects = Aspects.of(construct);\n    const allAspectsHere = [...inheritedAspects ?? [], ...aspects.all];\n    const nodeAspectsCount = aspects.all.length;\n    for (const aspect of allAspectsHere) {\n      let invoked = invokedByPath[node.path];\n      if (!invoked) {\n        invoked = invokedByPath[node.path] = [];\n      }\n\n      if (invoked.includes(aspect)) { continue; }\n\n      aspect.visit(construct);\n\n      // if an aspect was added to the node while invoking another aspect it will not be invoked, emit a warning\n      // the `nestedAspectWarning` flag is used to prevent the warning from being emitted for every child\n      if (!nestedAspectWarning && nodeAspectsCount !== aspects.all.length) {\n        Annotations.of(construct).addWarning('We detected an Aspect was added via another Aspect, and will not be applied');\n        nestedAspectWarning = true;\n      }\n\n      // mark as invoked for this node\n      invoked.push(aspect);\n    }\n\n    for (const child of construct.node.children) {\n      if (!Stage.isStage(child)) {\n        recurse(child, allAspectsHere);\n      }\n    }\n  }\n}\n\n/**\n * Find all stacks and add Metadata Resources to all of them\n *\n * There is no good generic place to do this. Can't do it in the constructor\n * (because adding a child construct makes it impossible to set context on the\n * node), and the generic prepare phase is deprecated.\n *\n * Only do this on [parent] stacks (not nested stacks), don't do this when\n * disabled by the user.\n *\n * Also, only when running via the CLI. If we do it unconditionally,\n * all unit tests everywhere are going to break massively. I've spent a day\n * fixing our own, but downstream users would be affected just as badly.\n *\n * Stop at Assembly boundaries.\n */\nfunction injectMetadataResources(root: IConstruct) {\n  visit(root, 'post', construct => {\n    if (!Stack.isStack(construct) || !construct._versionReportingEnabled) { return; }\n\n    // Because of https://github.com/aws/aws-cdk/blob/master/packages/assert-internal/lib/synth-utils.ts#L74\n    // synthesize() may be called more than once on a stack in unit tests, and the below would break\n    // if we execute it a second time. Guard against the constructs already existing.\n    const CDKMetadata = 'CDKMetadata';\n    if (construct.node.tryFindChild(CDKMetadata)) { return; }\n\n    new MetadataResource(construct, CDKMetadata);\n  });\n}\n\n/**\n * Synthesize children in post-order into the given builder\n *\n * Stop at Assembly boundaries.\n */\nfunction synthesizeTree(root: IConstruct, builder: cxapi.CloudAssemblyBuilder, validateOnSynth: boolean = false) {\n  visit(root, 'post', construct => {\n    const session = {\n      outdir: builder.outdir,\n      assembly: builder,\n      validateOnSynth,\n    };\n\n    if (Stack.isStack(construct)) {\n      construct.synthesizer.synthesize(session);\n    } else if (construct instanceof TreeMetadata) {\n      construct._synthesizeTree(session);\n    } else {\n      const custom = getCustomSynthesis(construct);\n      custom?.onSynthesize(session);\n    }\n  });\n}\n\ninterface ValidationError {\n  readonly message: string;\n  readonly source: IConstruct;\n}\n\n/**\n * Validate all constructs in the given construct tree\n */\nfunction validateTree(root: IConstruct) {\n  const errors = new Array<ValidationError>();\n\n  visit(root, 'pre', construct => {\n    for (const message of construct.node.validate()) {\n      errors.push({ message, source: construct });\n    }\n  });\n\n  if (errors.length > 0) {\n    const errorList = errors.map(e => `[${e.source.node.path}] ${e.message}`).join('\\n  ');\n    throw new Error(`Validation failed with the following errors:\\n  ${errorList}`);\n  }\n}\n\n/**\n * Visit the given construct tree in either pre or post order, stopping at Assemblies\n */\nfunction visit(root: IConstruct, order: 'pre' | 'post', cb: (x: IConstruct) => void) {\n  if (order === 'pre') {\n    cb(root);\n  }\n\n  for (const child of root.node.children) {\n    if (Stage.isStage(child)) { continue; }\n    visit(child, order, cb);\n  }\n\n  if (order === 'post') {\n    cb(root);\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
