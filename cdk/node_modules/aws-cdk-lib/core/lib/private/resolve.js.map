{
  "version": 3,
  "sources": ["resolve.ts"],
  "sourcesContent": ["import { IConstruct } from 'constructs';\nimport { DefaultTokenResolver, IPostProcessor, IResolvable, IResolveContext, ITokenResolver, ResolveChangeContextOptions, StringConcat } from '../resolvable';\nimport { TokenizedStringFragments } from '../string-fragments';\nimport { containsListTokenElement, TokenString, unresolved } from './encoding';\nimport { TokenMap } from './token-map';\n\n// This file should not be exported to consumers, resolving should happen through Construct.resolve()\nconst tokenMap = TokenMap.instance();\n\n/**\n * Resolved complex values will have a type hint applied.\n *\n * The type hint will be based on the type of the input value that was resolved.\n *\n * If the value was encoded, the type hint will be the type of the encoded value. In case\n * of a plain `IResolvable`, a type hint of 'string' will be assumed.\n */\nconst RESOLUTION_TYPEHINT_SYM = Symbol.for('@aws-cdk/core.resolvedTypeHint');\n\n/**\n * Prefix used for intrinsic keys\n *\n * If a key with this prefix is found in an object, the actual value of the\n * key doesn't matter. The value of this key will be an `[ actualKey, actualValue ]`\n * tuple, and the `actualKey` will be a value which otherwise couldn't be represented\n * in the types of `string | number | symbol`, which are the only possible JavaScript\n * object keys.\n */\nexport const INTRINSIC_KEY_PREFIX = '$IntrinsicKey$';\n\n/**\n * Type hints for resolved values\n */\nexport enum ResolutionTypeHint {\n  STRING = 'string',\n  NUMBER = 'number',\n  LIST = 'list',\n}\n\n/**\n * Options to the resolve() operation\n *\n * NOT the same as the ResolveContext; ResolveContext is exposed to Token\n * implementors and resolution hooks, whereas this struct is just to bundle\n * a number of things that would otherwise be arguments to resolve() in a\n * readable way.\n */\nexport interface IResolveOptions {\n  scope: IConstruct;\n  preparing: boolean;\n  resolver: ITokenResolver;\n  prefix?: string[];\n\n  /**\n   * Whether or not to allow intrinsics in keys of an object\n   *\n   * Because keys of an object must be strings, a (resolved) intrinsic, which\n   * is an object, cannot be stored in that position. By default, we reject these\n   * intrinsics if we encounter them.\n   *\n   * If this is set to `true`, in order to store the complex value in a map,\n   * keys that happen to evaluate to intrinsics will be added with a unique key\n   * identified by an uncomming prefix, mapped to a tuple that represents the\n   * actual key/value-pair. The map will look like this:\n   *\n   * {\n   *    '$IntrinsicKey$0': [ { Ref: ... }, 'value1' ],\n   *    '$IntrinsicKey$1': [ { Ref: ... }, 'value2' ],\n   *    'regularKey': 'value3',\n   *    ...\n   * }\n   *\n   * Callers should only set this option to `true` if they are prepared to deal with\n   * the object in this weird shape, and massage it back into a correct object afterwards.\n   *\n   * (A regular but uncommon string was chosen over something like symbols or\n   * other ways of tagging the extra values in order to simplify the implementation which\n   * maintains the desired behavior `resolve(resolve(x)) == resolve(x)`).\n   *\n   * @default false\n   */\n  allowIntrinsicKeys?: boolean;\n\n  /**\n   * Whether to remove undefined elements from arrays and objects when resolving.\n   *\n   * @default true\n   */\n  removeEmpty?: boolean;\n}\n\n/**\n * Resolves an object by evaluating all tokens and removing any undefined or empty objects or arrays.\n * Values can only be primitives, arrays or tokens. Other objects (i.e. with methods) will be rejected.\n *\n * @param obj The object to resolve.\n * @param prefix Prefix key path components for diagnostics.\n */\nexport function resolve(obj: any, options: IResolveOptions): any {\n  const prefix = options.prefix || [];\n  const pathName = '/' + prefix.join('/');\n\n  /**\n   * Make a new resolution context\n   */\n  function makeContext(appendPath?: string): [IResolveContext, IPostProcessor] {\n    const newPrefix = appendPath !== undefined ? prefix.concat([appendPath]) : options.prefix;\n\n    let postProcessor: IPostProcessor | undefined;\n\n    const context: IResolveContext = {\n      preparing: options.preparing,\n      scope: options.scope as IConstruct,\n      registerPostProcessor(pp) { postProcessor = pp; },\n      resolve(x: any, changeOptions?: ResolveChangeContextOptions) { return resolve(x, { ...options, ...changeOptions, prefix: newPrefix }); },\n    };\n\n    return [context, { postProcess(x) { return postProcessor ? postProcessor.postProcess(x, context) : x; } }];\n  }\n\n  // protect against cyclic references by limiting depth.\n  if (prefix.length > 200) {\n    throw new Error('Unable to resolve object tree with circular reference. Path: ' + pathName);\n  }\n\n  // whether to leave the empty elements when resolving - false by default\n  const leaveEmpty = options.removeEmpty === false;\n\n  //\n  // undefined\n  //\n\n  if (typeof(obj) === 'undefined') {\n    return undefined;\n  }\n\n  //\n  // null\n  //\n\n  if (obj === null) {\n    return null;\n  }\n\n  //\n  // functions - not supported (only tokens are supported)\n  //\n\n  if (typeof(obj) === 'function') {\n    throw new Error(`Trying to resolve a non-data object. Only token are supported for lazy evaluation. Path: ${pathName}. Object: ${obj}`);\n  }\n\n  //\n  // string - potentially replace all stringified Tokens\n  //\n  if (typeof(obj) === 'string') {\n    // If this is a \"list element\" Token, it should never occur by itself in string context\n    if (TokenString.forListToken(obj).test()) {\n      throw new Error('Found an encoded list token string in a scalar string context. Use \\'Fn.select(0, list)\\' (not \\'list[0]\\') to extract elements from token lists.');\n    }\n\n    // Otherwise look for a stringified Token in this object\n    const str = TokenString.forString(obj);\n    if (str.test()) {\n      const fragments = str.split(tokenMap.lookupToken.bind(tokenMap));\n      return tagResolvedValue(options.resolver.resolveString(fragments, makeContext()[0]), ResolutionTypeHint.STRING);\n    }\n    return obj;\n  }\n\n  //\n  // number - potentially decode Tokenized number\n  //\n  if (typeof(obj) === 'number') {\n    return tagResolvedValue(resolveNumberToken(obj, makeContext()[0]), ResolutionTypeHint.NUMBER);\n  }\n\n  //\n  // primitives - as-is\n  //\n\n  if (typeof(obj) !== 'object' || obj instanceof Date) {\n    return obj;\n  }\n\n  //\n  // arrays - resolve all values, remove undefined and remove empty arrays\n  //\n\n  if (Array.isArray(obj)) {\n    if (containsListTokenElement(obj)) {\n      return tagResolvedValue(options.resolver.resolveList(obj, makeContext()[0]), ResolutionTypeHint.LIST);\n    }\n\n    const arr = obj\n      .map((x, i) => makeContext(`${i}`)[0].resolve(x))\n      .filter(x => leaveEmpty || typeof(x) !== 'undefined');\n\n    return arr;\n  }\n\n  //\n  // tokens - invoke 'resolve' and continue to resolve recursively\n  //\n\n  if (unresolved(obj)) {\n    const [context, postProcessor] = makeContext();\n    const ret = tagResolvedValue(options.resolver.resolveToken(obj, context, postProcessor), ResolutionTypeHint.STRING);\n    return ret;\n  }\n\n  //\n  // objects - deep-resolve all values\n  //\n\n  // Must not be a Construct at this point, otherwise you probably made a typo\n  // mistake somewhere and resolve will get into an infinite loop recursing into\n  // child.parent <---> parent.children\n  if (isConstruct(obj)) {\n    throw new Error('Trying to resolve() a Construct at ' + pathName);\n  }\n\n  const result: any = { };\n  let intrinsicKeyCtr = 0;\n  for (const key of Object.keys(obj)) {\n    const value = makeContext(String(key))[0].resolve(obj[key]);\n\n    // skip undefined\n    if (typeof(value) === 'undefined') {\n      if (leaveEmpty) {\n        result[key] = undefined;\n      }\n      continue;\n    }\n\n    // Simple case -- not an unresolved key\n    if (!unresolved(key)) {\n      result[key] = value;\n      continue;\n    }\n\n    const resolvedKey = makeContext()[0].resolve(key);\n    if (typeof(resolvedKey) === 'string') {\n      result[resolvedKey] = value;\n    } else {\n      if (!options.allowIntrinsicKeys) {\n        // eslint-disable-next-line max-len\n        throw new Error(`\"${String(key)}\" is used as the key in a map so must resolve to a string, but it resolves to: ${JSON.stringify(resolvedKey)}. Consider using \"CfnJson\" to delay resolution to deployment-time`);\n      }\n\n      // Can't represent this object in a JavaScript key position, but we can store it\n      // in value position. Use a unique symbol as the key.\n      result[`${INTRINSIC_KEY_PREFIX}${intrinsicKeyCtr++}`] = [resolvedKey, value];\n    }\n  }\n\n  // Because we may be called to recurse on already resolved values (that already have type hints applied)\n  // and we just copied those values into a fresh object, be sure to retain any type hints.\n  const previousTypeHint = resolvedTypeHint(obj);\n  return previousTypeHint ? tagResolvedValue(result, previousTypeHint) : result;\n}\n\n/**\n * Find all Tokens that are used in the given structure\n */\nexport function findTokens(scope: IConstruct, fn: () => any): IResolvable[] {\n  const resolver = new RememberingTokenResolver(new StringConcat());\n\n  resolve(fn(), { scope, prefix: [], resolver, preparing: true });\n\n  return resolver.tokens;\n}\n\n/**\n * Remember all Tokens encountered while resolving\n */\nexport class RememberingTokenResolver extends DefaultTokenResolver {\n  private readonly tokensSeen = new Set<IResolvable>();\n\n  public resolveToken(t: IResolvable, context: IResolveContext, postProcessor: IPostProcessor) {\n    this.tokensSeen.add(t);\n    return super.resolveToken(t, context, postProcessor);\n  }\n\n  public resolveString(s: TokenizedStringFragments, context: IResolveContext) {\n    const ret = super.resolveString(s, context);\n    return ret;\n  }\n\n  public get tokens(): IResolvable[] {\n    return Array.from(this.tokensSeen);\n  }\n}\n\n/**\n * Determine whether an object is a Construct\n *\n * Not in 'construct.ts' because that would lead to a dependency cycle via 'uniqueid.ts',\n * and this is a best-effort protection against a common programming mistake anyway.\n */\nfunction isConstruct(x: any): boolean {\n  return x._children !== undefined && x._metadata !== undefined;\n}\n\nfunction resolveNumberToken(x: number, context: IResolveContext): any {\n  const token = TokenMap.instance().lookupNumberToken(x);\n  if (token === undefined) { return x; }\n  return context.resolve(token);\n}\n\n/**\n * Apply a type hint to a resolved value\n *\n * The type hint will only be applied to objects.\n *\n * These type hints are used for correct JSON-ification of intrinsic values.\n */\nfunction tagResolvedValue(value: any, typeHint: ResolutionTypeHint): any {\n  if (typeof value !== 'object' || value == null) { return value; }\n  Object.defineProperty(value, RESOLUTION_TYPEHINT_SYM, {\n    value: typeHint,\n    configurable: true,\n  });\n  return value;\n}\n\n/**\n * Return the type hint from the given value\n *\n * If the value is not a resolved value (i.e, the result of resolving a token),\n * `undefined` will be returned.\n *\n * These type hints are used for correct JSON-ification of intrinsic values.\n */\nexport function resolvedTypeHint(value: any): ResolutionTypeHint | undefined {\n  if (typeof value !== 'object' || value == null) { return undefined; }\n  return value[RESOLUTION_TYPEHINT_SYM];\n}\n"],
  "mappings": "gOACA,KAAA,cAAA,QAAA,eAAA,EAEA,WAAA,QAAA,YAAA,EACA,YAAA,QAAA,aAAA,EAGM,SAAW,YAAA,SAAS,SAAQ,EAU5B,wBAA0B,OAAO,IAAI,gCAAgC,EAW9D,QAAA,qBAAuB,iBAKpC,GAAY,oBAAZ,AAAA,UAAY,oBAAkB,CAC5B,oBAAA,OAAA,SACA,oBAAA,OAAA,SACA,oBAAA,KAAA,MACF,GAJY,mBAAA,QAAA,oBAAA,SAAA,mBAAkB,CAAA,EAAA,EAiE9B,iBAAwB,IAAU,QAAwB,CACxD,KAAM,QAAS,QAAQ,QAAU,CAAA,EAC3B,SAAW,IAAM,OAAO,KAAK,GAAG,EAKtC,qBAAqB,WAAmB,CACtC,KAAM,WAAY,aAAe,OAAY,OAAO,OAAO,CAAC,UAAU,CAAC,EAAI,QAAQ,OAEnF,GAAI,eAEJ,KAAM,SAA2B,CAC/B,UAAW,QAAQ,UACnB,MAAO,QAAQ,MACf,sBAAsB,GAAE,CAAI,cAAgB,EAAG,EAC/C,QAAQ,EAAQ,cAA2C,CAAI,MAAO,SAAQ,EAAG,IAAK,WAAY,cAAe,OAAQ,SAAS,CAAE,CAAE,GAGxI,MAAO,CAAC,QAAS,CAAE,YAAY,EAAC,CAAI,MAAO,eAAgB,cAAc,YAAY,EAAG,OAAO,EAAI,CAAE,CAAE,CAAE,CAC3G,CAGA,GAAI,OAAO,OAAS,IAClB,KAAM,IAAI,OAAM,gEAAkE,QAAQ,EAI5F,KAAM,YAAa,QAAQ,cAAgB,GAM3C,GAAI,MAAO,MAAS,YAClB,OAOF,GAAI,MAAQ,KACV,MAAO,MAOT,GAAI,MAAO,MAAS,WAClB,KAAM,IAAI,OAAM,4FAA4F,qBAAqB,KAAK,EAMxI,GAAI,MAAO,MAAS,SAAU,CAE5B,GAAI,WAAA,YAAY,aAAa,GAAG,EAAE,KAAI,EACpC,KAAM,IAAI,OAAM,+IAAmJ,EAIrK,KAAM,KAAM,WAAA,YAAY,UAAU,GAAG,EACrC,GAAI,IAAI,KAAI,EAAI,CACd,KAAM,WAAY,IAAI,MAAM,SAAS,YAAY,KAAK,QAAQ,CAAC,EAC/D,MAAO,kBAAiB,QAAQ,SAAS,cAAc,UAAW,YAAW,EAAG,EAAE,EAAG,mBAAmB,MAAM,EAEhH,MAAO,KAMT,GAAI,MAAO,MAAS,SAClB,MAAO,kBAAiB,mBAAmB,IAAK,YAAW,EAAG,EAAE,EAAG,mBAAmB,MAAM,EAO9F,GAAI,MAAO,MAAS,UAAY,cAAe,MAC7C,MAAO,KAOT,GAAI,MAAM,QAAQ,GAAG,EACnB,MAAI,YAAA,yBAAyB,GAAG,EACvB,iBAAiB,QAAQ,SAAS,YAAY,IAAK,YAAW,EAAG,EAAE,EAAG,mBAAmB,IAAI,EAG1F,IACT,IAAI,CAAC,EAAG,IAAM,YAAY,GAAG,GAAG,EAAE,GAAG,QAAQ,CAAC,CAAC,EAC/C,OAAO,GAAK,YAAc,MAAO,IAAO,WAAW,EASxD,GAAI,WAAA,WAAW,GAAG,EAAG,CACnB,KAAM,CAAC,QAAS,eAAiB,YAAW,EAE5C,MADY,kBAAiB,QAAQ,SAAS,aAAa,IAAK,QAAS,aAAa,EAAG,mBAAmB,MAAM,EAWpH,GAAI,YAAY,GAAG,EACjB,KAAM,IAAI,OAAM,sCAAwC,QAAQ,EAGlE,KAAM,QAAc,CAAA,EACpB,GAAI,iBAAkB,EACtB,SAAW,OAAO,QAAO,KAAK,GAAG,EAAG,CAClC,KAAM,OAAQ,YAAY,OAAO,GAAG,CAAC,EAAE,GAAG,QAAQ,IAAI,IAAI,EAG1D,GAAI,MAAO,QAAW,YAAa,CACjC,AAAI,YACF,QAAO,KAAO,QAEhB,SAIF,GAAI,CAAC,WAAA,WAAW,GAAG,EAAG,CACpB,OAAO,KAAO,MACd,SAGF,KAAM,aAAc,YAAW,EAAG,GAAG,QAAQ,GAAG,EAChD,GAAI,MAAO,cAAiB,SAC1B,OAAO,aAAe,UACjB,CACL,GAAI,CAAC,QAAQ,mBAEX,KAAM,IAAI,OAAM,IAAI,OAAO,GAAG,mFAAmF,KAAK,UAAU,WAAW,oEAAoE,EAKjN,OAAO,GAAG,QAAA,uBAAuB,qBAAuB,CAAC,YAAa,KAAK,GAM/E,KAAM,kBAAmB,iBAAiB,GAAG,EAC7C,MAAO,kBAAmB,iBAAiB,OAAQ,gBAAgB,EAAI,MACzE,CAlKA,QAAA,QAAA,QAuKA,oBAA2B,MAAmB,GAAa,CACzD,KAAM,UAAW,GAAI,0BAAyB,GAAI,cAAA,YAAc,EAEhE,eAAQ,GAAE,EAAI,CAAE,MAAO,OAAQ,CAAA,EAAI,SAAU,UAAW,EAAI,CAAE,EAEvD,SAAS,MAClB,CANA,QAAA,WAAA,WAWA,MAAa,gCAAiC,cAAA,oBAAoB,CAAlE,aAAA,qBACmB,KAAA,WAAa,GAAI,IAepC,CAbS,aAAa,EAAgB,QAA0B,cAA6B,CACzF,YAAK,WAAW,IAAI,CAAC,EACd,MAAM,aAAa,EAAG,QAAS,aAAa,EAG9C,cAAc,EAA6B,QAAwB,CAExE,MADY,OAAM,cAAc,EAAG,OAAO,KAIjC,SAAM,CACf,MAAO,OAAM,KAAK,KAAK,UAAU,GAdrC,QAAA,yBAAA,yBAwBA,qBAAqB,EAAM,CACzB,MAAO,GAAE,YAAc,QAAa,EAAE,YAAc,MACtD,CAEA,4BAA4B,EAAW,QAAwB,CAC7D,KAAM,OAAQ,YAAA,SAAS,SAAQ,EAAG,kBAAkB,CAAC,EACrD,MAAI,SAAU,OAAoB,EAC3B,QAAQ,QAAQ,KAAK,CAC9B,CASA,0BAA0B,MAAY,SAA4B,CAChE,MAAI,OAAO,QAAU,UAAY,OAAS,MAC1C,OAAO,eAAe,MAAO,wBAAyB,CACpD,MAAO,SACP,aAAc,GACf,EACM,KACT,CAUA,0BAAiC,MAAU,CACzC,GAAI,QAAO,QAAU,UAAY,OAAS,MAC1C,MAAO,OAAM,wBACf,CAHA,QAAA,iBAAA",
  "names": []
}
