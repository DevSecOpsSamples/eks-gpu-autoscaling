{
  "version": 3,
  "sources": ["prepare-app.ts"],
  "sourcesContent": ["import { ConstructOrder, Dependable, IConstruct } from 'constructs';\nimport { CfnResource } from '../cfn-resource';\nimport { Stack } from '../stack';\nimport { Stage } from '../stage';\nimport { resolveReferences } from './refs';\n\n/**\n * Prepares the app for synthesis. This function is called by the root `prepare`\n * (normally this the App, but if a Stack is a root, it is called by the stack),\n * which means it's the last 'prepare' that executes.\n *\n * It takes care of reifying cross-references between stacks (or nested stacks),\n * and of creating assets for nested stack templates.\n *\n * @param root The root of the construct tree.\n */\nexport function prepareApp(root: IConstruct) {\n  // apply dependencies between resources in depending subtrees\n  for (const dependency of findTransitiveDeps(root)) {\n    const targetCfnResources = findCfnResources(dependency.target);\n    const sourceCfnResources = findCfnResources(dependency.source);\n\n    for (const target of targetCfnResources) {\n      for (const source of sourceCfnResources) {\n        source.addDependsOn(target);\n      }\n    }\n  }\n\n  resolveReferences(root);\n\n  // depth-first (children first) queue of nested stacks. We will pop a stack\n  // from the head of this queue to prepare its template asset.\n  //\n  // Depth-first since the a nested stack's template hash will be reflected in\n  // its parent's template, which then changes the parent's hash, etc.\n  const queue = findAllNestedStacks(root);\n\n  if (queue.length > 0) {\n    while (queue.length > 0) {\n      const nested = queue.shift()!;\n      defineNestedStackAsset(nested);\n    }\n\n    // \u25B7[ Given the legacy synthesizer and a 3-or-deeper nesting of nested stacks ]\n    //\n    // Adding nested stack assets may haved added CfnParameters to the top-level\n    // stack which are referenced in a deeper-level stack. The values of these\n    // parameters need to be carried through to the right location via Nested\n    // Stack parameters, which `resolveReferences()` will do.\n    //\n    // Yes, this may add `Parameter` elements to a template whose hash has\n    // already been calculated, but the invariant that if the functional part\n    // of the template changes its hash will change is still upheld.\n    resolveReferences(root);\n  }\n}\n\n/**\n * Prepares the assets for nested stacks in this app.\n * @returns `true` if assets were added to the parent of a nested stack, which\n * implies that another round of reference resolution is in order. If this\n * function returns `false`, we know we are done.\n */\nfunction defineNestedStackAsset(nestedStack: Stack) {\n  // this is needed temporarily until we move NestedStack to '@aws-cdk/core'.\n  const nested: INestedStackPrivateApi = nestedStack as any;\n  nested._prepareTemplateAsset();\n}\n\nfunction findAllNestedStacks(root: IConstruct) {\n  const result = new Array<Stack>();\n\n  const includeStack = (stack: IConstruct): stack is Stack => {\n    if (!Stack.isStack(stack)) { return false; }\n    if (!stack.nested) { return false; }\n\n    // test: if we are not within a stage, then include it.\n    if (!Stage.of(stack)) { return true; }\n\n    return Stage.of(stack) === root;\n  };\n\n  // create a list of all nested stacks in depth-first post order this means\n  // that we first prepare the leaves and then work our way up.\n  for (const stack of root.node.findAll(ConstructOrder.POSTORDER /* <== important */)) {\n    if (includeStack(stack)) {\n      result.push(stack);\n    }\n  }\n\n  return result;\n}\n\n/**\n * Find all resources in a set of constructs\n */\nfunction findCfnResources(root: IConstruct): CfnResource[] {\n  return root.node.findAll().filter(CfnResource.isCfnResource);\n}\n\ninterface INestedStackPrivateApi {\n  _prepareTemplateAsset(): boolean;\n}\n\n/**\n * Return all dependencies registered on this node or any of its children\n */\nfunction findTransitiveDeps(root: IConstruct): Dependency[] {\n  const found = new Map<IConstruct, Set<IConstruct>>(); // Deduplication map\n  const ret = new Array<Dependency>();\n\n  for (const source of root.node.findAll()) {\n    for (const dependable of source.node.dependencies) {\n      for (const target of Dependable.of(dependable).dependencyRoots) {\n        let foundTargets = found.get(source);\n        if (!foundTargets) { found.set(source, foundTargets = new Set()); }\n\n        if (!foundTargets.has(target)) {\n          ret.push({ source, target });\n          foundTargets.add(target);\n        }\n      }\n    }\n  }\n\n  return ret;\n}\n\n\ninterface Dependency {\n  readonly source: IConstruct;\n  readonly target: IConstruct;\n}\n"],
  "mappings": "8FAAA,KAAA,cAAA,QAAA,YAAA,EACA,eAAA,QAAA,iBAAA,EACA,QAAA,QAAA,UAAA,EACA,QAAA,QAAA,UAAA,EACA,OAAA,QAAA,QAAA,EAYA,oBAA2B,KAAgB,CAEzC,SAAW,cAAc,oBAAmB,IAAI,EAAG,CACjD,KAAM,oBAAqB,iBAAiB,WAAW,MAAM,EACvD,mBAAqB,iBAAiB,WAAW,MAAM,EAE7D,SAAW,UAAU,oBACnB,SAAW,UAAU,oBACnB,OAAO,aAAa,MAAM,EAKhC,OAAA,kBAAkB,IAAI,EAOtB,KAAM,OAAQ,oBAAoB,IAAI,EAEtC,GAAI,MAAM,OAAS,EAAG,CACpB,KAAO,MAAM,OAAS,GAAG,CACvB,KAAM,QAAS,MAAM,MAAK,EAC1B,uBAAuB,MAAM,EAa/B,OAAA,kBAAkB,IAAI,EAE1B,CAxCA,QAAA,WAAA,WAgDA,gCAAgC,YAAkB,CAGhD,AADuC,YAChC,sBAAqB,CAC9B,CAEA,6BAA6B,KAAgB,CAC3C,KAAM,QAAS,GAAI,OAEb,aAAe,AAAC,OAChB,CAAC,QAAA,MAAM,QAAQ,KAAK,GACpB,CAAC,MAAM,OAAiB,GAGvB,QAAA,MAAM,GAAG,KAAK,EAEZ,QAAA,MAAM,GAAG,KAAK,IAAM,KAFI,GAOjC,SAAW,SAAS,MAAK,KAAK,QAAQ,aAAA,eAAe,SAA6B,EAChF,AAAI,aAAa,KAAK,GACpB,OAAO,KAAK,KAAK,EAIrB,MAAO,OACT,CAKA,0BAA0B,KAAgB,CACxC,MAAO,MAAK,KAAK,QAAO,EAAG,OAAO,eAAA,YAAY,aAAa,CAC7D,CASA,4BAA4B,KAAgB,CAC1C,KAAM,OAAQ,GAAI,KACZ,IAAM,GAAI,OAEhB,SAAW,UAAU,MAAK,KAAK,QAAO,EACpC,SAAW,cAAc,QAAO,KAAK,aACnC,SAAW,UAAU,cAAA,WAAW,GAAG,UAAU,EAAE,gBAAiB,CAC9D,GAAI,cAAe,MAAM,IAAI,MAAM,EACnC,AAAK,cAAgB,MAAM,IAAI,OAAQ,aAAe,GAAI,IAAK,EAE1D,aAAa,IAAI,MAAM,GAC1B,KAAI,KAAK,CAAE,OAAQ,MAAM,CAAE,EAC3B,aAAa,IAAI,MAAM,GAM/B,MAAO,IACT",
  "names": []
}
