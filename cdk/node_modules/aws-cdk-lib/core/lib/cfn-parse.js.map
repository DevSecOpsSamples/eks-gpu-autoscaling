{
  "version": 3,
  "sources": ["cfn-parse.ts"],
  "sourcesContent": ["import { CfnCondition } from './cfn-condition';\nimport { CfnElement } from './cfn-element';\nimport { Fn } from './cfn-fn';\nimport { CfnMapping } from './cfn-mapping';\nimport { Aws } from './cfn-pseudo';\nimport { CfnResource } from './cfn-resource';\nimport {\n  CfnAutoScalingReplacingUpdate, CfnAutoScalingRollingUpdate, CfnAutoScalingScheduledAction, CfnCodeDeployLambdaAliasUpdate,\n  CfnCreationPolicy, CfnDeletionPolicy, CfnResourceAutoScalingCreationPolicy, CfnResourceSignal, CfnUpdatePolicy,\n} from './cfn-resource-policy';\nimport { CfnTag } from './cfn-tag';\nimport { Lazy } from './lazy';\nimport { CfnReference, ReferenceRendering } from './private/cfn-reference';\nimport { IResolvable } from './resolvable';\nimport { Validator } from './runtime';\nimport { isResolvableObject, Token } from './token';\nimport { undefinedIfAllValuesAreEmpty } from './util';\n\n/**\n * The class used as the intermediate result from the generated L1 methods\n * that convert from CloudFormation's UpperCase to CDK's lowerCase property names.\n * Saves any extra properties that were present in the argument object,\n * but that were not found in the CFN schema,\n * so that they're not lost from the final CDK-rendered template.\n */\nexport class FromCloudFormationResult<T> {\n  public readonly value: T;\n  public readonly extraProperties: { [key: string]: any };\n\n  public constructor(value: T) {\n    this.value = value;\n    this.extraProperties = {};\n  }\n\n  public appendExtraProperties(prefix: string, properties: { [key: string]: any } | undefined): void {\n    for (const [key, val] of Object.entries(properties ?? {})) {\n      this.extraProperties[`${prefix}.${key}`] = val;\n    }\n  }\n}\n\n/**\n * A property object we will accumulate properties into\n */\nexport class FromCloudFormationPropertyObject<T extends Record<string, any>> extends FromCloudFormationResult<T> {\n  private readonly recognizedProperties = new Set<string>();\n\n  public constructor() {\n    super({} as any); // We're still accumulating\n  }\n\n  /**\n   * Add a parse result under a given key\n   */\n  public addPropertyResult(cdkPropName: keyof T, cfnPropName: string, result?: FromCloudFormationResult<any>): void {\n    this.recognizedProperties.add(cfnPropName);\n    if (!result) { return; }\n    this.value[cdkPropName] = result.value;\n    this.appendExtraProperties(cfnPropName, result.extraProperties);\n  }\n\n  public addUnrecognizedPropertiesAsExtra(properties: object): void {\n    for (const [key, val] of Object.entries(properties)) {\n      if (!this.recognizedProperties.has(key)) {\n        this.extraProperties[key] = val;\n      }\n    }\n  }\n}\n\n/**\n * This class contains static methods called when going from\n * translated values received from {@link CfnParser.parseValue}\n * to the actual L1 properties -\n * things like changing IResolvable to the appropriate type\n * (string, string array, or number), etc.\n *\n * While this file not exported from the module\n * (to not make it part of the public API),\n * it is directly referenced in the generated L1 code.\n *\n */\nexport class FromCloudFormation {\n  // nothing to for any but return it\n  public static getAny(value: any): FromCloudFormationResult<any> {\n    return new FromCloudFormationResult(value);\n  }\n\n  public static getBoolean(value: any): FromCloudFormationResult<boolean | IResolvable> {\n    if (typeof value === 'string') {\n      // CloudFormation allows passing strings as boolean\n      switch (value) {\n        case 'true': return new FromCloudFormationResult(true);\n        case 'false': return new FromCloudFormationResult(false);\n        default: throw new Error(`Expected 'true' or 'false' for boolean value, got: '${value}'`);\n      }\n    }\n\n    // in all other cases, just return the value,\n    // and let a validator handle if it's not a boolean\n    return new FromCloudFormationResult(value);\n  }\n\n  public static getDate(value: any): FromCloudFormationResult<Date | IResolvable> {\n    // if the date is a deploy-time value, just return it\n    if (isResolvableObject(value)) {\n      return new FromCloudFormationResult(value);\n    }\n\n    // if the date has been given as a string, convert it\n    if (typeof value === 'string') {\n      return new FromCloudFormationResult(new Date(value));\n    }\n\n    // all other cases - just return the value,\n    // if it's not a Date, a validator should catch it\n    return new FromCloudFormationResult(value);\n  }\n\n  // won't always return a string; if the input can't be resolved to a string,\n  // the input will be returned.\n  public static getString(value: any): FromCloudFormationResult<string> {\n    // if the string is a deploy-time value, serialize it to a Token\n    if (isResolvableObject(value)) {\n      return new FromCloudFormationResult(value.toString());\n    }\n\n    // CloudFormation treats numbers and strings interchangeably;\n    // so, if we get a number here, convert it to a string\n    if (typeof value === 'number') {\n      return new FromCloudFormationResult(value.toString());\n    }\n\n    // CloudFormation treats booleans and strings interchangeably;\n    // so, if we get a boolean here, convert it to a string\n    if (typeof value === 'boolean') {\n      return new FromCloudFormationResult(value.toString());\n    }\n\n    // in all other cases, just return the input,\n    // and let a validator handle it if it's not a string\n    return new FromCloudFormationResult(value);\n  }\n\n  // won't always return a number; if the input can't be parsed to a number,\n  // the input will be returned.\n  public static getNumber(value: any): FromCloudFormationResult<number> {\n    // if the string is a deploy-time value, serialize it to a Token\n    if (isResolvableObject(value)) {\n      return new FromCloudFormationResult(Token.asNumber(value));\n    }\n\n    // return a number, if the input can be parsed as one\n    if (typeof value === 'string') {\n      const parsedValue = parseFloat(value);\n      if (!isNaN(parsedValue)) {\n        return new FromCloudFormationResult(parsedValue);\n      }\n    }\n\n    // otherwise return the input,\n    // and let a validator handle it if it's not a number\n    return new FromCloudFormationResult(value);\n  }\n\n  public static getStringArray(value: any): FromCloudFormationResult<string[]> {\n    // if the array is a deploy-time value, serialize it to a Token\n    if (isResolvableObject(value)) {\n      return new FromCloudFormationResult(Token.asList(value));\n    }\n\n    // in all other cases, delegate to the standard mapping logic\n    return this.getArray(this.getString)(value);\n  }\n\n  public static getArray<T>(mapper: (arg: any) => FromCloudFormationResult<T>): (x: any) => FromCloudFormationResult<T[]> {\n    return (value: any) => {\n      if (!Array.isArray(value)) {\n        // break the type system, and just return the given value,\n        // which hopefully will be reported as invalid by the validator\n        // of the property we're transforming\n        // (unless it's a deploy-time value,\n        // which we can't map over at build time anyway)\n        return new FromCloudFormationResult(value);\n      }\n\n      const values = new Array<any>();\n      const ret = new FromCloudFormationResult(values);\n      for (let i = 0; i < value.length; i++) {\n        const result = mapper(value[i]);\n        values.push(result.value);\n        ret.appendExtraProperties(`${i}`, result.extraProperties);\n      }\n      return ret;\n    };\n  }\n\n  public static getMap<T>(mapper: (arg: any) => FromCloudFormationResult<T>): (x: any) => FromCloudFormationResult<{ [key: string]: T }> {\n    return (value: any) => {\n      if (typeof value !== 'object') {\n        // if the input is not a map (= object in JS land),\n        // just return it, and let the validator of this property handle it\n        // (unless it's a deploy-time value,\n        // which we can't map over at build time anyway)\n        return new FromCloudFormationResult(value);\n      }\n\n      const values: { [key: string]: T } = {};\n      const ret = new FromCloudFormationResult(values);\n      for (const [key, val] of Object.entries(value)) {\n        const result = mapper(val);\n        values[key] = result.value;\n        ret.appendExtraProperties(key, result.extraProperties);\n      }\n      return ret;\n    };\n  }\n\n  public static getCfnTag(tag: any): FromCloudFormationResult<CfnTag> {\n    return tag == null\n      ? new FromCloudFormationResult({ } as any) // break the type system - this should be detected at runtime by a tag validator\n      : new FromCloudFormationResult({\n        key: tag.Key,\n        value: tag.Value,\n      });\n  }\n\n  /**\n   * Return a function that, when applied to a value, will return the first validly deserialized one\n   */\n  public static getTypeUnion(validators: Validator[], mappers: Array<(x: any) => FromCloudFormationResult<any>>):\n  (x: any) => FromCloudFormationResult<any> {\n    return (value: any) => {\n      for (let i = 0; i < validators.length; i++) {\n        const candidate = mappers[i](value);\n        if (validators[i](candidate.value).isSuccess) {\n          return candidate;\n        }\n      }\n\n      // if nothing matches, just return the input unchanged, and let validators catch it\n      return new FromCloudFormationResult(value);\n    };\n  }\n}\n\n/**\n * An interface that represents callbacks into a CloudFormation template.\n * Used by the fromCloudFormation methods in the generated L1 classes.\n */\nexport interface ICfnFinder {\n  /**\n   * Return the Condition with the given name from the template.\n   * If there is no Condition with that name in the template,\n   * returns undefined.\n   */\n  findCondition(conditionName: string): CfnCondition | undefined;\n\n  /**\n   * Return the Mapping with the given name from the template.\n   * If there is no Mapping with that name in the template,\n   * returns undefined.\n   */\n  findMapping(mappingName: string): CfnMapping | undefined;\n\n  /**\n   * Returns the element referenced using a Ref expression with the given name.\n   * If there is no element with this name in the template,\n   * return undefined.\n   */\n  findRefTarget(elementName: string): CfnElement | undefined;\n\n  /**\n   * Returns the resource with the given logical ID in the template.\n   * If a resource with that logical ID was not found in the template,\n   * returns undefined.\n   */\n  findResource(logicalId: string): CfnResource | undefined;\n}\n\n/**\n * The interface used as the last argument to the fromCloudFormation\n * static method of the generated L1 classes.\n */\nexport interface FromCloudFormationOptions {\n  /**\n   * The parser used to convert CloudFormation to values the CDK understands.\n   */\n  readonly parser: CfnParser;\n}\n\n/**\n * The context in which the parsing is taking place.\n *\n * Some fragments of CloudFormation templates behave differently than others\n * (for example, the 'Conditions' sections treats { \"Condition\": \"NameOfCond\" }\n * differently than the 'Resources' section).\n * This enum can be used to change the created {@link CfnParser} behavior,\n * based on the template context.\n */\nexport enum CfnParsingContext {\n  /** We're currently parsing the 'Conditions' section. */\n  CONDITIONS,\n\n  /** We're currently parsing the 'Rules' section. */\n  RULES,\n}\n\n/**\n * The options for {@link FromCloudFormation.parseValue}.\n */\nexport interface ParseCfnOptions {\n  /**\n   * The finder interface used to resolve references in the template.\n   */\n  readonly finder: ICfnFinder;\n\n  /**\n   * The context we're parsing the template in.\n   *\n   * @default - the default context (no special behavior)\n   */\n  readonly context?: CfnParsingContext;\n\n  /**\n   * Values provided here will replace references to parameters in the parsed template.\n   */\n  readonly parameters: { [parameterName: string]: any };\n}\n\n/**\n * This class contains methods for translating from a pure CFN value\n * (like a JS object { \"Ref\": \"Bucket\" })\n * to a form CDK understands\n * (like Fn.ref('Bucket')).\n *\n * While this file not exported from the module\n * (to not make it part of the public API),\n * it is directly referenced in the generated L1 code,\n * so any renames of it need to be reflected in cfn2ts/codegen.ts as well.\n *\n */\nexport class CfnParser {\n  private readonly options: ParseCfnOptions;\n\n  constructor(options: ParseCfnOptions) {\n    this.options = options;\n  }\n\n  public handleAttributes(resource: CfnResource, resourceAttributes: any, logicalId: string): void {\n    const cfnOptions = resource.cfnOptions;\n\n    cfnOptions.creationPolicy = this.parseCreationPolicy(resourceAttributes.CreationPolicy);\n    cfnOptions.updatePolicy = this.parseUpdatePolicy(resourceAttributes.UpdatePolicy);\n    cfnOptions.deletionPolicy = this.parseDeletionPolicy(resourceAttributes.DeletionPolicy);\n    cfnOptions.updateReplacePolicy = this.parseDeletionPolicy(resourceAttributes.UpdateReplacePolicy);\n    cfnOptions.version = this.parseValue(resourceAttributes.Version);\n    cfnOptions.description = this.parseValue(resourceAttributes.Description);\n    cfnOptions.metadata = this.parseValue(resourceAttributes.Metadata);\n\n    // handle Condition\n    if (resourceAttributes.Condition) {\n      const condition = this.finder.findCondition(resourceAttributes.Condition);\n      if (!condition) {\n        throw new Error(`Resource '${logicalId}' uses Condition '${resourceAttributes.Condition}' that doesn't exist`);\n      }\n      cfnOptions.condition = condition;\n    }\n\n    // handle DependsOn\n    resourceAttributes.DependsOn = resourceAttributes.DependsOn ?? [];\n    const dependencies: string[] = Array.isArray(resourceAttributes.DependsOn) ?\n      resourceAttributes.DependsOn : [resourceAttributes.DependsOn];\n    for (const dep of dependencies) {\n      const depResource = this.finder.findResource(dep);\n      if (!depResource) {\n        throw new Error(`Resource '${logicalId}' depends on '${dep}' that doesn't exist`);\n      }\n      resource.node.addDependency(depResource);\n    }\n  }\n\n  private parseCreationPolicy(policy: any): CfnCreationPolicy | undefined {\n    if (typeof policy !== 'object') { return undefined; }\n\n    // change simple JS values to their CDK equivalents\n    policy = this.parseValue(policy);\n\n    return undefinedIfAllValuesAreEmpty({\n      autoScalingCreationPolicy: parseAutoScalingCreationPolicy(policy.AutoScalingCreationPolicy),\n      resourceSignal: parseResourceSignal(policy.ResourceSignal),\n    });\n\n    function parseAutoScalingCreationPolicy(p: any): CfnResourceAutoScalingCreationPolicy | undefined {\n      if (typeof p !== 'object') { return undefined; }\n\n      return undefinedIfAllValuesAreEmpty({\n        minSuccessfulInstancesPercent: FromCloudFormation.getNumber(p.MinSuccessfulInstancesPercent).value,\n      });\n    }\n\n    function parseResourceSignal(p: any): CfnResourceSignal | undefined {\n      if (typeof p !== 'object') { return undefined; }\n\n      return undefinedIfAllValuesAreEmpty({\n        count: FromCloudFormation.getNumber(p.Count).value,\n        timeout: FromCloudFormation.getString(p.Timeout).value,\n      });\n    }\n  }\n\n  private parseUpdatePolicy(policy: any): CfnUpdatePolicy | undefined {\n    if (typeof policy !== 'object') { return undefined; }\n\n    // change simple JS values to their CDK equivalents\n    policy = this.parseValue(policy);\n\n    return undefinedIfAllValuesAreEmpty({\n      autoScalingReplacingUpdate: parseAutoScalingReplacingUpdate(policy.AutoScalingReplacingUpdate),\n      autoScalingRollingUpdate: parseAutoScalingRollingUpdate(policy.AutoScalingRollingUpdate),\n      autoScalingScheduledAction: parseAutoScalingScheduledAction(policy.AutoScalingScheduledAction),\n      codeDeployLambdaAliasUpdate: parseCodeDeployLambdaAliasUpdate(policy.CodeDeployLambdaAliasUpdate),\n      enableVersionUpgrade: FromCloudFormation.getBoolean(policy.EnableVersionUpgrade).value,\n      useOnlineResharding: FromCloudFormation.getBoolean(policy.UseOnlineResharding).value,\n    });\n\n    function parseAutoScalingReplacingUpdate(p: any): CfnAutoScalingReplacingUpdate | undefined {\n      if (typeof p !== 'object') { return undefined; }\n\n      return undefinedIfAllValuesAreEmpty({\n        willReplace: p.WillReplace,\n      });\n    }\n\n    function parseAutoScalingRollingUpdate(p: any): CfnAutoScalingRollingUpdate | undefined {\n      if (typeof p !== 'object') { return undefined; }\n\n      return undefinedIfAllValuesAreEmpty({\n        maxBatchSize: FromCloudFormation.getNumber(p.MaxBatchSize).value,\n        minInstancesInService: FromCloudFormation.getNumber(p.MinInstancesInService).value,\n        minSuccessfulInstancesPercent: FromCloudFormation.getNumber(p.MinSuccessfulInstancesPercent).value,\n        pauseTime: FromCloudFormation.getString(p.PauseTime).value,\n        suspendProcesses: FromCloudFormation.getStringArray(p.SuspendProcesses).value,\n        waitOnResourceSignals: FromCloudFormation.getBoolean(p.WaitOnResourceSignals).value,\n      });\n    }\n\n    function parseCodeDeployLambdaAliasUpdate(p: any): CfnCodeDeployLambdaAliasUpdate | undefined {\n      if (typeof p !== 'object') { return undefined; }\n\n      return {\n        beforeAllowTrafficHook: FromCloudFormation.getString(p.BeforeAllowTrafficHook).value,\n        afterAllowTrafficHook: FromCloudFormation.getString(p.AfterAllowTrafficHook).value,\n        applicationName: FromCloudFormation.getString(p.ApplicationName).value,\n        deploymentGroupName: FromCloudFormation.getString(p.DeploymentGroupName).value,\n      };\n    }\n\n    function parseAutoScalingScheduledAction(p: any): CfnAutoScalingScheduledAction | undefined {\n      if (typeof p !== 'object') { return undefined; }\n\n      return undefinedIfAllValuesAreEmpty({\n        ignoreUnmodifiedGroupSizeProperties: FromCloudFormation.getBoolean(p.IgnoreUnmodifiedGroupSizeProperties).value,\n      });\n    }\n  }\n\n  private parseDeletionPolicy(policy: any): CfnDeletionPolicy | undefined {\n    switch (policy) {\n      case null: return undefined;\n      case undefined: return undefined;\n      case 'Delete': return CfnDeletionPolicy.DELETE;\n      case 'Retain': return CfnDeletionPolicy.RETAIN;\n      case 'Snapshot': return CfnDeletionPolicy.SNAPSHOT;\n      default: throw new Error(`Unrecognized DeletionPolicy '${policy}'`);\n    }\n  }\n\n  public parseValue(cfnValue: any): any {\n    // == null captures undefined as well\n    if (cfnValue == null) {\n      return undefined;\n    }\n    // if we have any late-bound values,\n    // just return them\n    if (isResolvableObject(cfnValue)) {\n      return cfnValue;\n    }\n    if (Array.isArray(cfnValue)) {\n      return cfnValue.map(el => this.parseValue(el));\n    }\n    if (typeof cfnValue === 'object') {\n      // an object can be either a CFN intrinsic, or an actual object\n      const cfnIntrinsic = this.parseIfCfnIntrinsic(cfnValue);\n      if (cfnIntrinsic !== undefined) {\n        return cfnIntrinsic;\n      }\n      const ret: any = {};\n      for (const [key, val] of Object.entries(cfnValue)) {\n        ret[key] = this.parseValue(val);\n      }\n      return ret;\n    }\n    // in all other cases, just return the input\n    return cfnValue;\n  }\n\n  public get finder(): ICfnFinder {\n    return this.options.finder;\n  }\n\n  private parseIfCfnIntrinsic(object: any): any {\n    const key = this.looksLikeCfnIntrinsic(object);\n    switch (key) {\n      case undefined:\n        return undefined;\n      case 'Ref': {\n        const refTarget = object[key];\n        const specialRef = this.specialCaseRefs(refTarget);\n        if (specialRef !== undefined) {\n          return specialRef;\n        } else {\n          const refElement = this.finder.findRefTarget(refTarget);\n          if (!refElement) {\n            throw new Error(`Element used in Ref expression with logical ID: '${refTarget}' not found`);\n          }\n          return CfnReference.for(refElement, 'Ref');\n        }\n      }\n      case 'Fn::GetAtt': {\n        const value = object[key];\n        let logicalId: string, attributeName: string, stringForm: boolean;\n        // Fn::GetAtt takes as arguments either a string...\n        if (typeof value === 'string') {\n          // ...in which case the logical ID and the attribute name are separated with '.'\n          const dotIndex = value.indexOf('.');\n          if (dotIndex === -1) {\n            throw new Error(`Short-form Fn::GetAtt must contain a '.' in its string argument, got: '${value}'`);\n          }\n          logicalId = value.slice(0, dotIndex);\n          attributeName = value.slice(dotIndex + 1); // the +1 is to skip the actual '.'\n          stringForm = true;\n        } else {\n          // ...or a 2-element list\n          logicalId = value[0];\n          attributeName = value[1];\n          stringForm = false;\n        }\n        const target = this.finder.findResource(logicalId);\n        if (!target) {\n          throw new Error(`Resource used in GetAtt expression with logical ID: '${logicalId}' not found`);\n        }\n        return CfnReference.for(target, attributeName, stringForm ? ReferenceRendering.GET_ATT_STRING : undefined);\n      }\n      case 'Fn::Join': {\n        // Fn::Join takes a 2-element list as its argument,\n        // where the first element is the delimiter,\n        // and the second is the list of elements to join\n        const value = this.parseValue(object[key]);\n        // wrap the array as a Token,\n        // as otherwise Fn.join() will try to concatenate\n        // the non-token parts,\n        // causing a diff with the original template\n        return Fn.join(value[0], Lazy.list({ produce: () => value[1] }));\n      }\n      case 'Fn::Cidr': {\n        const value = this.parseValue(object[key]);\n        return Fn.cidr(value[0], value[1], value[2]);\n      }\n      case 'Fn::FindInMap': {\n        const value = this.parseValue(object[key]);\n        // the first argument to FindInMap is the mapping name\n        let mappingName: string;\n        if (Token.isUnresolved(value[0])) {\n          // the first argument can be a dynamic expression like Ref: Param;\n          // if it is, we can't find the mapping in advance\n          mappingName = value[0];\n        } else {\n          const mapping = this.finder.findMapping(value[0]);\n          if (!mapping) {\n            throw new Error(`Mapping used in FindInMap expression with name '${value[0]}' was not found in the template`);\n          }\n          mappingName = mapping.logicalId;\n        }\n        return Fn._findInMap(mappingName, value[1], value[2]);\n      }\n      case 'Fn::Select': {\n        const value = this.parseValue(object[key]);\n        return Fn.select(value[0], value[1]);\n      }\n      case 'Fn::GetAZs': {\n        const value = this.parseValue(object[key]);\n        return Fn.getAzs(value);\n      }\n      case 'Fn::ImportValue': {\n        const value = this.parseValue(object[key]);\n        return Fn.importValue(value);\n      }\n      case 'Fn::Split': {\n        const value = this.parseValue(object[key]);\n        return Fn.split(value[0], value[1]);\n      }\n      case 'Fn::Transform': {\n        const value = this.parseValue(object[key]);\n        return Fn.transform(value.Name, value.Parameters);\n      }\n      case 'Fn::Base64': {\n        const value = this.parseValue(object[key]);\n        return Fn.base64(value);\n      }\n      case 'Fn::If': {\n        // Fn::If takes a 3-element list as its argument,\n        // where the first element is the name of a Condition\n        const value = this.parseValue(object[key]);\n        const condition = this.finder.findCondition(value[0]);\n        if (!condition) {\n          throw new Error(`Condition '${value[0]}' used in an Fn::If expression does not exist in the template`);\n        }\n        return Fn.conditionIf(condition.logicalId, value[1], value[2]);\n      }\n      case 'Fn::Equals': {\n        const value = this.parseValue(object[key]);\n        return Fn.conditionEquals(value[0], value[1]);\n      }\n      case 'Fn::And': {\n        const value = this.parseValue(object[key]);\n        return Fn.conditionAnd(...value);\n      }\n      case 'Fn::Not': {\n        const value = this.parseValue(object[key]);\n        return Fn.conditionNot(value[0]);\n      }\n      case 'Fn::Or': {\n        const value = this.parseValue(object[key]);\n        return Fn.conditionOr(...value);\n      }\n      case 'Fn::Sub': {\n        const value = this.parseValue(object[key]);\n        let fnSubString: string;\n        let map: { [key: string]: any } | undefined;\n        if (typeof value === 'string') {\n          fnSubString = value;\n          map = undefined;\n        } else {\n          fnSubString = value[0];\n          map = value[1];\n        }\n\n        return this.parseFnSubString(fnSubString, map);\n      }\n      case 'Condition': {\n        // a reference to a Condition from another Condition\n        const condition = this.finder.findCondition(object[key]);\n        if (!condition) {\n          throw new Error(`Referenced Condition with name '${object[key]}' was not found in the template`);\n        }\n        return { Condition: condition.logicalId };\n      }\n      default:\n        if (this.options.context === CfnParsingContext.RULES) {\n          return this.handleRulesIntrinsic(key, object);\n        } else {\n          throw new Error(`Unsupported CloudFormation function '${key}'`);\n        }\n    }\n  }\n\n  private looksLikeCfnIntrinsic(object: object): string | undefined {\n    const objectKeys = Object.keys(object);\n    // a CFN intrinsic is always an object with a single key\n    if (objectKeys.length !== 1) {\n      return undefined;\n    }\n\n    const key = objectKeys[0];\n    return key === 'Ref' || key.startsWith('Fn::') ||\n        // special intrinsic only available in the 'Conditions' section\n        (this.options.context === CfnParsingContext.CONDITIONS && key === 'Condition')\n      ? key\n      : undefined;\n  }\n\n  private parseFnSubString(templateString: string, expressionMap: { [key: string]: any } | undefined): string {\n    const map = expressionMap ?? {};\n    const self = this;\n    return Fn.sub(go(templateString), Object.keys(map).length === 0 ? expressionMap : map);\n\n    function go(value: string): string {\n      const leftBrace = value.indexOf('${');\n      if (leftBrace === -1) {\n        return value;\n      }\n      // search for the closing brace to the right of the opening '${'\n      // (in theory, there could be other braces in the string,\n      // for example if it represents a JSON object)\n      const rightBrace = value.indexOf('}', leftBrace);\n      if (rightBrace === -1) {\n        return value;\n      }\n\n      const leftHalf = value.substring(0, leftBrace);\n      const rightHalf = value.substring(rightBrace + 1);\n      // don't include left and right braces when searching for the target of the reference\n      const refTarget = value.substring(leftBrace + 2, rightBrace).trim();\n      if (refTarget[0] === '!') {\n        return value.substring(0, rightBrace + 1) + go(rightHalf);\n      }\n\n      // lookup in map\n      if (refTarget in map) {\n        return leftHalf + '${' + refTarget + '}' + go(rightHalf);\n      }\n\n      // since it's not in the map, check if it's a pseudo-parameter\n      // (or a value to be substituted for a Parameter, provided by the customer)\n      const specialRef = self.specialCaseSubRefs(refTarget);\n      if (specialRef !== undefined) {\n        if (Token.isUnresolved(specialRef)) {\n          // specialRef can only be a Token if the value passed by the customer\n          // for substituting a Parameter was a Token.\n          // This is actually bad here,\n          // because the Token can potentially be something that doesn't render\n          // well inside an Fn::Sub template string, like a { Ref } object.\n          // To handle this case,\n          // instead of substituting the Parameter directly with the token in the template string,\n          // add a new entry to the Fn::Sub map,\n          // with key refTarget, and the token as the value.\n          // This is safe, because this sort of shadowing is legal in CloudFormation,\n          // and also because we're certain the Fn::Sub map doesn't contain an entry for refTarget\n          // (as we check that condition in the code right above this).\n          map[refTarget] = specialRef;\n          return leftHalf + '${' + refTarget + '}' + go(rightHalf);\n        } else {\n          return leftHalf + specialRef + go(rightHalf);\n        }\n      }\n\n      const dotIndex = refTarget.indexOf('.');\n      const isRef = dotIndex === -1;\n      if (isRef) {\n        const refElement = self.finder.findRefTarget(refTarget);\n        if (!refElement) {\n          throw new Error(`Element referenced in Fn::Sub expression with logical ID: '${refTarget}' was not found in the template`);\n        }\n        return leftHalf + CfnReference.for(refElement, 'Ref', ReferenceRendering.FN_SUB).toString() + go(rightHalf);\n      } else {\n        const targetId = refTarget.substring(0, dotIndex);\n        const refResource = self.finder.findResource(targetId);\n        if (!refResource) {\n          throw new Error(`Resource referenced in Fn::Sub expression with logical ID: '${targetId}' was not found in the template`);\n        }\n        const attribute = refTarget.substring(dotIndex + 1);\n        return leftHalf + CfnReference.for(refResource, attribute, ReferenceRendering.FN_SUB).toString() + go(rightHalf);\n      }\n    }\n  }\n\n  private handleRulesIntrinsic(key: string, object: any): any {\n    // Rules have their own set of intrinsics:\n    // https://docs.aws.amazon.com/servicecatalog/latest/adminguide/intrinsic-function-reference-rules.html\n    switch (key) {\n      case 'Fn::ValueOf': {\n        // ValueOf is special,\n        // as it takes the name of a Parameter as its first argument\n        const value = this.parseValue(object[key]);\n        const parameterName = value[0];\n        if (parameterName in this.parameters) {\n          // since ValueOf returns the value of a specific attribute,\n          // fail here - this substitution is not allowed\n          throw new Error(`Cannot substitute parameter '${parameterName}' used in Fn::ValueOf expression with attribute '${value[1]}'`);\n        }\n        const param = this.finder.findRefTarget(parameterName);\n        if (!param) {\n          throw new Error(`Rule references parameter '${parameterName}' which was not found in the template`);\n        }\n        // create an explicit IResolvable,\n        // as Fn.valueOf() returns a string,\n        // which is incorrect\n        // (Fn::ValueOf can also return an array)\n        return Lazy.any({ produce: () => ({ 'Fn::ValueOf': [param.logicalId, value[1]] }) });\n      }\n      default:\n        // I don't want to hard-code the list of supported Rules-specific intrinsics in this function;\n        // so, just return undefined here,\n        // and they will be treated as a regular JSON object\n        return undefined;\n    }\n  }\n\n  private specialCaseRefs(value: any): any {\n    if (value in this.parameters) {\n      return this.parameters[value];\n    }\n    switch (value) {\n      case 'AWS::AccountId': return Aws.ACCOUNT_ID;\n      case 'AWS::Region': return Aws.REGION;\n      case 'AWS::Partition': return Aws.PARTITION;\n      case 'AWS::URLSuffix': return Aws.URL_SUFFIX;\n      case 'AWS::NotificationARNs': return Aws.NOTIFICATION_ARNS;\n      case 'AWS::StackId': return Aws.STACK_ID;\n      case 'AWS::StackName': return Aws.STACK_NAME;\n      case 'AWS::NoValue': return Aws.NO_VALUE;\n      default: return undefined;\n    }\n  }\n\n  private specialCaseSubRefs(value: string): string | undefined {\n    if (value in this.parameters) {\n      return this.parameters[value];\n    }\n    return value.indexOf('::') === -1 ? undefined: '${' + value + '}';\n  }\n\n  private get parameters(): { [parameterName: string]: any } {\n    return this.options.parameters || {};\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
