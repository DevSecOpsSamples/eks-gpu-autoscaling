{
  "version": 3,
  "sources": ["deps.ts"],
  "sourcesContent": ["import { CfnResource } from './cfn-resource';\nimport { Stack } from './stack';\nimport { Stage } from './stage';\nimport { findLastCommonElement, pathToTopLevelStack as pathToRoot } from './util';\n\ntype Element = CfnResource | Stack;\n\n/**\n * Adds a dependency between two resources or stacks, across stack and nested\n * stack boundaries.\n *\n * The algorithm consists of:\n * - Try to find the deepest common stack between the two elements\n * - If there isn't a common stack, it means the elements belong to two\n *   disjoined stack-trees and therefore we apply the dependency at the\n *   assembly/app level between the two topl-level stacks.\n * - If we did find a common stack, we apply the dependency as a CloudFormation\n *   \"DependsOn\" between the resources that \"represent\" our source and target\n *   either directly or through the AWS::CloudFormation::Stack resources that\n *   \"lead\" to them.\n *\n * @param source The source resource/stack (the depedent)\n * @param target The target resource/stack (the dependency)\n * @param reason Optional resource to associate with the dependency for\n * diagnostics\n */\nexport function addDependency<T extends Element>(source: T, target: T, reason?: string) {\n  if (source === target) {\n    return;\n  }\n\n  const sourceStack = Stack.of(source);\n  const targetStack = Stack.of(target);\n\n  const sourceStage = Stage.of(sourceStack);\n  const targetStage = Stage.of(targetStack);\n  if (sourceStage !== targetStage) {\n    // eslint-disable-next-line max-len\n    throw new Error(`You cannot add a dependency from '${source.node.path}' (in ${describeStage(sourceStage)}) to '${target.node.path}' (in ${describeStage(targetStage)}): dependency cannot cross stage boundaries`);\n  }\n\n  // find the deepest common stack between the two elements\n  const sourcePath = pathToRoot(sourceStack);\n  const targetPath = pathToRoot(targetStack);\n  const commonStack = findLastCommonElement(sourcePath, targetPath);\n\n  // if there is no common stack, then define a assembly-level dependency\n  // between the two top-level stacks\n  if (!commonStack) {\n    const topLevelSource = sourcePath[0]; // first path element is the top-level stack\n    const topLevelTarget = targetPath[0];\n    topLevelSource._addAssemblyDependency(topLevelTarget, reason);\n    return;\n  }\n\n  // assertion: at this point if source and target are stacks, both are nested stacks.\n  // since we have a common stack, it is impossible that both are top-level\n  // stacks, so let's examine the two cases where one of them is top-level and\n  // the other is nested.\n\n  // case 1 - source is top-level and target is nested: this implies that\n  // `target` is a direct or indirect nested stack of `source`, and an explicit\n  // dependency is not required because nested stacks will always be deployed\n  // before their parents.\n  if (commonStack === source) {\n    return;\n  }\n\n  // case 2 - source is nested and target is top-level: this implies that\n  // `source` is a direct or indirect nested stack of `target`, and this is not\n  // possible (nested stacks cannot depend on their parents).\n  if (commonStack === target) {\n    throw new Error(`Nested stack '${sourceStack.node.path}' cannot depend on a parent stack '${targetStack.node.path}': ${reason}`);\n  }\n\n  // we have a common stack from which we can reach both `source` and `target`\n  // now we need to find two resources which are defined directly in this stack\n  // and which can \"lead us\" to the source/target.\n  const sourceResource = resourceInCommonStackFor(source);\n  const targetResource = resourceInCommonStackFor(target);\n  sourceResource._addResourceDependency(targetResource);\n\n  function resourceInCommonStackFor(element: CfnResource | Stack): CfnResource {\n    const resource = Stack.isStack(element) ? element.nestedStackResource : element;\n    if (!resource) {\n      throw new Error('assertion failure'); // see \"assertion\" above\n    }\n\n    const resourceStack = Stack.of(resource);\n\n    // we reached a resource defined in the common stack\n    if (commonStack === resourceStack) {\n      return resource;\n    }\n\n    return resourceInCommonStackFor(resourceStack);\n  }\n}\n\n/**\n * Return a string representation of the given assembler, for use in error messages\n */\nfunction describeStage(assembly: Stage | undefined): string {\n  if (!assembly) { return 'an unrooted construct tree'; }\n  if (!assembly.parentStage) { return 'the App'; }\n  return `Stage '${assembly.node.path}'`;\n}\n"],
  "mappings": "iGACA,KAAA,SAAA,QAAA,SAAA,EACA,QAAA,QAAA,SAAA,EACA,OAAA,QAAA,QAAA,EAuBA,uBAAiD,OAAW,OAAW,OAAe,CACpF,GAAI,SAAW,OACb,OAGF,KAAM,aAAc,QAAA,MAAM,GAAG,MAAM,EAC7B,YAAc,QAAA,MAAM,GAAG,MAAM,EAE7B,YAAc,QAAA,MAAM,GAAG,WAAW,EAClC,YAAc,QAAA,MAAM,GAAG,WAAW,EACxC,GAAI,cAAgB,YAElB,KAAM,IAAI,OAAM,qCAAqC,OAAO,KAAK,aAAa,cAAc,WAAW,UAAU,OAAO,KAAK,aAAa,cAAc,WAAW,8CAA8C,EAInN,KAAM,YAAa,OAAA,oBAAW,WAAW,EACnC,WAAa,OAAA,oBAAW,WAAW,EACnC,YAAc,OAAA,sBAAsB,WAAY,UAAU,EAIhE,GAAI,CAAC,YAAa,CAChB,KAAM,gBAAiB,WAAW,GAC5B,eAAiB,WAAW,GAClC,eAAe,uBAAuB,eAAgB,MAAM,EAC5D,OAYF,GAAI,cAAgB,OAClB,OAMF,GAAI,cAAgB,OAClB,KAAM,IAAI,OAAM,iBAAiB,YAAY,KAAK,0CAA0C,YAAY,KAAK,UAAU,QAAQ,EAMjI,KAAM,gBAAiB,yBAAyB,MAAM,EAChD,eAAiB,yBAAyB,MAAM,EACtD,eAAe,uBAAuB,cAAc,EAEpD,kCAAkC,QAA4B,CAC5D,KAAM,UAAW,QAAA,MAAM,QAAQ,OAAO,EAAI,QAAQ,oBAAsB,QACxE,GAAI,CAAC,SACH,KAAM,IAAI,OAAM,mBAAmB,EAGrC,KAAM,eAAgB,QAAA,MAAM,GAAG,QAAQ,EAGvC,MAAI,eAAgB,cACX,SAGF,yBAAyB,aAAa,CAC/C,CACF,CAvEA,QAAA,cAAA,cA4EA,uBAAuB,SAA2B,CAChD,MAAK,UACA,SAAS,YACP,UAAU,SAAS,KAAK,QADK,UADZ,4BAG1B",
  "names": []
}
