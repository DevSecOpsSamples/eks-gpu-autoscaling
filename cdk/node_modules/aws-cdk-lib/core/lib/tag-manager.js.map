{
  "version": 3,
  "sources": ["tag-manager.ts"],
  "sourcesContent": ["import { TagType } from './cfn-resource';\nimport { CfnTag } from './cfn-tag';\nimport { Lazy } from './lazy';\nimport { IResolvable } from './resolvable';\n\ninterface Tag {\n  key: string;\n  value: string;\n  priority: number;\n\n  /**\n   * @default true\n   */\n  applyToLaunchedInstances?: boolean;\n}\n\ninterface CfnAsgTag {\n  key: string;\n  value: string;\n  propagateAtLaunch: boolean;\n}\n\ninterface StackTag {\n  Key: string;\n  Value: string;\n}\n/**\n * Interface for converter between CloudFormation and internal tag representations\n */\ninterface ITagFormatter {\n  /**\n   * Format the given tags as CloudFormation tags\n   */\n  formatTags(tags: Tag[]): any;\n\n  /**\n   * Parse the CloudFormation tag representation into internal representation\n   *\n   * Use the given priority.\n   */\n  parseTags(cfnPropertyTags: any, priority: number): Tag[];\n}\n\n/**\n * Standard tags are a list of { key, value } objects\n */\nclass StandardFormatter implements ITagFormatter {\n  public parseTags(cfnPropertyTags: any, priority: number): Tag[] {\n    if (!Array.isArray(cfnPropertyTags)) {\n      throw new Error(`Invalid tag input expected array of {key, value} have ${JSON.stringify(cfnPropertyTags)}`);\n    }\n\n    const tags: Tag[] = [];\n    for (const tag of cfnPropertyTags) {\n      if (tag.key === undefined || tag.value === undefined) {\n        throw new Error(`Invalid tag input expected {key, value} have ${JSON.stringify(tag)}`);\n      }\n      // using interp to ensure Token is now string\n      tags.push({\n        key: `${tag.key}`,\n        value: `${tag.value}`,\n        priority,\n      });\n    }\n    return tags;\n  }\n\n  public formatTags(tags: Tag[]): any {\n    const cfnTags: CfnTag[] = [];\n    for (const tag of tags) {\n      cfnTags.push({\n        key: tag.key,\n        value: tag.value,\n      });\n    }\n    return cfnTags.length === 0 ? undefined : cfnTags;\n  }\n}\n\n/**\n * ASG tags are a list of { key, value, propagateAtLaunch } objects\n */\nclass AsgFormatter implements ITagFormatter {\n  public parseTags(cfnPropertyTags: any, priority: number): Tag[] {\n    const tags: Tag[] = [];\n    if (!Array.isArray(cfnPropertyTags)) {\n      throw new Error(`Invalid tag input expected array of {key, value, propagateAtLaunch} have ${JSON.stringify(cfnPropertyTags)}`);\n    }\n\n    for (const tag of cfnPropertyTags) {\n      if (tag.key === undefined ||\n        tag.value === undefined ||\n        tag.propagateAtLaunch === undefined) {\n        throw new Error(`Invalid tag input expected {key, value, propagateAtLaunch} have ${JSON.stringify(tag)}`);\n      }\n      // using interp to ensure Token is now string\n      tags.push({\n        key: `${tag.key}`,\n        value: `${tag.value}`,\n        priority,\n        applyToLaunchedInstances: !!tag.propagateAtLaunch,\n      });\n    }\n\n    return tags;\n  }\n\n  public formatTags(tags: Tag[]): any {\n    const cfnTags: CfnAsgTag[] = [];\n    for (const tag of tags) {\n      cfnTags.push({\n        key: tag.key,\n        value: tag.value,\n        propagateAtLaunch: tag.applyToLaunchedInstances !== false,\n      });\n    }\n    return cfnTags.length === 0 ? undefined : cfnTags;\n  }\n}\n\n/**\n * Some CloudFormation constructs use a { key: value } map for tags\n */\nclass MapFormatter implements ITagFormatter {\n  public parseTags(cfnPropertyTags: any, priority: number): Tag[] {\n    const tags: Tag[] = [];\n    if (Array.isArray(cfnPropertyTags) || typeof(cfnPropertyTags) !== 'object') {\n      throw new Error(`Invalid tag input expected map of {key: value} have ${JSON.stringify(cfnPropertyTags)}`);\n    }\n\n    for (const [key, value] of Object.entries(cfnPropertyTags)) {\n      tags.push({\n        key,\n        value: `${value}`,\n        priority,\n      });\n    }\n\n    return tags;\n  }\n\n  public formatTags(tags: Tag[]): any {\n    const cfnTags: {[key: string]: string} = {};\n    for (const tag of tags) {\n      cfnTags[`${tag.key}`] = `${tag.value}`;\n    }\n    return Object.keys(cfnTags).length === 0 ? undefined : cfnTags;\n  }\n}\n\n/**\n * StackTags are of the format { Key: key, Value: value }\n */\nclass KeyValueFormatter implements ITagFormatter {\n  public parseTags(keyValueTags: any, priority: number): Tag[] {\n    const tags: Tag[] = [];\n    for (const key in keyValueTags) {\n      if (keyValueTags.hasOwnProperty(key)) {\n        const value = keyValueTags[key];\n        tags.push({\n          key,\n          value,\n          priority,\n        });\n      }\n    }\n    return tags;\n  }\n  public formatTags(unformattedTags: Tag[]): any {\n    const tags: StackTag[] = [];\n    unformattedTags.forEach(tag => {\n      tags.push({\n        Key: tag.key,\n        Value: tag.value,\n      });\n    });\n    return tags.length > 0 ? tags : undefined;\n  }\n}\n\nclass NoFormat implements ITagFormatter {\n  public parseTags(_cfnPropertyTags: any): Tag[] {\n    return [];\n  }\n  public formatTags(_tags: Tag[]): any {\n    return undefined;\n  }\n}\n\n\nlet _tagFormattersCache: {[key: string]: ITagFormatter} | undefined;\n\n/**\n * Access tag formatters table\n *\n * In a function because we're in a load cycle with cfn-resource that defines `TagType`.\n */\nfunction TAG_FORMATTERS(): {[key: string]: ITagFormatter} {\n  return _tagFormattersCache ?? (_tagFormattersCache = {\n    [TagType.AUTOSCALING_GROUP]: new AsgFormatter(),\n    [TagType.STANDARD]: new StandardFormatter(),\n    [TagType.MAP]: new MapFormatter(),\n    [TagType.KEY_VALUE]: new KeyValueFormatter(),\n    [TagType.NOT_TAGGABLE]: new NoFormat(),\n  });\n};\n\n/**\n * Interface to implement tags.\n */\nexport interface ITaggable {\n  /**\n   * TagManager to set, remove and format tags\n   */\n  readonly tags: TagManager;\n}\n\n/**\n * Options to configure TagManager behavior\n */\nexport interface TagManagerOptions {\n  /**\n   * The name of the property in CloudFormation for these tags\n   *\n   * Normally this is `tags`, but Cognito UserPool uses UserPoolTags\n   *\n   * @default \"tags\"\n   */\n  readonly tagPropertyName?: string;\n}\n\n/**\n * TagManager facilitates a common implementation of tagging for Constructs\n *\n * Normally, you do not need to use this class, as the CloudFormation specification\n * will indicate which resources are taggable. However, sometimes you will need this\n * to make custom resources taggable. Used `tagManager.renderedTags` to obtain a\n * value that will resolve to the tags at synthesis time.\n *\n * @example\n * import * as cdk from '@aws-cdk/core';\n *\n * class MyConstruct extends cdk.Resource implements cdk.ITaggable {\n *   public readonly tags = new cdk.TagManager(cdk.TagType.KEY_VALUE, 'Whatever::The::Type');\n *\n *   constructor(scope: cdk.Construct, id: string) {\n *     super(scope, id);\n *\n *     new cdk.CfnResource(this, 'Resource', {\n *       type: 'Whatever::The::Type',\n *       properties: {\n *         // ...\n *         Tags: this.tags.renderedTags,\n *       },\n *     });\n *   }\n * }\n *\n */\nexport class TagManager {\n\n  /**\n   * Check whether the given construct is Taggable\n   */\n  public static isTaggable(construct: any): construct is ITaggable {\n    return (construct as any).tags !== undefined;\n  }\n\n  /**\n   * The property name for tag values\n   *\n   * Normally this is `tags` but some resources choose a different name. Cognito\n   * UserPool uses UserPoolTags\n   */\n  public readonly tagPropertyName: string;\n\n  /**\n   * A lazy value that represents the rendered tags at synthesis time\n   *\n   * If you need to make a custom construct taggable, use the value of this\n   * property to pass to the `tags` property of the underlying construct.\n   */\n  public readonly renderedTags: IResolvable;\n\n  private readonly tags = new Map<string, Tag>();\n  private readonly priorities = new Map<string, number>();\n  private readonly tagFormatter: ITagFormatter;\n  private readonly resourceTypeName: string;\n  private readonly initialTagPriority = 50;\n\n  constructor(tagType: TagType, resourceTypeName: string, tagStructure?: any, options: TagManagerOptions = { }) {\n    this.resourceTypeName = resourceTypeName;\n    this.tagFormatter = TAG_FORMATTERS()[tagType];\n    if (tagStructure !== undefined) {\n      this._setTag(...this.tagFormatter.parseTags(tagStructure, this.initialTagPriority));\n    }\n    this.tagPropertyName = options.tagPropertyName || 'tags';\n\n    this.renderedTags = Lazy.any({ produce: () => this.renderTags() });\n  }\n\n  /**\n   * Adds the specified tag to the array of tags\n   *\n   */\n  public setTag(key: string, value: string, priority = 0, applyToLaunchedInstances = true): void {\n    // This method mostly exists because we don't want to expose the 'Tag' type used (it will be confusing\n    // to users).\n    this._setTag({ key, value, priority, applyToLaunchedInstances });\n  }\n\n  /**\n   * Removes the specified tag from the array if it exists\n   *\n   * @param key The tag to remove\n   * @param priority The priority of the remove operation\n   */\n  public removeTag(key: string, priority: number): void {\n    if (priority >= (this.priorities.get(key) || 0)) {\n      this.tags.delete(key);\n      this.priorities.set(key, priority);\n    }\n  }\n\n  /**\n   * Renders tags into the proper format based on TagType\n   *\n   * This method will eagerly render the tags currently applied. In\n   * most cases, you should be using `tagManager.renderedTags` instead,\n   * which will return a `Lazy` value that will resolve to the correct\n   * tags at synthesis time.\n   */\n  public renderTags(): any {\n    return this.tagFormatter.formatTags(this.sortedTags);\n  }\n\n  /**\n   * Render the tags in a readable format\n   */\n  public tagValues(): Record<string, string> {\n    const ret: Record<string, string> = {};\n    for (const tag of this.sortedTags) {\n      ret[tag.key] = tag.value;\n    }\n    return ret;\n  }\n\n  /**\n   * Determine if the aspect applies here\n   *\n   * Looks at the include and exclude resourceTypeName arrays to determine if\n   * the aspect applies here\n   */\n  public applyTagAspectHere(include?: string[], exclude?: string[]) {\n    if (exclude && exclude.length > 0 && exclude.indexOf(this.resourceTypeName) !== -1) {\n      return false;\n    }\n    if (include && include.length > 0 && include.indexOf(this.resourceTypeName) === -1) {\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Returns true if there are any tags defined\n   */\n  public hasTags(): boolean {\n    return this.tags.size > 0;\n  }\n\n  private _setTag(...tags: Tag[]) {\n    for (const tag of tags) {\n      if (tag.priority >= (this.priorities.get(tag.key) || 0)) {\n        this.tags.set(tag.key, tag);\n        this.priorities.set(tag.key, tag.priority);\n      }\n    }\n  }\n\n  private get sortedTags() {\n    return Array.from(this.tags.values()).sort((a, b) => a.key.localeCompare(b.key));\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
