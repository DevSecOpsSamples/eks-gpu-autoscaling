{
  "version": 3,
  "sources": ["resource.ts"],
  "sourcesContent": ["import { ArnComponents, ArnFormat } from './arn';\nimport { CfnResource } from './cfn-resource';\nimport { IStringProducer, Lazy } from './lazy';\nimport { generatePhysicalName, isGeneratedWhenNeededMarker } from './private/physical-name-generator';\nimport { Reference } from './reference';\nimport { RemovalPolicy } from './removal-policy';\nimport { IResolveContext } from './resolvable';\nimport { Stack } from './stack';\nimport { Token, Tokenization } from './token';\n\n// v2 - leave this as a separate section so it reduces merge conflicts when compat is removed\n// eslint-disable-next-line import/order\nimport { Construct, IConstruct } from 'constructs';\n\nconst RESOURCE_SYMBOL = Symbol.for('@aws-cdk/core.Resource');\n\n/**\n * Represents the environment a given resource lives in.\n * Used as the return value for the {@link IResource.env} property.\n */\nexport interface ResourceEnvironment {\n  /**\n   * The AWS account ID that this resource belongs to.\n   * Since this can be a Token\n   * (for example, when the account is CloudFormation's AWS::AccountId intrinsic),\n   * make sure to use Token.compareStrings()\n   * instead of just comparing the values for equality.\n   */\n  readonly account: string;\n\n  /**\n   * The AWS region that this resource belongs to.\n   * Since this can be a Token\n   * (for example, when the region is CloudFormation's AWS::Region intrinsic),\n   * make sure to use Token.compareStrings()\n   * instead of just comparing the values for equality.\n   */\n  readonly region: string;\n}\n\n/**\n * Interface for the Resource construct.\n */\nexport interface IResource extends IConstruct {\n  /**\n   * The stack in which this resource is defined.\n   */\n  readonly stack: Stack;\n\n  /**\n   * The environment this resource belongs to.\n   * For resources that are created and managed by the CDK\n   * (generally, those created by creating new class instances like Role, Bucket, etc.),\n   * this is always the same as the environment of the stack they belong to;\n   * however, for imported resources\n   * (those obtained from static methods like fromRoleArn, fromBucketName, etc.),\n   * that might be different than the stack they were imported into.\n   */\n  readonly env: ResourceEnvironment;\n\n  /**\n   * Apply the given removal policy to this resource\n   *\n   * The Removal Policy controls what happens to this resource when it stops\n   * being managed by CloudFormation, either because you've removed it from the\n   * CDK application or because you've made a change that requires the resource\n   * to be replaced.\n   *\n   * The resource can be deleted (`RemovalPolicy.DESTROY`), or left in your AWS\n   * account for data recovery and cleanup later (`RemovalPolicy.RETAIN`).\n   */\n  applyRemovalPolicy(policy: RemovalPolicy): void;\n}\n\n/**\n * Construction properties for {@link Resource}.\n */\nexport interface ResourceProps {\n  /**\n   * The value passed in by users to the physical name prop of the resource.\n   *\n   * - `undefined` implies that a physical name will be allocated by\n   *   CloudFormation during deployment.\n   * - a concrete value implies a specific physical name\n   * - `PhysicalName.GENERATE_IF_NEEDED` is a marker that indicates that a physical will only be generated\n   *   by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation.\n   *\n   * @default - The physical name will be allocated by CloudFormation at deployment time\n   */\n  readonly physicalName?: string;\n\n  /**\n   * The AWS account ID this resource belongs to.\n   *\n   * @default - the resource is in the same account as the stack it belongs to\n   */\n  readonly account?: string;\n\n  /**\n   * The AWS region this resource belongs to.\n   *\n   * @default - the resource is in the same region as the stack it belongs to\n   */\n  readonly region?: string;\n\n  /**\n   * ARN to deduce region and account from\n   *\n   * The ARN is parsed and the account and region are taken from the ARN.\n   * This should be used for imported resources.\n   *\n   * Cannot be supplied together with either `account` or `region`.\n   *\n   * @default - take environment from `account`, `region` parameters, or use Stack environment.\n   */\n  readonly environmentFromArn?: string;\n}\n\n/**\n * A construct which represents an AWS resource.\n */\nexport abstract class Resource extends Construct implements IResource {\n  /**\n   * Check whether the given construct is a Resource\n   */\n  public static isResource(construct: IConstruct): construct is CfnResource {\n    return construct !== null && typeof(construct) === 'object' && RESOURCE_SYMBOL in construct;\n  }\n\n  public readonly stack: Stack;\n  public readonly env: ResourceEnvironment;\n\n  /**\n   * Returns a string-encoded token that resolves to the physical name that\n   * should be passed to the CloudFormation resource.\n   *\n   * This value will resolve to one of the following:\n   * - a concrete value (e.g. `\"my-awesome-bucket\"`)\n   * - `undefined`, when a name should be generated by CloudFormation\n   * - a concrete name generated automatically during synthesis, in\n   *   cross-environment scenarios.\n   *\n   */\n  protected readonly physicalName: string;\n\n  private _physicalName: string | undefined;\n  private readonly _allowCrossEnvironment: boolean;\n\n  constructor(scope: Construct, id: string, props: ResourceProps = {}) {\n    super(scope, id);\n\n    if ((props.account !== undefined || props.region !== undefined) && props.environmentFromArn !== undefined) {\n      throw new Error(`Supply at most one of 'account'/'region' (${props.account}/${props.region}) and 'environmentFromArn' (${props.environmentFromArn})`);\n    }\n\n    Object.defineProperty(this, RESOURCE_SYMBOL, { value: true });\n\n    this.stack = Stack.of(this);\n\n    const parsedArn = props.environmentFromArn ?\n      // Since we only want the region and account, NO_RESOURE_NAME is good enough\n      this.stack.splitArn(props.environmentFromArn, ArnFormat.NO_RESOURCE_NAME)\n      : undefined;\n    this.env = {\n      account: props.account ?? parsedArn?.account ?? this.stack.account,\n      region: props.region ?? parsedArn?.region ?? this.stack.region,\n    };\n\n    let physicalName = props.physicalName;\n\n    if (props.physicalName && isGeneratedWhenNeededMarker(props.physicalName)) {\n      // auto-generate only if cross-env is required\n      this._physicalName = undefined;\n      this._allowCrossEnvironment = true;\n      physicalName = Lazy.string({ produce: () => this._physicalName });\n    } else if (props.physicalName && !Token.isUnresolved(props.physicalName)) {\n      // concrete value specified by the user\n      this._physicalName = props.physicalName;\n      this._allowCrossEnvironment = true;\n    } else {\n      // either undefined (deploy-time) or has tokens, which means we can't use for cross-env\n      this._physicalName = props.physicalName;\n      this._allowCrossEnvironment = false;\n    }\n\n    if (physicalName === undefined) {\n      physicalName = Token.asString(undefined);\n    }\n\n    this.physicalName = physicalName;\n  }\n\n  /**\n   * Called when this resource is referenced across environments\n   * (account/region) to order to request that a physical name will be generated\n   * for this resource during synthesis, so the resource can be referenced\n   * through it's absolute name/arn.\n   *\n   * @internal\n   */\n  public _enableCrossEnvironment(): void {\n    if (!this._allowCrossEnvironment) {\n      // error out - a deploy-time name cannot be used across environments\n      throw new Error(`Cannot use resource '${this.node.path}' in a cross-environment fashion, ` +\n        \"the resource's physical name must be explicit set or use `PhysicalName.GENERATE_IF_NEEDED`\");\n    }\n\n    if (!this._physicalName) {\n      this._physicalName = this.generatePhysicalName();\n    }\n  }\n\n  /**\n   * Apply the given removal policy to this resource\n   *\n   * The Removal Policy controls what happens to this resource when it stops\n   * being managed by CloudFormation, either because you've removed it from the\n   * CDK application or because you've made a change that requires the resource\n   * to be replaced.\n   *\n   * The resource can be deleted (`RemovalPolicy.DESTROY`), or left in your AWS\n   * account for data recovery and cleanup later (`RemovalPolicy.RETAIN`).\n   */\n  public applyRemovalPolicy(policy: RemovalPolicy) {\n    const child = this.node.defaultChild;\n    if (!child || !CfnResource.isCfnResource(child)) {\n      throw new Error('Cannot apply RemovalPolicy: no child or not a CfnResource. Apply the removal policy on the CfnResource directly.');\n    }\n    child.applyRemovalPolicy(policy);\n  }\n\n  protected generatePhysicalName(): string {\n    return generatePhysicalName(this);\n  }\n\n  /**\n   * Returns an environment-sensitive token that should be used for the\n   * resource's \"name\" attribute (e.g. `bucket.bucketName`).\n   *\n   * Normally, this token will resolve to `nameAttr`, but if the resource is\n   * referenced across environments, it will be resolved to `this.physicalName`,\n   * which will be a concrete name.\n   *\n   * @param nameAttr The CFN attribute which resolves to the resource's name.\n   * Commonly this is the resource's `ref`.\n   */\n  protected getResourceNameAttribute(nameAttr: string) {\n    return mimicReference(nameAttr, {\n      produce: (context: IResolveContext) => {\n        const consumingStack = Stack.of(context.scope);\n\n        if (this.stack.environment !== consumingStack.environment) {\n          this._enableCrossEnvironment();\n          return this.physicalName;\n        } else {\n          return nameAttr;\n        }\n      },\n    });\n  }\n\n  /**\n   * Returns an environment-sensitive token that should be used for the\n   * resource's \"ARN\" attribute (e.g. `bucket.bucketArn`).\n   *\n   * Normally, this token will resolve to `arnAttr`, but if the resource is\n   * referenced across environments, `arnComponents` will be used to synthesize\n   * a concrete ARN with the resource's physical name. Make sure to reference\n   * `this.physicalName` in `arnComponents`.\n   *\n   * @param arnAttr The CFN attribute which resolves to the ARN of the resource.\n   * Commonly it will be called \"Arn\" (e.g. `resource.attrArn`), but sometimes\n   * it's the CFN resource's `ref`.\n   * @param arnComponents The format of the ARN of this resource. You must\n   * reference `this.physicalName` somewhere within the ARN in order for\n   * cross-environment references to work.\n   *\n   */\n  protected getResourceArnAttribute(arnAttr: string, arnComponents: ArnComponents) {\n    return mimicReference(arnAttr, {\n      produce: (context: IResolveContext) => {\n        const consumingStack = Stack.of(context.scope);\n        if (this.stack.environment !== consumingStack.environment) {\n          this._enableCrossEnvironment();\n          return this.stack.formatArn(arnComponents);\n        } else {\n          return arnAttr;\n        }\n      },\n    });\n  }\n}\n\n/**\n * Produce a Lazy that is also a Reference (if the base value is a Reference).\n *\n * If the given value is a Reference (or resolves to a Reference), return a new\n * Reference that mimics the same target and display name, but resolves using\n * the logic of the passed lazy.\n *\n * If the given value is NOT a Reference, just return a simple Lazy.\n */\nfunction mimicReference(refSource: any, producer: IStringProducer): string {\n  const reference = Tokenization.reverse(refSource, {\n    // If this is an ARN concatenation, just fail to extract a reference.\n    failConcat: false,\n  });\n  if (!Reference.isReference(reference)) {\n    return Lazy.uncachedString(producer);\n  }\n\n  return Token.asString(new class extends Reference {\n    resolve(context: IResolveContext) {\n      return producer.produce(context);\n    }\n  }(reference, reference.target, reference.displayName));\n}\n"],
  "mappings": "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",
  "names": []
}
