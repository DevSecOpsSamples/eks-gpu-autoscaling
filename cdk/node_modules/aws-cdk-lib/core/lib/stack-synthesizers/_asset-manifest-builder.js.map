{
  "version": 3,
  "sources": ["_asset-manifest-builder.ts"],
  "sourcesContent": ["import * as fs from 'fs';\nimport * as path from 'path';\n\nimport * as cxschema from '../../../cloud-assembly-schema';\nimport { FileAssetSource, FileAssetLocation, FileAssetPackaging, DockerImageAssetSource, DockerImageAssetLocation } from '../assets';\nimport { Fn } from '../cfn-fn';\nimport { Stack } from '../stack';\nimport { resolvedOr } from './_shared';\nimport { ISynthesisSession } from './types';\n\n/**\n * Build an manifest from assets added to a stack synthesizer\n */\nexport class AssetManifestBuilder {\n  private readonly files: NonNullable<cxschema.AssetManifest['files']> = {};\n  private readonly dockerImages: NonNullable<cxschema.AssetManifest['dockerImages']> = {};\n\n  public addFileAssetDefault(\n    asset: FileAssetSource,\n    stack: Stack,\n    bucketName: string,\n    bucketPrefix: string,\n    role?: RoleOptions,\n  ): FileAssetLocation {\n    validateFileAssetSource(asset);\n\n    const extension =\n      asset.fileName != undefined ? path.extname(asset.fileName) : '';\n    const objectKey =\n      bucketPrefix +\n      asset.sourceHash +\n      (asset.packaging === FileAssetPackaging.ZIP_DIRECTORY\n        ? '.zip'\n        : extension);\n\n    // Add to manifest\n    this.files[asset.sourceHash] = {\n      source: {\n        path: asset.fileName,\n        executable: asset.executable,\n        packaging: asset.packaging,\n      },\n      destinations: {\n        [this.manifestEnvName(stack)]: {\n          bucketName: bucketName,\n          objectKey,\n          region: resolvedOr(stack.region, undefined),\n          assumeRoleArn: role?.assumeRoleArn,\n          assumeRoleExternalId: role?.assumeRoleExternalId,\n        },\n      },\n    };\n\n    const { region, urlSuffix } = stackLocationOrInstrinsics(stack);\n    const httpUrl = cfnify(\n      `https://s3.${region}.${urlSuffix}/${bucketName}/${objectKey}`,\n    );\n    const s3ObjectUrlWithPlaceholders = `s3://${bucketName}/${objectKey}`;\n\n    // Return CFN expression\n    //\n    // 's3ObjectUrlWithPlaceholders' is intended for the CLI. The CLI ultimately needs a\n    // 'https://s3.REGION.amazonaws.com[.cn]/name/hash' URL to give to CloudFormation.\n    // However, there's no way for us to actually know the URL_SUFFIX in the framework, so\n    // we can't construct that URL. Instead, we record the 's3://.../...' form, and the CLI\n    // transforms it to the correct 'https://.../' URL before calling CloudFormation.\n    return {\n      bucketName: cfnify(bucketName),\n      objectKey,\n      httpUrl,\n      s3ObjectUrl: cfnify(s3ObjectUrlWithPlaceholders),\n      s3ObjectUrlWithPlaceholders,\n      s3Url: httpUrl,\n    };\n  }\n\n  public addDockerImageAssetDefault(\n    asset: DockerImageAssetSource,\n    stack: Stack,\n    repositoryName: string,\n    dockerTagPrefix: string,\n    role?: RoleOptions,\n  ): DockerImageAssetLocation {\n    validateDockerImageAssetSource(asset);\n    const imageTag = dockerTagPrefix + asset.sourceHash;\n\n    // Add to manifest\n    this.dockerImages[asset.sourceHash] = {\n      source: {\n        executable: asset.executable,\n        directory: asset.directoryName,\n        dockerBuildArgs: asset.dockerBuildArgs,\n        dockerBuildTarget: asset.dockerBuildTarget,\n        dockerFile: asset.dockerFile,\n        networkMode: asset.networkMode,\n      },\n      destinations: {\n        [this.manifestEnvName(stack)]: {\n          repositoryName: repositoryName,\n          imageTag,\n          region: resolvedOr(stack.region, undefined),\n          assumeRoleArn: role?.assumeRoleArn,\n          assumeRoleExternalId: role?.assumeRoleExternalId,\n        },\n      },\n    };\n\n    const { account, region, urlSuffix } = stackLocationOrInstrinsics(stack);\n\n    // Return CFN expression\n    return {\n      repositoryName: cfnify(repositoryName),\n      imageUri: cfnify(\n        `${account}.dkr.ecr.${region}.${urlSuffix}/${repositoryName}:${imageTag}`,\n      ),\n    };\n  }\n\n  /**\n   * Write the manifest to disk, and add it to the synthesis session\n   *\n   * Reutrn the artifact Id\n   */\n  public writeManifest(\n    stack: Stack,\n    session: ISynthesisSession,\n    additionalProps: Partial<cxschema.AssetManifestProperties> = {},\n  ): string {\n    const artifactId = `${stack.artifactId}.assets`;\n    const manifestFile = `${artifactId}.json`;\n    const outPath = path.join(session.assembly.outdir, manifestFile);\n\n    const manifest: cxschema.AssetManifest = {\n      version: cxschema.Manifest.version(),\n      files: this.files,\n      dockerImages: this.dockerImages,\n    };\n\n    fs.writeFileSync(outPath, JSON.stringify(manifest, undefined, 2));\n\n    session.assembly.addArtifact(artifactId, {\n      type: cxschema.ArtifactType.ASSET_MANIFEST,\n      properties: {\n        file: manifestFile,\n        ...additionalProps,\n      },\n    });\n\n    return artifactId;\n  }\n\n  private manifestEnvName(stack: Stack): string {\n    return [\n      resolvedOr(stack.account, 'current_account'),\n      resolvedOr(stack.region, 'current_region'),\n    ].join('-');\n  }\n}\n\nexport interface RoleOptions {\n  readonly assumeRoleArn?: string;\n  readonly assumeRoleExternalId?: string;\n}\n\nfunction validateFileAssetSource(asset: FileAssetSource) {\n  if (!!asset.executable === !!asset.fileName) {\n    throw new Error(`Exactly one of 'fileName' or 'executable' is required, got: ${JSON.stringify(asset)}`);\n  }\n\n  if (!!asset.packaging !== !!asset.fileName) {\n    throw new Error(`'packaging' is expected in combination with 'fileName', got: ${JSON.stringify(asset)}`);\n  }\n}\n\nfunction validateDockerImageAssetSource(asset: DockerImageAssetSource) {\n  if (!!asset.executable === !!asset.directoryName) {\n    throw new Error(`Exactly one of 'directoryName' or 'executable' is required, got: ${JSON.stringify(asset)}`);\n  }\n\n  check('dockerBuildArgs');\n  check('dockerBuildTarget');\n  check('dockerFile');\n\n  function check<K extends keyof DockerImageAssetSource>(key: K) {\n    if (asset[key] && !asset.directoryName) {\n      throw new Error(`'${key}' is only allowed in combination with 'directoryName', got: ${JSON.stringify(asset)}`);\n    }\n  }\n}\n\n/**\n * Return the stack locations if they're concrete, or the original CFN intrisics otherwise\n *\n * We need to return these instead of the tokenized versions of the strings,\n * since we must accept those same ${AWS::AccountId}/${AWS::Region} placeholders\n * in bucket names and role names (in order to allow environment-agnostic stacks).\n *\n * We'll wrap a single {Fn::Sub} around the final string in order to replace everything,\n * but we can't have the token system render part of the string to {Fn::Join} because\n * the CFN specification doesn't allow the {Fn::Sub} template string to be an arbitrary\n * expression--it must be a string literal.\n */\nfunction stackLocationOrInstrinsics(stack: Stack) {\n  return {\n    account: resolvedOr(stack.account, '${AWS::AccountId}'),\n    region: resolvedOr(stack.region, '${AWS::Region}'),\n    urlSuffix: resolvedOr(stack.urlSuffix, '${AWS::URLSuffix}'),\n  };\n}\n\n/**\n * If the string still contains placeholders, wrap it in a Fn::Sub so they will be substituted at CFN deployment time\n *\n * (This happens to work because the placeholders we picked map directly onto CFN\n * placeholders. If they didn't we'd have to do a transformation here).\n */\nfunction cfnify(s: string): string {\n  return s.indexOf('${') > -1 ? Fn.sub(s) : s;\n}"],
  "mappings": "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",
  "names": []
}
