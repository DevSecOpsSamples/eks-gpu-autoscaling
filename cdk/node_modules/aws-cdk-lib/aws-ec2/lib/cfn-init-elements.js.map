{
  "version": 3,
  "sources": ["cfn-init-elements.ts"],
  "sourcesContent": ["import * as fs from 'fs';\nimport * as iam from '../../aws-iam';\nimport * as s3 from '../../aws-s3';\nimport * as s3_assets from '../../aws-s3-assets';\nimport { Duration } from '../../core';\nimport { InitBindOptions, InitElementConfig, InitElementType, InitPlatform } from './private/cfn-init-internal';\n\n/**\n * An object that represents reasons to restart an InitService\n *\n * Pass an instance of this object to the `InitFile`, `InitCommand`,\n * `InitSource` and `InitPackage` objects, and finally to an `InitService`\n * itself to cause the actions (files, commands, sources, and packages)\n * to trigger a restart of the service.\n *\n * For example, the following will run a custom command to install Nginx,\n * and trigger the nginx service to be restarted after the command has run.\n *\n * ```ts\n * const handle = new ec2.InitServiceRestartHandle();\n * ec2.CloudFormationInit.fromElements(\n *   ec2.InitCommand.shellCommand('/usr/bin/custom-nginx-install.sh', { serviceRestartHandles: [handle] }),\n *   ec2.InitService.enable('nginx', { serviceRestartHandle: handle }),\n * );\n * ```\n */\nexport class InitServiceRestartHandle {\n  private readonly commands = new Array<string>();\n  private readonly files = new Array<string>();\n  private readonly sources = new Array<string>();\n  private readonly packages: Record<string, string[]> = {};\n\n  /**\n   * Add a command key to the restart set\n   * @internal\n   */\n  public _addCommand(key: string) {\n    return this.commands.push(key);\n  }\n\n  /**\n   * Add a file key to the restart set\n   * @internal\n   */\n  public _addFile(key: string) {\n    return this.files.push(key);\n  }\n\n  /**\n   * Add a source key to the restart set\n   * @internal\n   */\n  public _addSource(key: string) {\n    return this.sources.push(key);\n  }\n\n  /**\n   * Add a package key to the restart set\n   * @internal\n   */\n  public _addPackage(packageType: string, key: string) {\n    if (!this.packages[packageType]) {\n      this.packages[packageType] = [];\n    }\n    this.packages[packageType].push(key);\n  }\n\n  /**\n   * Render the restart handles for use in an InitService declaration\n   * @internal\n   */\n  public _renderRestartHandles(): any {\n    const nonEmpty = <A>(x: A[]) => x.length > 0 ? x : undefined;\n\n    return {\n      commands: nonEmpty(this.commands),\n      files: nonEmpty(this.files),\n      packages: Object.keys(this.packages).length > 0 ? this.packages : undefined,\n      sources: nonEmpty(this.sources),\n    };\n  }\n}\n\n/**\n * Base class for all CloudFormation Init elements\n */\nexport abstract class InitElement {\n\n  /**\n   * Returns the init element type for this element.\n   */\n  public abstract readonly elementType: string;\n\n  /**\n   * Called when the Init config is being consumed. Renders the CloudFormation\n   * representation of this init element, and calculates any authentication\n   * properties needed, if any.\n   *\n   * @param options bind options for the element.\n   * @internal\n   */\n  public abstract _bind(options: InitBindOptions): InitElementConfig;\n\n}\n\n/**\n * Options for InitCommand\n */\nexport interface InitCommandOptions {\n  /**\n   * Identifier key for this command\n   *\n   * Commands are executed in lexicographical order of their key names.\n   *\n   * @default - Automatically generated based on index\n   */\n  readonly key?: string;\n\n  /**\n   * Sets environment variables for the command.\n   *\n   * This property overwrites, rather than appends, the existing environment.\n   *\n   * @default - Use current environment\n   */\n  readonly env?: Record<string, string>;\n\n  /**\n   * The working directory\n   *\n   * @default - Use default working directory\n   */\n  readonly cwd?: string;\n\n  /**\n   * Command to determine whether this command should be run\n   *\n   * If the test passes (exits with error code of 0), the command is run.\n   *\n   * @default - Always run the command\n   */\n  readonly testCmd?: string;\n\n  /**\n   * Continue running if this command fails\n   *\n   * @default false\n   */\n  readonly ignoreErrors?: boolean;\n\n  /**\n   * The duration to wait after a command has finished in case the command causes a reboot.\n   *\n   * Set this value to `InitCommandWaitDuration.none()` if you do not want to wait for every command;\n   * `InitCommandWaitDuration.forever()` directs cfn-init to exit and resume only after the reboot is complete.\n   *\n   * For Windows systems only.\n   *\n   * @default - 60 seconds\n   */\n  readonly waitAfterCompletion?: InitCommandWaitDuration;\n\n  /**\n   * Restart the given service(s) after this command has run\n   *\n   * @default - Do not restart any service\n   */\n  readonly serviceRestartHandles?: InitServiceRestartHandle[];\n}\n\n/**\n * Represents a duration to wait after a command has finished, in case of a reboot (Windows only).\n */\nexport abstract class InitCommandWaitDuration {\n  /** Wait for a specified duration after a command. */\n  public static of(duration: Duration): InitCommandWaitDuration {\n    return new class extends InitCommandWaitDuration {\n      /** @internal */\n      public _render() { return duration.toSeconds(); }\n    }();\n  }\n\n  /** Do not wait for this command. */\n  public static none(): InitCommandWaitDuration {\n    return InitCommandWaitDuration.of(Duration.seconds(0));\n  }\n\n  /** cfn-init will exit and resume only after a reboot. */\n  public static forever(): InitCommandWaitDuration {\n    return new class extends InitCommandWaitDuration {\n      /** @internal */\n      public _render() { return 'forever'; }\n    }();\n  }\n\n  /**\n   * Render to a CloudFormation value.\n   * @internal\n   */\n  public abstract _render(): any;\n}\n\n/**\n * Command to execute on the instance\n */\nexport class InitCommand extends InitElement {\n  /**\n   * Run a shell command\n   *\n   * Remember that some characters like `&`, `|`, `;`, `>` etc. have special meaning in a shell and\n   * need to be preceded by a `\\` if you want to treat them as part of a filename.\n   */\n  public static shellCommand(shellCommand: string, options: InitCommandOptions = {}): InitCommand {\n    return new InitCommand(shellCommand, options);\n  }\n\n  /**\n   * Run a command from an argv array\n   *\n   * You do not need to escape space characters or enclose command parameters in quotes.\n   */\n  public static argvCommand(argv: string[], options: InitCommandOptions = {}): InitCommand {\n    if (argv.length === 0) {\n      throw new Error('Cannot define argvCommand with an empty arguments');\n    }\n    return new InitCommand(argv, options);\n  }\n\n  public readonly elementType = InitElementType.COMMAND.toString();\n\n  private constructor(private readonly command: string[] | string, private readonly options: InitCommandOptions) {\n    super();\n  }\n\n  /** @internal */\n  public _bind(options: InitBindOptions): InitElementConfig {\n    const commandKey = this.options.key || `${options.index}`.padStart(3, '0'); // 001, 005, etc.\n\n    if (options.platform !== InitPlatform.WINDOWS && this.options.waitAfterCompletion !== undefined) {\n      throw new Error(`Command '${this.command}': 'waitAfterCompletion' is only valid for Windows systems.`);\n    }\n\n    for (const handle of this.options.serviceRestartHandles ?? []) {\n      handle._addCommand(commandKey);\n    }\n\n    return {\n      config: {\n        [commandKey]: {\n          command: this.command,\n          env: this.options.env,\n          cwd: this.options.cwd,\n          test: this.options.testCmd,\n          ignoreErrors: this.options.ignoreErrors,\n          waitAfterCompletion: this.options.waitAfterCompletion?._render(),\n        },\n      },\n    };\n  }\n\n}\n\n/**\n * Options for InitFile\n */\nexport interface InitFileOptions {\n  /**\n   * The name of the owning group for this file.\n   *\n   * Not supported for Windows systems.\n   *\n   * @default 'root'\n   */\n  readonly group?: string;\n\n  /**\n   * The name of the owning user for this file.\n   *\n   * Not supported for Windows systems.\n   *\n   * @default 'root'\n   */\n  readonly owner?: string;\n\n  /**\n   * A six-digit octal value representing the mode for this file.\n   *\n   * Use the first three digits for symlinks and the last three digits for\n   * setting permissions. To create a symlink, specify 120xxx, where xxx\n   * defines the permissions of the target file. To specify permissions for a\n   * file, use the last three digits, such as 000644.\n   *\n   * Not supported for Windows systems.\n   *\n   * @default '000644'\n   */\n  readonly mode?: string;\n\n  /**\n   * True if the inlined content (from a string or file) should be treated as base64 encoded.\n   * Only applicable for inlined string and file content.\n   *\n   * @default false\n   */\n  readonly base64Encoded?: boolean;\n\n  /**\n   * Restart the given service after this file has been written\n   *\n   * @default - Do not restart any service\n   */\n  readonly serviceRestartHandles?: InitServiceRestartHandle[];\n}\n\n/**\n * Additional options for creating an InitFile from an asset.\n */\nexport interface InitFileAssetOptions extends InitFileOptions, s3_assets.AssetOptions {\n}\n\n/**\n * Create files on the EC2 instance.\n */\nexport abstract class InitFile extends InitElement {\n\n  /**\n   * Use a literal string as the file content\n   */\n  public static fromString(fileName: string, content: string, options: InitFileOptions = {}): InitFile {\n    if (!content) {\n      throw new Error(`InitFile ${fileName}: cannot create empty file. Please supply at least one character of content.`);\n    }\n    return new class extends InitFile {\n      protected _doBind(bindOptions: InitBindOptions) {\n        return {\n          config: this._standardConfig(options, bindOptions.platform, {\n            content,\n            encoding: this.options.base64Encoded ? 'base64' : 'plain',\n          }),\n        };\n      }\n    }(fileName, options);\n  }\n\n  /**\n   * Write a symlink with the given symlink target\n   */\n  public static symlink(fileName: string, target: string, options: InitFileOptions = {}): InitFile {\n    const { mode, ...otherOptions } = options;\n    if (mode && mode.slice(0, 3) !== '120') {\n      throw new Error('File mode for symlinks must begin with 120XXX');\n    }\n    return InitFile.fromString(fileName, target, { mode: (mode || '120644'), ...otherOptions });\n  }\n\n  /**\n   * Use a JSON-compatible object as the file content, write it to a JSON file.\n   *\n   * May contain tokens.\n   */\n  public static fromObject(fileName: string, obj: Record<string, any>, options: InitFileOptions = {}): InitFile {\n    return new class extends InitFile {\n      protected _doBind(bindOptions: InitBindOptions) {\n        return {\n          config: this._standardConfig(options, bindOptions.platform, {\n            content: obj,\n          }),\n        };\n      }\n    }(fileName, options);\n  }\n\n  /**\n   * Read a file from disk and use its contents\n   *\n   * The file will be embedded in the template, so care should be taken to not\n   * exceed the template size.\n   *\n   * If options.base64encoded is set to true, this will base64-encode the file's contents.\n   */\n  public static fromFileInline(targetFileName: string, sourceFileName: string, options: InitFileOptions = {}): InitFile {\n    const encoding = options.base64Encoded ? 'base64' : 'utf8';\n    const fileContents = fs.readFileSync(sourceFileName).toString(encoding);\n    return InitFile.fromString(targetFileName, fileContents, options);\n  }\n\n  /**\n   * Download from a URL at instance startup time\n   */\n  public static fromUrl(fileName: string, url: string, options: InitFileOptions = {}): InitFile {\n    return new class extends InitFile {\n      protected _doBind(bindOptions: InitBindOptions) {\n        return {\n          config: this._standardConfig(options, bindOptions.platform, {\n            source: url,\n          }),\n        };\n      }\n    }(fileName, options);\n  }\n\n  /**\n   * Download a file from an S3 bucket at instance startup time\n   */\n  public static fromS3Object(fileName: string, bucket: s3.IBucket, key: string, options: InitFileOptions = {}): InitFile {\n    return new class extends InitFile {\n      protected _doBind(bindOptions: InitBindOptions) {\n        bucket.grantRead(bindOptions.instanceRole, key);\n        return {\n          config: this._standardConfig(options, bindOptions.platform, {\n            source: bucket.urlForObject(key),\n          }),\n          authentication: standardS3Auth(bindOptions.instanceRole, bucket.bucketName),\n        };\n      }\n    }(fileName, options);\n  }\n\n  /**\n   * Create an asset from the given file\n   *\n   * This is appropriate for files that are too large to embed into the template.\n   */\n  public static fromAsset(targetFileName: string, path: string, options: InitFileAssetOptions = {}): InitFile {\n    return new class extends InitFile {\n      protected _doBind(bindOptions: InitBindOptions) {\n        const asset = new s3_assets.Asset(bindOptions.scope, `${targetFileName}Asset`, {\n          path,\n          ...options,\n        });\n        asset.grantRead(bindOptions.instanceRole);\n\n        return {\n          config: this._standardConfig(options, bindOptions.platform, {\n            source: asset.httpUrl,\n          }),\n          authentication: standardS3Auth(bindOptions.instanceRole, asset.s3BucketName),\n          assetHash: asset.assetHash,\n        };\n      }\n    }(targetFileName, options);\n  }\n\n  /**\n   * Use a file from an asset at instance startup time\n   */\n  public static fromExistingAsset(targetFileName: string, asset: s3_assets.Asset, options: InitFileOptions = {}): InitFile {\n    return new class extends InitFile {\n      protected _doBind(bindOptions: InitBindOptions) {\n        asset.grantRead(bindOptions.instanceRole);\n        return {\n          config: this._standardConfig(options, bindOptions.platform, {\n            source: asset.httpUrl,\n          }),\n          authentication: standardS3Auth(bindOptions.instanceRole, asset.s3BucketName),\n          assetHash: asset.assetHash,\n        };\n      }\n    }(targetFileName, options);\n  }\n\n  public readonly elementType = InitElementType.FILE.toString();\n\n  protected constructor(private readonly fileName: string, private readonly options: InitFileOptions) {\n    super();\n  }\n\n  /** @internal */\n  public _bind(bindOptions: InitBindOptions): InitElementConfig {\n    for (const handle of this.options.serviceRestartHandles ?? []) {\n      handle._addFile(this.fileName);\n    }\n\n    return this._doBind(bindOptions);\n  }\n\n  /**\n   * Perform the actual bind and render\n   *\n   * This is in a second method so the superclass can guarantee that\n   * the common work of registering into serviceHandles cannot be forgotten.\n   * @internal\n   */\n  protected abstract _doBind(options: InitBindOptions): InitElementConfig;\n\n  /**\n   * Render the standard config block, given content vars\n   * @internal\n   */\n  protected _standardConfig(fileOptions: InitFileOptions, platform: InitPlatform, contentVars: Record<string, any>): Record<string, any> {\n    if (platform === InitPlatform.WINDOWS) {\n      if (fileOptions.group || fileOptions.owner || fileOptions.mode) {\n        throw new Error('Owner, group, and mode options not supported for Windows.');\n      }\n      return {\n        [this.fileName]: { ...contentVars },\n      };\n    }\n\n    return {\n      [this.fileName]: {\n        ...contentVars,\n        mode: fileOptions.mode || '000644',\n        owner: fileOptions.owner || 'root',\n        group: fileOptions.group || 'root',\n      },\n    };\n  }\n}\n\n/**\n * Create Linux/UNIX groups and assign group IDs.\n *\n * Not supported for Windows systems.\n */\nexport class InitGroup extends InitElement {\n\n  /**\n   * Create a group from its name, and optionally, group id\n   */\n  public static fromName(groupName: string, groupId?: number): InitGroup {\n    return new InitGroup(groupName, groupId);\n  }\n\n  public readonly elementType = InitElementType.GROUP.toString();\n\n  protected constructor(private groupName: string, private groupId?: number) {\n    super();\n  }\n\n  /** @internal */\n  public _bind(options: InitBindOptions): InitElementConfig {\n    if (options.platform === InitPlatform.WINDOWS) {\n      throw new Error('Init groups are not supported on Windows');\n    }\n\n    return {\n      config: {\n        [this.groupName]: this.groupId !== undefined ? { gid: this.groupId } : {},\n      },\n    };\n  }\n\n}\n\n/**\n * Optional parameters used when creating a user\n */\nexport interface InitUserOptions {\n  /**\n   * The user's home directory.\n   *\n   * @default assigned by the OS\n   */\n  readonly homeDir?: string;\n\n  /**\n   * A user ID. The creation process fails if the user name exists with a different user ID.\n   * If the user ID is already assigned to an existing user the operating system may\n   * reject the creation request.\n   *\n   * @default assigned by the OS\n   */\n  readonly userId?: number;\n\n  /**\n   * A list of group names. The user will be added to each group in the list.\n   *\n   * @default the user is not associated with any groups.\n   */\n  readonly groups?: string[];\n}\n\n/**\n * Create Linux/UNIX users and to assign user IDs.\n *\n * Users are created as non-interactive system users with a shell of\n * /sbin/nologin. This is by design and cannot be modified.\n *\n * Not supported for Windows systems.\n */\nexport class InitUser extends InitElement {\n  /**\n   * Create a user from user name.\n   */\n  public static fromName(userName: string, options: InitUserOptions = {}): InitUser {\n    return new InitUser(userName, options);\n  }\n\n  public readonly elementType = InitElementType.USER.toString();\n\n  protected constructor(private readonly userName: string, private readonly userOptions: InitUserOptions) {\n    super();\n  }\n\n  /** @internal */\n  public _bind(options: InitBindOptions): InitElementConfig {\n    if (options.platform === InitPlatform.WINDOWS) {\n      throw new Error('Init users are not supported on Windows');\n    }\n\n    return {\n      config: {\n        [this.userName]: {\n          uid: this.userOptions.userId,\n          groups: this.userOptions.groups,\n          homeDir: this.userOptions.homeDir,\n        },\n      },\n    };\n  }\n}\n\n/**\n * Options for InitPackage.rpm/InitPackage.msi\n */\nexport interface LocationPackageOptions {\n  /**\n   * Identifier key for this package\n   *\n   * You can use this to order package installs.\n   *\n   * @default - Automatically generated\n   */\n  readonly key?: string;\n\n  /**\n   * Restart the given service after this command has run\n   *\n   * @default - Do not restart any service\n   */\n  readonly serviceRestartHandles?: InitServiceRestartHandle[];\n}\n\n/**\n * Options for InitPackage.yum/apt/rubyGem/python\n */\nexport interface NamedPackageOptions {\n  /**\n   * Specify the versions to install\n   *\n   * @default - Install the latest version\n   */\n  readonly version?: string[];\n\n  /**\n   * Restart the given services after this command has run\n   *\n   * @default - Do not restart any service\n   */\n  readonly serviceRestartHandles?: InitServiceRestartHandle[];\n}\n\n/**\n * A package to be installed during cfn-init time\n */\nexport class InitPackage extends InitElement {\n  /**\n   * Install an RPM from an HTTP URL or a location on disk\n   */\n  public static rpm(location: string, options: LocationPackageOptions = {}): InitPackage {\n    return new InitPackage('rpm', [location], options.key, options.serviceRestartHandles);\n  }\n\n  /**\n   * Install a package using Yum\n   */\n  public static yum(packageName: string, options: NamedPackageOptions = {}): InitPackage {\n    return new InitPackage('yum', options.version ?? [], packageName, options.serviceRestartHandles);\n  }\n\n  /**\n   * Install a package from RubyGems\n   */\n  public static rubyGem(gemName: string, options: NamedPackageOptions = {}): InitPackage {\n    return new InitPackage('rubygems', options.version ?? [], gemName, options.serviceRestartHandles);\n  }\n\n  /**\n   * Install a package from PyPI\n   */\n  public static python(packageName: string, options: NamedPackageOptions = {}): InitPackage {\n    return new InitPackage('python', options.version ?? [], packageName, options.serviceRestartHandles);\n  }\n\n  /**\n   * Install a package using APT\n   */\n  public static apt(packageName: string, options: NamedPackageOptions = {}): InitPackage {\n    return new InitPackage('apt', options.version ?? [], packageName, options.serviceRestartHandles);\n  }\n\n  /**\n   * Install an MSI package from an HTTP URL or a location on disk\n   */\n  public static msi(location: string, options: LocationPackageOptions = {}): InitPackage {\n    // The MSI package version must be a string, not an array.\n    return new class extends InitPackage {\n      protected renderPackageVersions() { return location; }\n    }('msi', [location], options.key, options.serviceRestartHandles);\n  }\n\n  public readonly elementType = InitElementType.PACKAGE.toString();\n\n  protected constructor(\n    private readonly type: string,\n    private readonly versions: string[],\n    private readonly packageName?: string,\n    private readonly serviceHandles?: InitServiceRestartHandle[],\n  ) {\n    super();\n  }\n\n  /** @internal */\n  public _bind(options: InitBindOptions): InitElementConfig {\n    if ((this.type === 'msi') !== (options.platform === InitPlatform.WINDOWS)) {\n      if (this.type === 'msi') {\n        throw new Error('MSI installers are only supported on Windows systems.');\n      } else {\n        throw new Error('Windows only supports the MSI package type');\n      }\n    }\n\n    if (!this.packageName && !['rpm', 'msi'].includes(this.type)) {\n      throw new Error('Package name must be specified for all package types besides RPM and MSI.');\n    }\n\n    const packageName = this.packageName || `${options.index}`.padStart(3, '0');\n\n    for (const handle of this.serviceHandles ?? []) {\n      handle._addPackage(this.type, packageName);\n    }\n\n    return {\n      config: {\n        [this.type]: {\n          [packageName]: this.renderPackageVersions(),\n        },\n      },\n    };\n  }\n\n  protected renderPackageVersions(): any {\n    return this.versions;\n  }\n}\n\n/**\n * Options for an InitService\n */\nexport interface InitServiceOptions {\n  /**\n   * Enable or disable this service\n   *\n   * Set to true to ensure that the service will be started automatically upon boot.\n   *\n   * Set to false to ensure that the service will not be started automatically upon boot.\n   *\n   * @default - true if used in `InitService.enable()`, no change to service\n   * state if used in `InitService.fromOptions()`.\n   */\n  readonly enabled?: boolean;\n\n  /**\n   * Make sure this service is running or not running after cfn-init finishes.\n   *\n   * Set to true to ensure that the service is running after cfn-init finishes.\n   *\n   * Set to false to ensure that the service is not running after cfn-init finishes.\n   *\n   * @default - same value as `enabled`.\n   */\n  readonly ensureRunning?: boolean;\n\n  /**\n   * Restart service when the actions registered into the restartHandle have been performed\n   *\n   * Register actions into the restartHandle by passing it to `InitFile`, `InitCommand`,\n   * `InitPackage` and `InitSource` objects.\n   *\n   * @default - No files trigger restart\n   */\n  readonly serviceRestartHandle?: InitServiceRestartHandle;\n}\n\n/**\n * A services that be enabled, disabled or restarted when the instance is launched.\n */\nexport class InitService extends InitElement {\n  /**\n   * Enable and start the given service, optionally restarting it\n   */\n  public static enable(serviceName: string, options: InitServiceOptions = {}): InitService {\n    const { enabled, ensureRunning, ...otherOptions } = options;\n    return new InitService(serviceName, {\n      enabled: enabled ?? true,\n      ensureRunning: ensureRunning ?? enabled ?? true,\n      ...otherOptions,\n    });\n  }\n\n  /**\n   * Disable and stop the given service\n   */\n  public static disable(serviceName: string): InitService {\n    return new InitService(serviceName, { enabled: false, ensureRunning: false });\n  }\n\n  public readonly elementType = InitElementType.SERVICE.toString();\n\n  private constructor(private readonly serviceName: string, private readonly serviceOptions: InitServiceOptions) {\n    super();\n  }\n\n  /** @internal */\n  public _bind(options: InitBindOptions): InitElementConfig {\n    const serviceManager = options.platform === InitPlatform.LINUX ? 'sysvinit' : 'windows';\n\n    return {\n      config: {\n        [serviceManager]: {\n          [this.serviceName]: {\n            enabled: this.serviceOptions.enabled,\n            ensureRunning: this.serviceOptions.ensureRunning,\n            ...this.serviceOptions.serviceRestartHandle?._renderRestartHandles(),\n          },\n        },\n      },\n    };\n  }\n\n}\n\n/**\n * Additional options for an InitSource\n */\nexport interface InitSourceOptions {\n\n  /**\n   * Restart the given services after this archive has been extracted\n   *\n   * @default - Do not restart any service\n   */\n  readonly serviceRestartHandles?: InitServiceRestartHandle[];\n}\n\n/**\n * Additional options for an InitSource that builds an asset from local files.\n */\nexport interface InitSourceAssetOptions extends InitSourceOptions, s3_assets.AssetOptions {\n\n}\n\n/**\n * Extract an archive into a directory\n */\nexport abstract class InitSource extends InitElement {\n  /**\n   * Retrieve a URL and extract it into the given directory\n   */\n  public static fromUrl(targetDirectory: string, url: string, options: InitSourceOptions = {}): InitSource {\n    return new class extends InitSource {\n      protected _doBind() {\n        return {\n          config: { [this.targetDirectory]: url },\n        };\n      }\n    }(targetDirectory, options.serviceRestartHandles);\n  }\n\n  /**\n   * Extract a GitHub branch into a given directory\n   */\n  public static fromGitHub(targetDirectory: string, owner: string, repo: string, refSpec?: string, options: InitSourceOptions = {}): InitSource {\n    return InitSource.fromUrl(targetDirectory, `https://github.com/${owner}/${repo}/tarball/${refSpec ?? 'master'}`, options);\n  }\n\n  /**\n   * Extract an archive stored in an S3 bucket into the given directory\n   */\n  public static fromS3Object(targetDirectory: string, bucket: s3.IBucket, key: string, options: InitSourceOptions = {}): InitSource {\n    return new class extends InitSource {\n      protected _doBind(bindOptions: InitBindOptions) {\n        bucket.grantRead(bindOptions.instanceRole, key);\n\n        return {\n          config: { [this.targetDirectory]: bucket.urlForObject(key) },\n          authentication: standardS3Auth(bindOptions.instanceRole, bucket.bucketName),\n        };\n      }\n    }(targetDirectory, options.serviceRestartHandles);\n  }\n\n  /**\n   * Create an InitSource from an asset created from the given path.\n   */\n  public static fromAsset(targetDirectory: string, path: string, options: InitSourceAssetOptions = {}): InitSource {\n    return new class extends InitSource {\n      protected _doBind(bindOptions: InitBindOptions) {\n        const asset = new s3_assets.Asset(bindOptions.scope, `${targetDirectory}Asset`, {\n          path,\n          ...bindOptions,\n        });\n        asset.grantRead(bindOptions.instanceRole);\n\n        return {\n          config: { [this.targetDirectory]: asset.httpUrl },\n          authentication: standardS3Auth(bindOptions.instanceRole, asset.s3BucketName),\n          assetHash: asset.assetHash,\n        };\n      }\n    }(targetDirectory, options.serviceRestartHandles);\n  }\n\n  /**\n   * Extract a directory from an existing directory asset.\n   */\n  public static fromExistingAsset(targetDirectory: string, asset: s3_assets.Asset, options: InitSourceOptions = {}): InitSource {\n    return new class extends InitSource {\n      protected _doBind(bindOptions: InitBindOptions) {\n        asset.grantRead(bindOptions.instanceRole);\n\n        return {\n          config: { [this.targetDirectory]: asset.httpUrl },\n          authentication: standardS3Auth(bindOptions.instanceRole, asset.s3BucketName),\n          assetHash: asset.assetHash,\n        };\n      }\n    }(targetDirectory, options.serviceRestartHandles);\n  }\n\n  public readonly elementType = InitElementType.SOURCE.toString();\n\n  protected constructor(private readonly targetDirectory: string, private readonly serviceHandles?: InitServiceRestartHandle[]) {\n    super();\n  }\n\n  /** @internal */\n  public _bind(options: InitBindOptions): InitElementConfig {\n    for (const handle of this.serviceHandles ?? []) {\n      handle._addSource(this.targetDirectory);\n    }\n\n    // Delegate actual bind to subclasses\n    return this._doBind(options);\n  }\n\n  /**\n   * Perform the actual bind and render\n   *\n   * This is in a second method so the superclass can guarantee that\n   * the common work of registering into serviceHandles cannot be forgotten.\n   * @internal\n   */\n  protected abstract _doBind(options: InitBindOptions): InitElementConfig;\n}\n\n/**\n * Render a standard S3 auth block for use in AWS::CloudFormation::Authentication\n *\n * This block is the same every time (modulo bucket name), so it has the same\n * key every time so the blocks are merged into one in the final render.\n */\nfunction standardS3Auth(role: iam.IRole, bucketName: string) {\n  return {\n    S3AccessCreds: {\n      type: 'S3',\n      roleName: role.roleName,\n      buckets: [bucketName],\n    },\n  };\n}\n"],
  "mappings": "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",
  "names": []
}
