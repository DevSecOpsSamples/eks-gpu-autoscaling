{
  "version": 3,
  "sources": ["subnet.ts"],
  "sourcesContent": ["import { CidrBlock, NetworkUtils } from './network-util';\nimport { ISubnet } from './vpc';\n\n/**\n * Contains logic which chooses a set of subnets from a larger list, in conjunction\n * with SubnetSelection, to determine where to place AWS resources such as VPC\n * endpoints, EC2 instances, etc.\n */\nexport abstract class SubnetFilter {\n\n  /**\n   * Chooses subnets by id.\n   */\n  public static byIds(subnetIds: string[]): SubnetFilter {\n    return new SubnetIdSubnetFilter(subnetIds);\n  }\n\n  /**\n   * Chooses subnets which are in one of the given availability zones.\n  */\n  public static availabilityZones(availabilityZones: string[]): SubnetFilter {\n    return new AvailabilityZoneSubnetFilter(availabilityZones);\n  }\n\n  /**\n   * Chooses subnets such that there is at most one per availability zone.\n  */\n  public static onePerAz(): SubnetFilter {\n    return new OnePerAZSubnetFilter();\n  }\n\n  /**\n   * Chooses subnets which contain any of the specified IP addresses.\n  */\n  public static containsIpAddresses(ipv4addrs: string[]): SubnetFilter {\n    return new ContainsIpAddressesSubnetFilter(ipv4addrs);\n  }\n\n  /**\n   * Chooses subnets which have the provided CIDR netmask.\n   */\n  public static byCidrMask(mask: number): SubnetFilter {\n    return new CidrMaskSubnetFilter(mask);\n  }\n\n  /**\n   * Executes the subnet filtering logic, returning a filtered set of subnets.\n   */\n  public selectSubnets(_subnets: ISubnet[]): ISubnet[] {\n    throw new Error('Cannot select subnets with an abstract SubnetFilter. `selectSubnets` needs to be implmemented.');\n  }\n}\n\n/**\n * Chooses subnets which are in one of the given availability zones.\n */\nclass AvailabilityZoneSubnetFilter extends SubnetFilter {\n\n  private readonly availabilityZones: string[];\n\n  constructor(availabilityZones: string[]) {\n    super();\n    this.availabilityZones = availabilityZones;\n  }\n\n  /**\n   * Executes the subnet filtering logic.\n   */\n  public selectSubnets(subnets: ISubnet[]): ISubnet[] {\n    return subnets.filter(s => this.availabilityZones.includes(s.availabilityZone));\n  }\n}\n\n/**\n * Chooses subnets such that there is at most one per availability zone.\n */\nclass OnePerAZSubnetFilter extends SubnetFilter {\n\n  constructor() {\n    super();\n  }\n\n  /**\n   * Executes the subnet filtering logic.\n   */\n  public selectSubnets(subnets: ISubnet[]): ISubnet[] {\n    return this.retainOnePerAz(subnets);\n  }\n\n  private retainOnePerAz(subnets: ISubnet[]): ISubnet[] {\n    const azsSeen = new Set<string>();\n    return subnets.filter(subnet => {\n      if (azsSeen.has(subnet.availabilityZone)) { return false; }\n      azsSeen.add(subnet.availabilityZone);\n      return true;\n    });\n  }\n}\n\n/**\n * Chooses subnets which contain any of the specified IP addresses.\n */\nclass ContainsIpAddressesSubnetFilter extends SubnetFilter {\n\n  private readonly ipAddresses: string[];\n\n  constructor(ipAddresses: string[]) {\n    super();\n    this.ipAddresses = ipAddresses;\n  }\n\n  /**\n   * Executes the subnet filtering logic.\n   */\n  public selectSubnets(subnets: ISubnet[]): ISubnet[] {\n    return this.retainByIp(subnets, this.ipAddresses);\n  }\n\n  private retainByIp(subnets: ISubnet[], ips: string[]): ISubnet[] {\n    const cidrBlockObjs = ips.map(ip => {\n      const ipNum = NetworkUtils.ipToNum(ip);\n      return new CidrBlock(ipNum, 32);\n    });\n    return subnets.filter(s => {\n      const subnetCidrBlock = new CidrBlock(s.ipv4CidrBlock);\n      return cidrBlockObjs.some(cidr => subnetCidrBlock.containsCidr(cidr));\n    });\n  }\n}\n\n/**\n * Chooses subnets based on the subnetId\n */\nclass SubnetIdSubnetFilter extends SubnetFilter {\n\n  private readonly subnetIds: string[];\n\n  constructor(subnetIds: string[]) {\n    super();\n    this.subnetIds = subnetIds;\n  }\n\n  /**\n   * Executes the subnet filtering logic.\n   */\n  public selectSubnets(subnets: ISubnet[]): ISubnet[] {\n    return subnets.filter(subnet => this.subnetIds.includes(subnet.subnetId));\n  }\n}\n\n/**\n * Chooses subnets based on the CIDR Netmask\n */\nclass CidrMaskSubnetFilter extends SubnetFilter {\n  private readonly mask: number\n\n  constructor(mask: number) {\n    super();\n    this.mask = mask;\n  }\n\n  /**\n   * Executes the subnet filtering logic.\n   */\n  public selectSubnets(subnets: ISubnet[]): ISubnet[] {\n    return subnets.filter(subnet => {\n      const subnetCidr = new CidrBlock(subnet.ipv4CidrBlock);\n      return subnetCidr.mask === this.mask;\n    });\n  }\n}\n"],
  "mappings": "wJAAA,eAAA,QAAA,gBAAA,EAQA,MAAsB,YAAY,OAKlB,OAAM,UAAmB,CACrC,MAAO,IAAI,sBAAqB,SAAS,QAM7B,mBAAkB,kBAA2B,CACzD,MAAO,IAAI,8BAA6B,iBAAiB,QAM7C,WAAQ,CACpB,MAAO,IAAI,4BAMC,qBAAoB,UAAmB,CACnD,MAAO,IAAI,iCAAgC,SAAS,QAMxC,YAAW,KAAY,CACnC,MAAO,IAAI,sBAAqB,IAAI,EAM/B,cAAc,SAAmB,CACtC,KAAM,IAAI,OAAM,gGAAgG,GAzCpH,QAAA,aAAA,8GAgDA,MAAM,oCAAqC,aAAY,CAIrD,YAAY,kBAA2B,CACrC,MAAK,EACL,KAAK,kBAAoB,kBAMpB,cAAc,QAAkB,CACrC,MAAO,SAAQ,OAAO,GAAK,KAAK,kBAAkB,SAAS,EAAE,gBAAgB,CAAC,GAOlF,MAAM,4BAA6B,aAAY,CAE7C,aAAA,CACE,MAAK,EAMA,cAAc,QAAkB,CACrC,MAAO,MAAK,eAAe,OAAO,EAG5B,eAAe,QAAkB,CACvC,KAAM,SAAU,GAAI,KACpB,MAAO,SAAQ,OAAO,QAChB,QAAQ,IAAI,OAAO,gBAAgB,EAAY,GACnD,SAAQ,IAAI,OAAO,gBAAgB,EAC5B,GACR,GAOL,MAAM,uCAAwC,aAAY,CAIxD,YAAY,YAAqB,CAC/B,MAAK,EACL,KAAK,YAAc,YAMd,cAAc,QAAkB,CACrC,MAAO,MAAK,WAAW,QAAS,KAAK,WAAW,EAG1C,WAAW,QAAoB,IAAa,CAClD,KAAM,eAAgB,IAAI,IAAI,IAAK,CACjC,KAAM,OAAQ,eAAA,aAAa,QAAQ,EAAE,EACrC,MAAO,IAAI,gBAAA,UAAU,MAAO,EAAE,CAChC,CAAC,EACD,MAAO,SAAQ,OAAO,GAAI,CACxB,KAAM,iBAAkB,GAAI,gBAAA,UAAU,EAAE,aAAa,EACrD,MAAO,eAAc,KAAK,MAAQ,gBAAgB,aAAa,IAAI,CAAC,CACtE,CAAC,GAOL,MAAM,4BAA6B,aAAY,CAI7C,YAAY,UAAmB,CAC7B,MAAK,EACL,KAAK,UAAY,UAMZ,cAAc,QAAkB,CACrC,MAAO,SAAQ,OAAO,QAAU,KAAK,UAAU,SAAS,OAAO,QAAQ,CAAC,GAO5E,MAAM,4BAA6B,aAAY,CAG7C,YAAY,KAAY,CACtB,MAAK,EACL,KAAK,KAAO,KAMP,cAAc,QAAkB,CACrC,MAAO,SAAQ,OAAO,QAEb,AADY,GAAI,gBAAA,UAAU,OAAO,aAAa,EACnC,OAAS,KAAK,IACjC",
  "names": []
}
