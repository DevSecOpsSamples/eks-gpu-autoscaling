{
  "version": 3,
  "sources": ["nat.ts"],
  "sourcesContent": ["import * as iam from '../../aws-iam';\nimport { Fn, Token } from '../../core';\nimport { Connections, IConnectable } from './connections';\nimport { Instance } from './instance';\nimport { InstanceType } from './instance-types';\nimport { IMachineImage, LookupMachineImage } from './machine-image';\nimport { Port } from './port';\nimport { ISecurityGroup, SecurityGroup } from './security-group';\nimport { PrivateSubnet, PublicSubnet, RouterType, Vpc } from './vpc';\n\n/**\n * Direction of traffic to allow all by default.\n */\nexport enum NatTrafficDirection {\n  /**\n   * Allow all outbound traffic and disallow all inbound traffic.\n   */\n  OUTBOUND_ONLY = 'OUTBOUND_ONLY',\n\n  /**\n   * Allow all outbound and inbound traffic.\n   */\n  INBOUND_AND_OUTBOUND = 'INBOUND_AND_OUTBOUND',\n\n  /**\n   * Disallow all outbound and inbound traffic.\n   */\n  NONE = 'NONE',\n}\n\n/**\n * Pair represents a gateway created by NAT Provider\n */\nexport interface GatewayConfig {\n\n  /**\n   * Availability Zone\n   */\n  readonly az: string\n\n  /**\n   * Identity of gateway spawned by the provider\n   */\n  readonly gatewayId: string\n}\n\n/**\n * NAT providers\n *\n * Determines what type of NAT provider to create, either NAT gateways or NAT\n * instance.\n *\n *\n */\nexport abstract class NatProvider {\n  /**\n   * Use NAT Gateways to provide NAT services for your VPC\n   *\n   * NAT gateways are managed by AWS.\n   *\n   * @see https://docs.aws.amazon.com/vpc/latest/userguide/vpc-nat-gateway.html\n   */\n  public static gateway(props: NatGatewayProps = {}): NatProvider {\n    return new NatGatewayProvider(props);\n  }\n\n  /**\n   * Use NAT instances to provide NAT services for your VPC\n   *\n   * NAT instances are managed by you, but in return allow more configuration.\n   *\n   * Be aware that instances created using this provider will not be\n   * automatically replaced if they are stopped for any reason. You should implement\n   * your own NatProvider based on AutoScaling groups if you need that.\n   *\n   * @see https://docs.aws.amazon.com/vpc/latest/userguide/VPC_NAT_Instance.html\n   */\n  public static instance(props: NatInstanceProps): NatInstanceProvider {\n    return new NatInstanceProvider(props);\n  }\n\n  /**\n   * Return list of gateways spawned by the provider\n   */\n  public abstract readonly configuredGateways: GatewayConfig[];\n\n  /**\n   * Called by the VPC to configure NAT\n   *\n   * Don't call this directly, the VPC will call it automatically.\n   */\n  public abstract configureNat(options: ConfigureNatOptions): void;\n\n  /**\n   * Configures subnet with the gateway\n   *\n   * Don't call this directly, the VPC will call it automatically.\n   */\n  public abstract configureSubnet(subnet: PrivateSubnet): void;\n}\n\n/**\n * Options passed by the VPC when NAT needs to be configured\n *\n *\n */\nexport interface ConfigureNatOptions {\n  /**\n   * The VPC we're configuring NAT for\n   */\n  readonly vpc: Vpc;\n\n  /**\n   * The public subnets where the NAT providers need to be placed\n   */\n  readonly natSubnets: PublicSubnet[];\n\n  /**\n   * The private subnets that need to route through the NAT providers.\n   *\n   * There may be more private subnets than public subnets with NAT providers.\n   */\n  readonly privateSubnets: PrivateSubnet[];\n}\n\n/**\n * Properties for a NAT gateway\n *\n */\nexport interface NatGatewayProps {\n  /**\n   * EIP allocation IDs for the NAT gateways\n   *\n   * @default - No fixed EIPs allocated for the NAT gateways\n   */\n  readonly eipAllocationIds?: string[];\n}\n\n/**\n * Properties for a NAT instance\n *\n *\n */\nexport interface NatInstanceProps {\n  /**\n   * The machine image (AMI) to use\n   *\n   * By default, will do an AMI lookup for the latest NAT instance image.\n   *\n   * If you have a specific AMI ID you want to use, pass a `GenericLinuxImage`. For example:\n   *\n   * ```ts\n   * ec2.NatProvider.instance({\n   *   instanceType: new ec2.InstanceType('t3.micro'),\n   *   machineImage: new ec2.GenericLinuxImage({\n   *     'us-east-2': 'ami-0f9c61b5a562a16af'\n   *   })\n   * })\n   * ```\n   *\n   * @default - Latest NAT instance image\n   */\n  readonly machineImage?: IMachineImage;\n\n  /**\n   * Instance type of the NAT instance\n   */\n  readonly instanceType: InstanceType;\n\n  /**\n   * Name of SSH keypair to grant access to instance\n   *\n   * @default - No SSH access will be possible.\n   */\n  readonly keyName?: string;\n\n  /**\n   * Security Group for NAT instances\n   *\n   * @default - A new security group will be created\n   */\n  readonly securityGroup?: ISecurityGroup;\n\n  /**\n   * Allow all inbound traffic through the NAT instance\n   *\n   * If you set this to false, you must configure the NAT instance's security\n   * groups in another way, either by passing in a fully configured Security\n   * Group using the `securityGroup` property, or by configuring it using the\n   * `.securityGroup` or `.connections` members after passing the NAT Instance\n   * Provider to a Vpc.\n   *\n   * @default true\n   * @deprecated - Use `defaultAllowedTraffic`.\n   */\n  readonly allowAllTraffic?: boolean;\n\n  /**\n   * Direction to allow all traffic through the NAT instance by default.\n   *\n   * By default, inbound and outbound traffic is allowed.\n   *\n   * If you set this to another value than INBOUND_AND_OUTBOUND, you must\n   * configure the NAT instance's security groups in another way, either by\n   * passing in a fully configured Security Group using the `securityGroup`\n   * property, or by configuring it using the `.securityGroup` or\n   * `.connections` members after passing the NAT Instance Provider to a Vpc.\n   *\n   * @default NatTrafficDirection.INBOUND_AND_OUTBOUND\n   */\n  readonly defaultAllowedTraffic?: NatTrafficDirection;\n}\n\n/**\n * Provider for NAT Gateways\n */\nclass NatGatewayProvider extends NatProvider {\n  private gateways: PrefSet<string> = new PrefSet<string>();\n\n  constructor(private readonly props: NatGatewayProps = {}) {\n    super();\n  }\n\n  public configureNat(options: ConfigureNatOptions) {\n    if (\n      this.props.eipAllocationIds != null\n      && !Token.isUnresolved(this.props.eipAllocationIds)\n      && this.props.eipAllocationIds.length < options.natSubnets.length\n    ) {\n      throw new Error(`Not enough NAT gateway EIP allocation IDs (${this.props.eipAllocationIds.length} provided) for the requested subnet count (${options.natSubnets.length} needed).`);\n    }\n\n    // Create the NAT gateways\n    let i = 0;\n    for (const sub of options.natSubnets) {\n      const eipAllocationId = this.props.eipAllocationIds ? pickN(i, this.props.eipAllocationIds) : undefined;\n      const gateway = sub.addNatGateway(eipAllocationId);\n      this.gateways.add(sub.availabilityZone, gateway.ref);\n      i++;\n    }\n\n    // Add routes to them in the private subnets\n    for (const sub of options.privateSubnets) {\n      this.configureSubnet(sub);\n    }\n  }\n\n  public configureSubnet(subnet: PrivateSubnet) {\n    const az = subnet.availabilityZone;\n    const gatewayId = this.gateways.pick(az);\n    subnet.addRoute('DefaultRoute', {\n      routerType: RouterType.NAT_GATEWAY,\n      routerId: gatewayId,\n      enablesInternetConnectivity: true,\n    });\n  }\n\n  public get configuredGateways(): GatewayConfig[] {\n    return this.gateways.values().map(x => ({ az: x[0], gatewayId: x[1] }));\n  }\n}\n\n/**\n * NAT provider which uses NAT Instances\n */\nexport class NatInstanceProvider extends NatProvider implements IConnectable {\n  private gateways: PrefSet<Instance> = new PrefSet<Instance>();\n  private _securityGroup?: ISecurityGroup;\n  private _connections?: Connections;\n\n  constructor(private readonly props: NatInstanceProps) {\n    super();\n\n    if (props.defaultAllowedTraffic !== undefined && props.allowAllTraffic !== undefined) {\n      throw new Error('Can not specify both of \\'defaultAllowedTraffic\\' and \\'defaultAllowedTraffic\\'; prefer \\'defaultAllowedTraffic\\'');\n    }\n  }\n\n  public configureNat(options: ConfigureNatOptions) {\n    const defaultDirection = this.props.defaultAllowedTraffic ??\n      (this.props.allowAllTraffic ?? true ? NatTrafficDirection.INBOUND_AND_OUTBOUND : NatTrafficDirection.OUTBOUND_ONLY);\n\n    // Create the NAT instances. They can share a security group and a Role.\n    const machineImage = this.props.machineImage || new NatInstanceImage();\n    this._securityGroup = this.props.securityGroup ?? new SecurityGroup(options.vpc, 'NatSecurityGroup', {\n      vpc: options.vpc,\n      description: 'Security Group for NAT instances',\n      allowAllOutbound: isOutboundAllowed(defaultDirection),\n    });\n    this._connections = new Connections({ securityGroups: [this._securityGroup] });\n\n    if (isInboundAllowed(defaultDirection)) {\n      this.connections.allowFromAnyIpv4(Port.allTraffic());\n    }\n\n    // FIXME: Ideally, NAT instances don't have a role at all, but\n    // 'Instance' does not allow that right now.\n    const role = new iam.Role(options.vpc, 'NatRole', {\n      assumedBy: new iam.ServicePrincipal('ec2.amazonaws.com'),\n    });\n\n    for (const sub of options.natSubnets) {\n      const natInstance = new Instance(sub, 'NatInstance', {\n        instanceType: this.props.instanceType,\n        machineImage,\n        sourceDestCheck: false, // Required for NAT\n        vpc: options.vpc,\n        vpcSubnets: { subnets: [sub] },\n        securityGroup: this._securityGroup,\n        role,\n        keyName: this.props.keyName,\n      });\n      // NAT instance routes all traffic, both ways\n      this.gateways.add(sub.availabilityZone, natInstance);\n    }\n\n    // Add routes to them in the private subnets\n    for (const sub of options.privateSubnets) {\n      this.configureSubnet(sub);\n    }\n  }\n\n  /**\n   * The Security Group associated with the NAT instances\n   */\n  public get securityGroup(): ISecurityGroup {\n    if (!this._securityGroup) {\n      throw new Error('Pass the NatInstanceProvider to a Vpc before accessing \\'securityGroup\\'');\n    }\n    return this._securityGroup;\n  }\n\n  /**\n   * Manage the Security Groups associated with the NAT instances\n   */\n  public get connections(): Connections {\n    if (!this._connections) {\n      throw new Error('Pass the NatInstanceProvider to a Vpc before accessing \\'connections\\'');\n    }\n    return this._connections;\n  }\n\n  public get configuredGateways(): GatewayConfig[] {\n    return this.gateways.values().map(x => ({ az: x[0], gatewayId: x[1].instanceId }));\n  }\n\n  public configureSubnet(subnet: PrivateSubnet) {\n    const az = subnet.availabilityZone;\n    const gatewayId = this.gateways.pick(az).instanceId;\n    subnet.addRoute('DefaultRoute', {\n      routerType: RouterType.INSTANCE,\n      routerId: gatewayId,\n      enablesInternetConnectivity: true,\n    });\n  }\n}\n\n/**\n * Preferential set\n *\n * Picks the value with the given key if available, otherwise distributes\n * evenly among the available options.\n */\nclass PrefSet<A> {\n  private readonly map: Record<string, A> = {};\n  private readonly vals = new Array<[string, A]>();\n  private next: number = 0;\n\n  public add(pref: string, value: A) {\n    this.map[pref] = value;\n    this.vals.push([pref, value]);\n  }\n\n  public pick(pref: string): A {\n    if (this.vals.length === 0) {\n      throw new Error('Cannot pick, set is empty');\n    }\n\n    if (pref in this.map) { return this.map[pref]; }\n    return this.vals[this.next++ % this.vals.length][1];\n  }\n\n  public values(): Array<[string, A]> {\n    return this.vals;\n  }\n}\n\n/**\n * Machine image representing the latest NAT instance image\n *\n *\n */\nexport class NatInstanceImage extends LookupMachineImage {\n  constructor() {\n    super({\n      name: 'amzn-ami-vpc-nat-*',\n      owners: ['amazon'],\n    });\n  }\n}\n\nfunction isOutboundAllowed(direction: NatTrafficDirection) {\n  return direction === NatTrafficDirection.INBOUND_AND_OUTBOUND ||\n    direction === NatTrafficDirection.OUTBOUND_ONLY;\n}\n\nfunction isInboundAllowed(direction: NatTrafficDirection) {\n  return direction === NatTrafficDirection.INBOUND_AND_OUTBOUND;\n}\n\n/**\n * Token-aware pick index function\n */\nfunction pickN(i: number, xs: string[]) {\n  if (Token.isUnresolved(xs)) { return Fn.select(i, xs); }\n\n  if (i >= xs.length) {\n    throw new Error(`Cannot get element ${i} from ${xs}`);\n  }\n\n  return xs[i];\n}\n"],
  "mappings": "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",
  "names": []
}
