{
  "version": 3,
  "sources": ["security-group.ts"],
  "sourcesContent": ["import * as cxschema from '../../cloud-assembly-schema';\nimport { Annotations, ContextProvider, IResource, Lazy, Names, Resource, ResourceProps, Stack, Token } from '../../core';\nimport * as cxapi from '../../cx-api';\nimport { Construct } from 'constructs';\nimport { Connections } from './connections';\nimport { CfnSecurityGroup, CfnSecurityGroupEgress, CfnSecurityGroupIngress } from './ec2.generated';\nimport { IPeer, Peer } from './peer';\nimport { Port } from './port';\nimport { IVpc } from './vpc';\n\nconst SECURITY_GROUP_SYMBOL = Symbol.for('@aws-cdk/iam.SecurityGroup');\n\nconst SECURITY_GROUP_DISABLE_INLINE_RULES_CONTEXT_KEY = '@aws-cdk/aws-ec2.securityGroupDisableInlineRules';\n\n/**\n * Interface for security group-like objects\n */\nexport interface ISecurityGroup extends IResource, IPeer {\n  /**\n   * ID for the current security group\n   * @attribute\n   */\n  readonly securityGroupId: string;\n\n  /**\n   * Whether the SecurityGroup has been configured to allow all outbound traffic\n   */\n  readonly allowAllOutbound: boolean;\n\n  /**\n   * Add an ingress rule for the current security group\n   *\n   * `remoteRule` controls where the Rule object is created if the peer is also a\n   * securityGroup and they are in different stack. If false (default) the\n   * rule object is created under the current SecurityGroup object. If true and the\n   * peer is also a SecurityGroup, the rule object is created under the remote\n   * SecurityGroup object.\n   */\n  addIngressRule(peer: IPeer, connection: Port, description?: string, remoteRule?: boolean): void;\n\n  /**\n   * Add an egress rule for the current security group\n   *\n   * `remoteRule` controls where the Rule object is created if the peer is also a\n   * securityGroup and they are in different stack. If false (default) the\n   * rule object is created under the current SecurityGroup object. If true and the\n   * peer is also a SecurityGroup, the rule object is created under the remote\n   * SecurityGroup object.\n   */\n  addEgressRule(peer: IPeer, connection: Port, description?: string, remoteRule?: boolean): void;\n}\n\n/**\n * A SecurityGroup that is not created in this template\n */\nabstract class SecurityGroupBase extends Resource implements ISecurityGroup {\n  /**\n   * Return whether the indicated object is a security group\n   */\n  public static isSecurityGroup(x: any): x is SecurityGroupBase {\n    return SECURITY_GROUP_SYMBOL in x;\n  }\n\n  public abstract readonly securityGroupId: string;\n  public abstract readonly allowAllOutbound: boolean;\n\n  public readonly canInlineRule = false;\n  public readonly connections: Connections = new Connections({ securityGroups: [this] });\n  public readonly defaultPort?: Port;\n\n  private peerAsTokenCount: number = 0;\n\n  constructor(scope: Construct, id: string, props?: ResourceProps) {\n    super(scope, id, props);\n\n    Object.defineProperty(this, SECURITY_GROUP_SYMBOL, { value: true });\n  }\n\n  public get uniqueId() {\n    return Names.nodeUniqueId(this.node);\n  }\n\n  public addIngressRule(peer: IPeer, connection: Port, description?: string, remoteRule?: boolean) {\n    if (description === undefined) {\n      description = `from ${peer.uniqueId}:${connection}`;\n    }\n\n    const [scope, id] = this.determineRuleScope(peer, connection, 'from', remoteRule);\n\n    // Skip duplicates\n    if (scope.node.tryFindChild(id) === undefined) {\n      new CfnSecurityGroupIngress(scope, id, {\n        groupId: this.securityGroupId,\n        ...peer.toIngressRuleConfig(),\n        ...connection.toRuleJson(),\n        description,\n      });\n    }\n  }\n\n  public addEgressRule(peer: IPeer, connection: Port, description?: string, remoteRule?: boolean) {\n    if (description === undefined) {\n      description = `to ${peer.uniqueId}:${connection}`;\n    }\n\n    const [scope, id] = this.determineRuleScope(peer, connection, 'to', remoteRule);\n\n    // Skip duplicates\n    if (scope.node.tryFindChild(id) === undefined) {\n      new CfnSecurityGroupEgress(scope, id, {\n        groupId: this.securityGroupId,\n        ...peer.toEgressRuleConfig(),\n        ...connection.toRuleJson(),\n        description,\n      });\n    }\n  }\n\n  public toIngressRuleConfig(): any {\n    return { sourceSecurityGroupId: this.securityGroupId };\n  }\n\n  public toEgressRuleConfig(): any {\n    return { destinationSecurityGroupId: this.securityGroupId };\n  }\n\n  /**\n   * Determine where to parent a new ingress/egress rule\n   *\n   * A SecurityGroup rule is parented under the group it's related to, UNLESS\n   * we're in a cross-stack scenario with another Security Group. In that case,\n   * we respect the 'remoteRule' flag and will parent under the other security\n   * group.\n   *\n   * This is necessary to avoid cyclic dependencies between stacks, since both\n   * ingress and egress rules will reference both security groups, and a naive\n   * parenting will lead to the following situation:\n   *\n   *   \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557         \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n   *   \u2551  \u250C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u2551         \u2551    \u250C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2551\n   *   \u2551  \u2502  GroupA   \u2502\u25C0\u2500\u2500\u2500\u2500\u256C\u2500\u2510   \u250C\u2500\u2500\u2500\u256C\u2500\u2500\u2500\u25B6\u2502  GroupB   \u2502   \u2551\n   *   \u2551  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2551 \u2502   \u2502   \u2551    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2551\n   *   \u2551        \u25B2           \u2551 \u2502   \u2502   \u2551          \u25B2         \u2551\n   *   \u2551        \u2502           \u2551 \u2502   \u2502   \u2551          \u2502         \u2551\n   *   \u2551        \u2502           \u2551 \u2502   \u2502   \u2551          \u2502         \u2551\n   *   \u2551  \u250C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u2551 \u2514\u2500\u2500\u2500\u253C\u2500\u2500\u2500\u256C\u2500\u2500\u2500\u2500\u250C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2551\n   *   \u2551  \u2502  EgressA  \u2502\u2500\u2500\u2500\u2500\u2500\u256C\u2500\u2500\u2500\u2500\u2500\u2518   \u2551    \u2502 IngressB  \u2502   \u2551\n   *   \u2551  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2551         \u2551    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2551\n   *   \u2551                    \u2551         \u2551                    \u2551\n   *   \u255A\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255D         \u255A\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255D\n   *\n   * By having the ability to switch the parent, we avoid the cyclic reference by\n   * keeping all rules in a single stack.\n   *\n   * If this happens, we also have to change the construct ID, because\n   * otherwise we might have two objects with the same ID if we have\n   * multiple reversed security group relationships.\n   *\n   *   \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n   *   \u2551\u250C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                      \u2551\n   *   \u2551\u2502  GroupB   \u2502                      \u2551\n   *   \u2551\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                      \u2551\n   *   \u2551      \u25B2                            \u2551\n   *   \u2551      \u2502              \u250C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2551\n   *   \u2551      \u251C\u2500\u2500\u2500\u2500\"from A\"\u2500\u2500\u2502 IngressB  \u2502 \u2551\n   *   \u2551      \u2502              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2551\n   *   \u2551      \u2502              \u250C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2551\n   *   \u2551      \u251C\u2500\u2500\u2500\u2500\u2500\"to B\"\u2500\u2500\u2500\u2502  EgressA  \u2502 \u2551\n   *   \u2551      \u2502              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2551\n   *   \u2551      \u2502              \u250C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2551\n   *   \u2551      \u2514\u2500\u2500\u2500\u2500\u2500\"to B\"\u2500\u2500\u2500\u2502  EgressC  \u2502 \u2551  <-- oops\n   *   \u2551                     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2551\n   *   \u255A\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255D\n   */\n\n  protected determineRuleScope(\n    peer: IPeer,\n    connection: Port,\n    fromTo: 'from' | 'to',\n    remoteRule?: boolean): [SecurityGroupBase, string] {\n\n    if (remoteRule && SecurityGroupBase.isSecurityGroup(peer) && differentStacks(this, peer)) {\n      // Reversed\n      const reversedFromTo = fromTo === 'from' ? 'to' : 'from';\n      return [peer, `${this.uniqueId}:${connection} ${reversedFromTo}`];\n    } else {\n      // Regular (do old ID escaping to in order to not disturb existing deployments)\n      return [this, `${fromTo} ${this.renderPeer(peer)}:${connection}`.replace('/', '_')];\n    }\n  }\n\n  private renderPeer(peer: IPeer) {\n    if (Token.isUnresolved(peer.uniqueId)) {\n      // Need to return a unique value each time a peer\n      // is an unresolved token, else the duplicate skipper\n      // in `sg.addXxxRule` can detect unique rules as duplicates\n      return this.peerAsTokenCount++ ? `'{IndirectPeer${this.peerAsTokenCount}}'` : '{IndirectPeer}';\n    } else {\n      return peer.uniqueId;\n    }\n  }\n}\n\nfunction differentStacks(group1: SecurityGroupBase, group2: SecurityGroupBase) {\n  return Stack.of(group1) !== Stack.of(group2);\n}\n\nexport interface SecurityGroupProps {\n  /**\n   * The name of the security group. For valid values, see the GroupName\n   * parameter of the CreateSecurityGroup action in the Amazon EC2 API\n   * Reference.\n   *\n   * It is not recommended to use an explicit group name.\n   *\n   * @default If you don't specify a GroupName, AWS CloudFormation generates a\n   * unique physical ID and uses that ID for the group name.\n   */\n  readonly securityGroupName?: string;\n\n  /**\n   * A description of the security group.\n   *\n   * @default The default name will be the construct's CDK path.\n   */\n  readonly description?: string;\n\n  /**\n   * The VPC in which to create the security group.\n   */\n  readonly vpc: IVpc;\n\n  /**\n   * Whether to allow all outbound traffic by default.\n   *\n   * If this is set to true, there will only be a single egress rule which allows all\n   * outbound traffic. If this is set to false, no outbound traffic will be allowed by\n   * default and all egress traffic must be explicitly authorized.\n   *\n   * @default true\n   */\n  readonly allowAllOutbound?: boolean;\n\n  /**\n   * Whether to disable inline ingress and egress rule optimization.\n   *\n   * If this is set to true, ingress and egress rules will not be declared under the\n   * SecurityGroup in cloudformation, but will be separate elements.\n   *\n   * Inlining rules is an optimization for producing smaller stack templates. Sometimes\n   * this is not desirable, for example when security group access is managed via tags.\n   *\n   * The default value can be overriden globally by setting the context variable\n   * '@aws-cdk/aws-ec2.securityGroupDisableInlineRules'.\n   *\n   * @default false\n   */\n  readonly disableInlineRules?: boolean;\n}\n\n/**\n * Additional options for imported security groups\n */\nexport interface SecurityGroupImportOptions {\n  /**\n   * Mark the SecurityGroup as having been created allowing all outbound traffic\n   *\n   * Only if this is set to false will egress rules be added to this security\n   * group. Be aware, this would undo any potential \"all outbound traffic\"\n   * default.\n   *\n   *\n   * @default true\n   */\n  readonly allowAllOutbound?: boolean;\n\n  /**\n   * If a SecurityGroup is mutable CDK can add rules to existing groups\n   *\n   * Beware that making a SecurityGroup immutable might lead to issue\n   * due to missing ingress/egress rules for new resources.\n   *\n   *\n   * @default true\n   */\n  readonly mutable?: boolean;\n}\n\n/**\n * Creates an Amazon EC2 security group within a VPC.\n *\n * Security Groups act like a firewall with a set of rules, and are associated\n * with any AWS resource that has or creates Elastic Network Interfaces (ENIs).\n * A typical example of a resource that has a security group is an Instance (or\n * Auto Scaling Group of instances)\n *\n * If you are defining new infrastructure in CDK, there is a good chance you\n * won't have to interact with this class at all. Like IAM Roles, Security\n * Groups need to exist to control access between AWS resources, but CDK will\n * automatically generate and populate them with least-privilege permissions\n * for you so you can concentrate on your business logic.\n *\n * All Constructs that require Security Groups will create one for you if you\n * don't specify one at construction. After construction, you can selectively\n * allow connections to and between constructs via--for example-- the `instance.connections`\n * object. Think of it as \"allowing connections to your instance\", rather than\n * \"adding ingress rules a security group\". See the [Allowing\n * Connections](https://docs.aws.amazon.com/cdk/api/latest/docs/aws-ec2-readme.html#allowing-connections)\n * section in the library documentation for examples.\n *\n * Direct manipulation of the Security Group through `addIngressRule` and\n * `addEgressRule` is possible, but mutation through the `.connections` object\n * is recommended. If you peer two constructs with security groups this way,\n * appropriate rules will be created in both.\n *\n * If you have an existing security group you want to use in your CDK application,\n * you would import it like this:\n *\n * ```ts\n * const securityGroup = ec2.SecurityGroup.fromSecurityGroupId(this, 'SG', 'sg-12345', {\n *   mutable: false\n * });\n * ```\n */\nexport class SecurityGroup extends SecurityGroupBase {\n  /**\n   * Look up a security group by id.\n   *\n   * @deprecated Use `fromLookupById()` instead\n   */\n  public static fromLookup(scope: Construct, id: string, securityGroupId: string) {\n    return this.fromLookupAttributes(scope, id, { securityGroupId });\n  }\n\n  /**\n   * Look up a security group by id.\n   */\n  public static fromLookupById(scope: Construct, id: string, securityGroupId: string) {\n    return this.fromLookupAttributes(scope, id, { securityGroupId });\n  }\n\n  /**\n   * Look up a security group by name.\n   */\n  public static fromLookupByName(scope: Construct, id: string, securityGroupName: string, vpc: IVpc) {\n    return this.fromLookupAttributes(scope, id, { securityGroupName, vpc });\n  }\n\n  /**\n   * Import an existing security group into this app.\n   *\n   * This method will assume that the Security Group has a rule in it which allows\n   * all outbound traffic, and so will not add egress rules to the imported Security\n   * Group (only ingress rules).\n   *\n   * If your existing Security Group needs to have egress rules added, pass the\n   * `allowAllOutbound: false` option on import.\n   */\n  public static fromSecurityGroupId(scope: Construct, id: string, securityGroupId: string, options: SecurityGroupImportOptions = {}): ISecurityGroup {\n    class MutableImport extends SecurityGroupBase {\n      public securityGroupId = securityGroupId;\n      public allowAllOutbound = options.allowAllOutbound ?? true;\n\n      public addEgressRule(peer: IPeer, connection: Port, description?: string, remoteRule?: boolean) {\n        // Only if allowAllOutbound has been disabled\n        if (options.allowAllOutbound === false) {\n          super.addEgressRule(peer, connection, description, remoteRule);\n        }\n      }\n    }\n\n    class ImmutableImport extends SecurityGroupBase {\n      public securityGroupId = securityGroupId;\n      public allowAllOutbound = options.allowAllOutbound ?? true;\n\n      public addEgressRule(_peer: IPeer, _connection: Port, _description?: string, _remoteRule?: boolean) {\n        // do nothing\n      }\n\n      public addIngressRule(_peer: IPeer, _connection: Port, _description?: string, _remoteRule?: boolean) {\n        // do nothing\n      }\n    }\n\n    return options.mutable !== false\n      ? new MutableImport(scope, id)\n      : new ImmutableImport(scope, id);\n  }\n\n  /**\n   * Look up a security group.\n   */\n  private static fromLookupAttributes(scope: Construct, id: string, options: SecurityGroupLookupOptions) {\n    if (Token.isUnresolved(options.securityGroupId) ||\u00A0Token.isUnresolved(options.securityGroupName) || Token.isUnresolved(options.vpc?.vpcId)) {\n      throw new Error('All arguments to look up a security group must be concrete (no Tokens)');\n    }\n\n    const attributes: cxapi.SecurityGroupContextResponse = ContextProvider.getValue(scope, {\n      provider: cxschema.ContextProvider.SECURITY_GROUP_PROVIDER,\n      props: {\n        securityGroupId: options.securityGroupId,\n        securityGroupName: options.securityGroupName,\n        vpcId: options.vpc?.vpcId,\n      },\n      dummyValue: {\n        securityGroupId: 'sg-12345',\n        allowAllOutbound: true,\n      } as cxapi.SecurityGroupContextResponse,\n    }).value;\n\n    return SecurityGroup.fromSecurityGroupId(scope, id, attributes.securityGroupId, {\n      allowAllOutbound: attributes.allowAllOutbound,\n      mutable: true,\n    });\n  }\n\n  /**\n   * An attribute that represents the security group name.\n   *\n   * @attribute\n   * @deprecated returns the security group ID, rather than the name.\n   */\n  public readonly securityGroupName: string;\n\n  /**\n   * The ID of the security group\n   *\n   * @attribute\n   */\n  public readonly securityGroupId: string;\n\n  /**\n   * The VPC ID this security group is part of.\n   *\n   * @attribute\n   */\n  public readonly securityGroupVpcId: string;\n\n  /**\n   * Whether the SecurityGroup has been configured to allow all outbound traffic\n   */\n  public readonly allowAllOutbound: boolean;\n\n  private readonly securityGroup: CfnSecurityGroup;\n  private readonly directIngressRules: CfnSecurityGroup.IngressProperty[] = [];\n  private readonly directEgressRules: CfnSecurityGroup.EgressProperty[] = [];\n\n  /**\n   * Whether to disable optimization for inline security group rules.\n   */\n  private readonly disableInlineRules: boolean;\n\n  constructor(scope: Construct, id: string, props: SecurityGroupProps) {\n    super(scope, id, {\n      physicalName: props.securityGroupName,\n    });\n\n    const groupDescription = props.description || this.node.path;\n\n    this.allowAllOutbound = props.allowAllOutbound !== false;\n\n    this.disableInlineRules = props.disableInlineRules !== undefined ?\n      !!props.disableInlineRules :\n      !!this.node.tryGetContext(SECURITY_GROUP_DISABLE_INLINE_RULES_CONTEXT_KEY);\n\n    this.securityGroup = new CfnSecurityGroup(this, 'Resource', {\n      groupName: this.physicalName,\n      groupDescription,\n      securityGroupIngress: Lazy.any({ produce: () => this.directIngressRules }, { omitEmptyArray: true } ),\n      securityGroupEgress: Lazy.any({ produce: () => this.directEgressRules }, { omitEmptyArray: true } ),\n      vpcId: props.vpc.vpcId,\n    });\n\n    this.securityGroupId = this.securityGroup.attrGroupId;\n    this.securityGroupVpcId = this.securityGroup.attrVpcId;\n    this.securityGroupName = this.securityGroup.ref;\n\n    this.addDefaultEgressRule();\n  }\n\n  public addIngressRule(peer: IPeer, connection: Port, description?: string, remoteRule?: boolean) {\n    if (!peer.canInlineRule || !connection.canInlineRule || this.disableInlineRules) {\n      super.addIngressRule(peer, connection, description, remoteRule);\n      return;\n    }\n\n    if (description === undefined) {\n      description = `from ${peer.uniqueId}:${connection}`;\n    }\n\n    this.addDirectIngressRule({\n      ...peer.toIngressRuleConfig(),\n      ...connection.toRuleJson(),\n      description,\n    });\n  }\n\n  public addEgressRule(peer: IPeer, connection: Port, description?: string, remoteRule?: boolean) {\n    if (this.allowAllOutbound) {\n      // In the case of \"allowAllOutbound\", we don't add any more rules. There\n      // is only one rule which allows all traffic and that subsumes any other\n      // rule.\n      if (!remoteRule) { // Warn only if addEgressRule() was explicitely called\n        Annotations.of(this).addWarning('Ignoring Egress rule since \\'allowAllOutbound\\' is set to true; To add customize rules, set allowAllOutbound=false on the SecurityGroup');\n      }\n      return;\n    } else {\n      // Otherwise, if the bogus rule exists we can now remove it because the\n      // presence of any other rule will get rid of EC2's implicit \"all\n      // outbound\" rule anyway.\n      this.removeNoTrafficRule();\n    }\n\n    if (!peer.canInlineRule || !connection.canInlineRule || this.disableInlineRules) {\n      super.addEgressRule(peer, connection, description, remoteRule);\n      return;\n    }\n\n    if (description === undefined) {\n      description = `from ${peer.uniqueId}:${connection}`;\n    }\n\n    const rule = {\n      ...peer.toEgressRuleConfig(),\n      ...connection.toRuleJson(),\n      description,\n    };\n\n    if (isAllTrafficRule(rule)) {\n      // We cannot allow this; if someone adds the rule in this way, it will be\n      // removed again if they add other rules. We also can't automatically switch\n      // to \"allOutbound=true\" mode, because we might have already emitted\n      // EgressRule objects (which count as rules added later) and there's no way\n      // to recall those. Better to prevent this for now.\n      throw new Error('Cannot add an \"all traffic\" egress rule in this way; set allowAllOutbound=true on the SecurityGroup instead.');\n    }\n\n    this.addDirectEgressRule(rule);\n  }\n\n  /**\n   * Add a direct ingress rule\n   */\n  private addDirectIngressRule(rule: CfnSecurityGroup.IngressProperty) {\n    if (!this.hasIngressRule(rule)) {\n      this.directIngressRules.push(rule);\n    }\n  }\n\n  /**\n   * Return whether the given ingress rule exists on the group\n   */\n  private hasIngressRule(rule: CfnSecurityGroup.IngressProperty): boolean {\n    return this.directIngressRules.findIndex(r => ingressRulesEqual(r, rule)) > -1;\n  }\n\n  /**\n   * Add a direct egress rule\n   */\n  private addDirectEgressRule(rule: CfnSecurityGroup.EgressProperty) {\n    if (!this.hasEgressRule(rule)) {\n      this.directEgressRules.push(rule);\n    }\n  }\n\n  /**\n   * Return whether the given egress rule exists on the group\n   */\n  private hasEgressRule(rule: CfnSecurityGroup.EgressProperty): boolean {\n    return this.directEgressRules.findIndex(r => egressRulesEqual(r, rule)) > -1;\n  }\n\n  /**\n   * Add the default egress rule to the securityGroup\n   *\n   * This depends on allowAllOutbound:\n   *\n   * - If allowAllOutbound is true, we *TECHNICALLY* don't need to do anything, because\n   *   EC2 is going to create this default rule anyway. But, for maximum readability\n   *   of the template, we will add one anyway.\n   * - If allowAllOutbound is false, we add a bogus rule that matches no traffic in\n   *   order to get rid of the default \"all outbound\" rule that EC2 creates by default.\n   *   If other rules happen to get added later, we remove the bogus rule again so\n   *   that it doesn't clutter up the template too much (even though that's not\n   *   strictly necessary).\n   */\n  private addDefaultEgressRule() {\n    if (this.disableInlineRules) {\n      const peer = this.allowAllOutbound ? ALL_TRAFFIC_PEER : NO_TRAFFIC_PEER;\n      const port = this.allowAllOutbound ? ALL_TRAFFIC_PORT : NO_TRAFFIC_PORT;\n      const description = this.allowAllOutbound ? ALLOW_ALL_RULE.description : MATCH_NO_TRAFFIC.description;\n      super.addEgressRule(peer, port, description, false);\n    } else {\n      const rule = this.allowAllOutbound? ALLOW_ALL_RULE : MATCH_NO_TRAFFIC;\n      this.directEgressRules.push(rule);\n    }\n  }\n\n  /**\n   * Remove the bogus rule if it exists\n   */\n  private removeNoTrafficRule() {\n    if (this.disableInlineRules) {\n      const [scope, id] = this.determineRuleScope(\n        NO_TRAFFIC_PEER,\n        NO_TRAFFIC_PORT,\n        'to',\n        false,\n      );\n      scope.node.tryRemoveChild(id);\n    } else {\n      const i = this.directEgressRules.findIndex(r => egressRulesEqual(r, MATCH_NO_TRAFFIC));\n      if (i > -1) {\n        this.directEgressRules.splice(i, 1);\n      }\n    }\n  }\n}\n\n/**\n * Egress rule that purposely matches no traffic\n *\n * This is used in order to disable the \"all traffic\" default of Security Groups.\n *\n * No machine can ever actually have the 255.255.255.255 IP address, but\n * in order to lock it down even more we'll restrict to a nonexistent\n * ICMP traffic type.\n */\nconst MATCH_NO_TRAFFIC = {\n  cidrIp: '255.255.255.255/32',\n  description: 'Disallow all traffic',\n  ipProtocol: 'icmp',\n  fromPort: 252,\n  toPort: 86,\n};\n\nconst NO_TRAFFIC_PEER = Peer.ipv4(MATCH_NO_TRAFFIC.cidrIp);\nconst NO_TRAFFIC_PORT = Port.icmpTypeAndCode(MATCH_NO_TRAFFIC.fromPort, MATCH_NO_TRAFFIC.toPort);\n\n/**\n * Egress rule that matches all traffic\n */\nconst ALLOW_ALL_RULE = {\n  cidrIp: '0.0.0.0/0',\n  description: 'Allow all outbound traffic by default',\n  ipProtocol: '-1',\n};\n\nconst ALL_TRAFFIC_PEER = Peer.anyIpv4();\nconst ALL_TRAFFIC_PORT = Port.allTraffic();\n\nexport interface ConnectionRule {\n  /**\n   * The IP protocol name (tcp, udp, icmp) or number (see Protocol Numbers).\n   * Use -1 to specify all protocols. If you specify -1, or a protocol number\n   * other than tcp, udp, icmp, or 58 (ICMPv6), traffic on all ports is\n   * allowed, regardless of any ports you specify. For tcp, udp, and icmp, you\n   * must specify a port range. For protocol 58 (ICMPv6), you can optionally\n   * specify a port range; if you don't, traffic for all types and codes is\n   * allowed.\n   *\n   * @default tcp\n   */\n  readonly protocol?: string;\n\n  /**\n   * Start of port range for the TCP and UDP protocols, or an ICMP type number.\n   *\n   * If you specify icmp for the IpProtocol property, you can specify\n   * -1 as a wildcard (i.e., any ICMP type number).\n   */\n  readonly fromPort: number;\n\n  /**\n   * End of port range for the TCP and UDP protocols, or an ICMP code.\n   *\n   * If you specify icmp for the IpProtocol property, you can specify -1 as a\n   * wildcard (i.e., any ICMP code).\n   *\n   * @default If toPort is not specified, it will be the same as fromPort.\n   */\n  readonly toPort?: number;\n\n  /**\n   * Description of this connection. It is applied to both the ingress rule\n   * and the egress rule.\n   *\n   * @default No description\n   */\n  readonly description?: string;\n}\n\n/**\n * Compare two ingress rules for equality the same way CloudFormation would (discarding description)\n */\nfunction ingressRulesEqual(a: CfnSecurityGroup.IngressProperty, b: CfnSecurityGroup.IngressProperty) {\n  return a.cidrIp === b.cidrIp\n    && a.cidrIpv6 === b.cidrIpv6\n    && a.fromPort === b.fromPort\n    && a.toPort === b.toPort\n    && a.ipProtocol === b.ipProtocol\n    && a.sourceSecurityGroupId === b.sourceSecurityGroupId\n    && a.sourceSecurityGroupName === b.sourceSecurityGroupName\n    && a.sourceSecurityGroupOwnerId === b.sourceSecurityGroupOwnerId;\n}\n\n/**\n * Compare two egress rules for equality the same way CloudFormation would (discarding description)\n */\nfunction egressRulesEqual(a: CfnSecurityGroup.EgressProperty, b: CfnSecurityGroup.EgressProperty) {\n  return a.cidrIp === b.cidrIp\n    && a.cidrIpv6 === b.cidrIpv6\n    && a.fromPort === b.fromPort\n    && a.toPort === b.toPort\n    && a.ipProtocol === b.ipProtocol\n    && a.destinationPrefixListId === b.destinationPrefixListId\n    && a.destinationSecurityGroupId === b.destinationSecurityGroupId;\n}\n\n/**\n * Whether this rule refers to all traffic\n */\nfunction isAllTrafficRule(rule: any) {\n  return rule.cidrIp === '0.0.0.0/0' && rule.ipProtocol === '-1';\n}\n\n/**\n * Properties for looking up an existing SecurityGroup.\n *\n * Either `securityGroupName` or `securityGroupId` has to be specified.\n */\ninterface SecurityGroupLookupOptions {\n  /**\n   * The name of the security group\n   *\n   * If given, will import the SecurityGroup with this name.\n   *\n   * @default Don't filter on securityGroupName\n   */\n  readonly securityGroupName?: string;\n\n  /**\n   * The ID of the security group\n   *\n   * If given, will import the SecurityGroup with this ID.\n   *\n   * @default Don't filter on securityGroupId\n   */\n  readonly securityGroupId?: string;\n\n  /**\n   * The VPC of the security group\n   *\n   * If given, will filter the SecurityGroup based on the VPC.\n   *\n   * @default Don't filter on VPC\n   */\n  readonly vpc?: IVpc,\n}\n"],
  "mappings": "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",
  "names": []
}
