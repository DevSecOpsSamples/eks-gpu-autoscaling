{
  "version": 3,
  "sources": ["connections.ts"],
  "sourcesContent": ["import { IPeer, Peer } from './peer';\nimport { Port } from './port';\nimport { ISecurityGroup } from './security-group';\n\n/**\n * The goal of this module is to make possible to write statements like this:\n *\n *  ```ts\n *  database.connections.allowFrom(fleet);\n *  fleet.connections.allowTo(database);\n *  rdgw.connections.allowFromCidrIp('0.3.1.5/86');\n *  rgdw.connections.allowTrafficTo(fleet, new AllPorts());\n *  ```\n *\n * The insight here is that some connecting peers have information on what ports should\n * be involved in the connection, and some don't.\n */\n\n/**\n * An object that has a Connections object\n */\nexport interface IConnectable {\n  /**\n   * The network connections associated with this resource.\n   */\n  readonly connections: Connections;\n}\n\n/**\n * Properties to intialize a new Connections object\n */\nexport interface ConnectionsProps {\n  /**\n   * Class that represents the rule by which others can connect to this connectable\n   *\n   * This object is required, but will be derived from securityGroup if that is passed.\n   *\n   * @default Derived from securityGroup if set.\n   */\n  readonly peer?: IPeer;\n\n  /**\n   * What securityGroup(s) this object is managing connections for\n   *\n   * @default No security groups\n   */\n  readonly securityGroups?: ISecurityGroup[];\n\n  /**\n   * Default port range for initiating connections to and from this object\n   *\n   * @default - No default port\n   */\n  readonly defaultPort?: Port;\n}\n\n/**\n * Manage the allowed network connections for constructs with Security Groups.\n *\n * Security Groups can be thought of as a firewall for network-connected\n * devices. This class makes it easy to allow network connections to and\n * from security groups, and between security groups individually. When\n * establishing connectivity between security groups, it will automatically\n * add rules in both security groups\n *\n * This object can manage one or more security groups.\n */\nexport class Connections implements IConnectable {\n  public readonly connections: Connections;\n\n  /**\n   * The default port configured for this connection peer, if available\n   */\n  public readonly defaultPort?: Port;\n\n  /**\n   * Underlying securityGroup for this Connections object, if present\n   *\n   * May be empty if this Connections object is not managing a SecurityGroup,\n   * but simply representing a Connectable peer.\n   */\n  private readonly _securityGroups = new ReactiveList<ISecurityGroup>();\n\n  /**\n   * The rule that defines how to represent this peer in a security group\n   */\n  private readonly _securityGroupRules = new ReactiveList<IPeer>();\n\n  /**\n   * When doing bidirectional grants between Connections, make sure we don't recursive infinitely\n   */\n  private skip: boolean = false;\n\n  /**\n   * When doing bidirectional grants between Security Groups in different stacks, put the rule on the other SG\n   */\n  private remoteRule: boolean = false;\n\n  constructor(props: ConnectionsProps = {}) {\n    this.connections = this;\n    this._securityGroups.push(...(props.securityGroups || []));\n\n    this._securityGroupRules.push(...this._securityGroups.asArray());\n    if (props.peer) {\n      this._securityGroupRules.push(props.peer);\n    }\n\n    this.defaultPort = props.defaultPort;\n  }\n\n  public get securityGroups(): ISecurityGroup[] {\n    return this._securityGroups.asArray();\n  }\n\n  /**\n   * Add a security group to the list of security groups managed by this object\n   */\n  public addSecurityGroup(...securityGroups: ISecurityGroup[]) {\n    for (const securityGroup of securityGroups) {\n      this._securityGroups.push(securityGroup);\n      this._securityGroupRules.push(securityGroup);\n    }\n  }\n\n  /**\n   * Allow connections to the peer on the given port\n   */\n  public allowTo(other: IConnectable, portRange: Port, description?: string) {\n    if (this.skip) { return; }\n\n    const remoteRule = this.remoteRule; // Capture current value into local for callback to close over\n    this._securityGroups.forEachAndForever(securityGroup => {\n      other.connections._securityGroupRules.forEachAndForever(rule => {\n        securityGroup.addEgressRule(rule, portRange, description, remoteRule);\n      });\n    });\n\n    this.skip = true;\n    other.connections.remoteRule = true;\n    try {\n      other.connections.allowFrom(this, portRange, description);\n    } finally {\n      this.skip = false;\n      other.connections.remoteRule = false;\n    }\n  }\n\n  /**\n   * Allow connections from the peer on the given port\n   */\n  public allowFrom(other: IConnectable, portRange: Port, description?: string) {\n    if (this.skip) { return; }\n\n    const remoteRule = this.remoteRule; // Capture current value into local for callback to close over\n    this._securityGroups.forEachAndForever(securityGroup => {\n      other.connections._securityGroupRules.forEachAndForever(rule => {\n        securityGroup.addIngressRule(rule, portRange, description, remoteRule);\n      });\n    });\n\n    this.skip = true;\n    other.connections.remoteRule = true;\n    try {\n      other.connections.allowTo(this, portRange, description);\n    } finally {\n      this.skip = false;\n      other.connections.remoteRule = false;\n    }\n  }\n\n  /**\n   * Allow hosts inside the security group to connect to each other on the given port\n   */\n  public allowInternally(portRange: Port, description?: string) {\n    this._securityGroups.forEachAndForever(securityGroup => {\n      this._securityGroupRules.forEachAndForever(rule => {\n        securityGroup.addIngressRule(rule, portRange, description);\n        securityGroup.addEgressRule(rule, portRange, description);\n      });\n    });\n  }\n\n  /**\n   * Allow to all IPv4 ranges\n   */\n  public allowToAnyIpv4(portRange: Port, description?: string) {\n    this.allowTo(Peer.anyIpv4(), portRange, description);\n  }\n\n  /**\n   * Allow from any IPv4 ranges\n   */\n  public allowFromAnyIpv4(portRange: Port, description?: string) {\n    this.allowFrom(Peer.anyIpv4(), portRange, description);\n  }\n\n  /**\n   * Allow connections from the peer on our default port\n   *\n   * Even if the peer has a default port, we will always use our default port.\n   */\n  public allowDefaultPortFrom(other: IConnectable, description?: string) {\n    if (!this.defaultPort) {\n      throw new Error('Cannot call allowDefaultPortFrom(): this resource has no default port');\n    }\n    this.allowFrom(other, this.defaultPort, description);\n  }\n\n  /**\n   * Allow hosts inside the security group to connect to each other\n   */\n  public allowDefaultPortInternally(description?: string) {\n    if (!this.defaultPort) {\n      throw new Error('Cannot call allowDefaultPortInternally(): this resource has no default port');\n    }\n    this.allowInternally(this.defaultPort, description);\n  }\n\n  /**\n   * Allow default connections from all IPv4 ranges\n   */\n  public allowDefaultPortFromAnyIpv4(description?: string) {\n    if (!this.defaultPort) {\n      throw new Error('Cannot call allowDefaultPortFromAnyIpv4(): this resource has no default port');\n    }\n    this.allowFromAnyIpv4(this.defaultPort, description);\n  }\n\n  /**\n   * Allow connections to the security group on their default port\n   */\n  public allowToDefaultPort(other: IConnectable, description?: string) {\n    if (other.connections.defaultPort === undefined) {\n      throw new Error('Cannot call allowToDefaultPort(): other resource has no default port');\n    }\n\n    this.allowTo(other, other.connections.defaultPort, description);\n  }\n\n  /**\n   * Allow connections from the peer on our default port\n   *\n   * Even if the peer has a default port, we will always use our default port.\n   */\n  public allowDefaultPortTo(other: IConnectable, description?: string) {\n    if (!this.defaultPort) {\n      throw new Error('Cannot call allowDefaultPortTo(): this resource has no default port');\n    }\n    this.allowTo(other, this.defaultPort, description);\n  }\n}\n\ntype Action<T> = (x: T) => void;\n\nclass ReactiveList<T> {\n  private readonly elements = new Array<T>();\n  private readonly listeners = new Array<Action<T>>();\n\n  public push(...xs: T[]) {\n    this.elements.push(...xs);\n    for (const listener of this.listeners) {\n      for (const x of xs) {\n        listener(x);\n      }\n    }\n  }\n\n  public forEachAndForever(listener: Action<T>) {\n    for (const element of this.elements) {\n      listener(element);\n    }\n    this.listeners.push(listener);\n  }\n\n  public asArray(): T[] {\n    return this.elements.slice();\n  }\n\n  public get length(): number {\n    return this.elements.length;\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
