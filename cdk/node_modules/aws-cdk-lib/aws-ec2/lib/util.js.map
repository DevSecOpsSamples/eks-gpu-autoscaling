{
  "version": 3,
  "sources": ["util.ts"],
  "sourcesContent": ["import { Construct } from 'constructs';\nimport { ISubnet, Subnet, SubnetType } from './vpc';\n\n/**\n * Turn an arbitrary string into one that can be used as a CloudFormation identifier by stripping special characters\n *\n * (At the moment, no efforts are taken to prevent collisions, but we can add that later when it becomes necessary).\n */\nexport function slugify(x: string): string {\n  return x.replace(/[^a-zA-Z0-9]/g, '');\n}\n\n/**\n * The default names for every subnet type\n */\nexport function defaultSubnetName(type: SubnetType) {\n  switch (type) {\n    case SubnetType.PUBLIC: return 'Public';\n    case SubnetType.PRIVATE_WITH_NAT: return 'Private';\n    case SubnetType.PRIVATE_ISOLATED: return 'Isolated';\n  }\n}\n\n/**\n * Return a subnet name from its construct ID\n *\n * All subnet names look like NAME <> \"Subnet\" <> INDEX\n */\nexport function subnetGroupNameFromConstructId(subnet: ISubnet) {\n  return subnet.node.id.replace(/Subnet\\d+$/, '');\n}\n\n/**\n * Make the subnet construct ID from a name and number\n */\nexport function subnetId(name: string, i: number) {\n  return `${name}Subnet${i + 1}`;\n}\n\nexport class ImportSubnetGroup {\n  private readonly subnetIds: string[];\n  private readonly names: string[];\n  private readonly routeTableIds: string[];\n  private readonly groups: number;\n\n  constructor(\n    subnetIds: string[] | undefined,\n    names: string[] | undefined,\n    routeTableIds: string[] | undefined,\n    type: SubnetType,\n    private readonly availabilityZones: string[],\n    idField: string,\n    nameField: string,\n    routeTableIdField: string) {\n\n    this.subnetIds = subnetIds || [];\n    this.routeTableIds = routeTableIds || [];\n    this.groups = this.subnetIds.length / this.availabilityZones.length;\n\n    if (Math.floor(this.groups) !== this.groups) {\n      // eslint-disable-next-line max-len\n      throw new Error(`Number of ${idField} (${this.subnetIds.length}) must be a multiple of availability zones (${this.availabilityZones.length}).`);\n    }\n    if (this.routeTableIds.length !== this.subnetIds.length && routeTableIds != null) {\n      // We don't err if no routeTableIds were provided to maintain backwards-compatibility. See https://github.com/aws/aws-cdk/pull/3171\n      /* eslint-disable max-len */\n      throw new Error(`Number of ${routeTableIdField} (${this.routeTableIds.length}) must be equal to the amount of ${idField} (${this.subnetIds.length}).`);\n    }\n\n    this.names = this.normalizeNames(names, defaultSubnetName(type), nameField);\n  }\n\n  public import(scope: Construct): ISubnet[] {\n    return range(this.subnetIds.length).map(i => {\n      const k = Math.floor(i / this.availabilityZones.length);\n      return Subnet.fromSubnetAttributes(scope, subnetId(this.names[k], i), {\n        availabilityZone: this.pickAZ(i),\n        subnetId: this.subnetIds[i],\n        routeTableId: this.routeTableIds[i],\n      });\n    });\n  }\n\n  /**\n   * Return a list with a name for every subnet\n   */\n  private normalizeNames(names: string[] | undefined, defaultName: string, fieldName: string) {\n    // If not given, return default\n    if (names === undefined || names.length === 0) {\n      return [defaultName];\n    }\n\n    // If given, must match given subnets\n    if (names.length !== this.groups) {\n      throw new Error(`${fieldName} must have an entry for every corresponding subnet group, got: ${JSON.stringify(names)}`);\n    }\n\n    return names;\n  }\n\n  /**\n   * Return the i'th AZ\n   */\n  private pickAZ(i: number) {\n    return this.availabilityZones[i % this.availabilityZones.length];\n  }\n}\n\n/**\n * Generate the list of numbers of [0..n)\n */\nexport function range(n: number): number[] {\n  const ret: number[] = [];\n  for (let i = 0; i < n; i++) {\n    ret.push(i);\n  }\n  return ret;\n}\n\n/**\n * Return the union of table IDs from all selected subnets\n */\nexport function allRouteTableIds(subnets: ISubnet[]): string[] {\n  const ret = new Set<string>();\n  for (const subnet of subnets) {\n    if (subnet.routeTable && subnet.routeTable.routeTableId) {\n      ret.add(subnet.routeTable.routeTableId);\n    }\n  }\n  return Array.from(ret);\n}\n\nexport function flatten<A>(xs: A[][]): A[] {\n  return Array.prototype.concat.apply([], xs);\n}\n"],
  "mappings": "8PACA,KAAA,OAAA,QAAA,OAAA,EAOA,iBAAwB,EAAS,CAC/B,MAAO,GAAE,QAAQ,gBAAiB,EAAE,CACtC,CAFA,QAAA,QAAA,QAOA,2BAAkC,KAAgB,CAChD,OAAQ,UACD,OAAA,WAAW,OAAQ,MAAO,aAC1B,OAAA,WAAW,iBAAkB,MAAO,cACpC,OAAA,WAAW,iBAAkB,MAAO,WAE7C,CANA,QAAA,kBAAA,kBAaA,wCAA+C,OAAe,CAC5D,MAAO,QAAO,KAAK,GAAG,QAAQ,aAAc,EAAE,CAChD,CAFA,QAAA,+BAAA,+BAOA,kBAAyB,KAAc,EAAS,CAC9C,MAAO,GAAG,aAAa,EAAI,GAC7B,CAFA,QAAA,SAAA,SAIA,MAAa,iBAAiB,CAM5B,YACE,UACA,MACA,cACA,KACiB,kBACjB,QACA,UACA,kBAAyB,CAMzB,GATiB,KAAA,kBAAA,kBAKjB,KAAK,UAAY,WAAa,CAAA,EAC9B,KAAK,cAAgB,eAAiB,CAAA,EACtC,KAAK,OAAS,KAAK,UAAU,OAAS,KAAK,kBAAkB,OAEzD,KAAK,MAAM,KAAK,MAAM,IAAM,KAAK,OAEnC,KAAM,IAAI,OAAM,aAAa,YAAY,KAAK,UAAU,qDAAqD,KAAK,kBAAkB,UAAU,EAEhJ,GAAI,KAAK,cAAc,SAAW,KAAK,UAAU,QAAU,eAAiB,KAG1E,KAAM,IAAI,OAAM,aAAa,sBAAsB,KAAK,cAAc,0CAA0C,YAAY,KAAK,UAAU,UAAU,EAGvJ,KAAK,MAAQ,KAAK,eAAe,MAAO,kBAAkB,IAAI,EAAG,SAAS,EAGrE,OAAO,MAAgB,CAC5B,MAAO,OAAM,KAAK,UAAU,MAAM,EAAE,IAAI,GAAI,CAC1C,KAAM,GAAI,KAAK,MAAM,EAAI,KAAK,kBAAkB,MAAM,EACtD,MAAO,OAAA,OAAO,qBAAqB,MAAO,SAAS,KAAK,MAAM,GAAI,CAAC,EAAG,CACpE,iBAAkB,KAAK,OAAO,CAAC,EAC/B,SAAU,KAAK,UAAU,GACzB,aAAc,KAAK,cAAc,GAClC,CACH,CAAC,EAMK,eAAe,MAA6B,YAAqB,UAAiB,CAExF,GAAI,QAAU,QAAa,MAAM,SAAW,EAC1C,MAAO,CAAC,WAAW,EAIrB,GAAI,MAAM,SAAW,KAAK,OACxB,KAAM,IAAI,OAAM,GAAG,2EAA2E,KAAK,UAAU,KAAK,GAAG,EAGvH,MAAO,OAMD,OAAO,EAAS,CACtB,MAAO,MAAK,kBAAkB,EAAI,KAAK,kBAAkB,SAjE7D,QAAA,kBAAA,kBAwEA,eAAsB,EAAS,CAC7B,KAAM,KAAgB,CAAA,EACtB,OAAS,GAAI,EAAG,EAAI,EAAG,IACrB,IAAI,KAAK,CAAC,EAEZ,MAAO,IACT,CANA,QAAA,MAAA,MAWA,0BAAiC,QAAkB,CACjD,KAAM,KAAM,GAAI,KAChB,SAAW,UAAU,SACnB,AAAI,OAAO,YAAc,OAAO,WAAW,cACzC,IAAI,IAAI,OAAO,WAAW,YAAY,EAG1C,MAAO,OAAM,KAAK,GAAG,CACvB,CARA,QAAA,iBAAA,iBAUA,iBAA2B,GAAS,CAClC,MAAO,OAAM,UAAU,OAAO,MAAM,CAAA,EAAI,EAAE,CAC5C,CAFA,QAAA,QAAA",
  "names": []
}
