"use strict";var _a,_b;Object.defineProperty(exports,"__esModule",{value:!0}),exports.Volume=exports.EbsDeviceVolumeType=exports.BlockDeviceVolume=void 0;const jsiiDeprecationWarnings=require("../../.warnings.jsii.js"),JSII_RTTI_SYMBOL_1=Symbol.for("jsii.rtti"),crypto=require("crypto"),aws_iam_1=require("../../aws-iam"),aws_kms_1=require("../../aws-kms"),core_1=require("../../core"),ec2_generated_1=require("./ec2.generated");class BlockDeviceVolume{constructor(ebsDevice,virtualName){this.ebsDevice=ebsDevice,this.virtualName=virtualName,jsiiDeprecationWarnings.aws_cdk_lib_aws_ec2_EbsDeviceProps(ebsDevice)}static ebs(volumeSize,options={}){return jsiiDeprecationWarnings.aws_cdk_lib_aws_ec2_EbsDeviceOptions(options),new this({...options,volumeSize})}static ebsFromSnapshot(snapshotId,options={}){return jsiiDeprecationWarnings.aws_cdk_lib_aws_ec2_EbsDeviceSnapshotOptions(options),new this({...options,snapshotId})}static ephemeral(volumeIndex){if(volumeIndex<0)throw new Error(`volumeIndex must be a number starting from 0, got "${volumeIndex}"`);return new this(void 0,`ephemeral${volumeIndex}`)}}exports.BlockDeviceVolume=BlockDeviceVolume,_a=JSII_RTTI_SYMBOL_1,BlockDeviceVolume[_a]={fqn:"aws-cdk-lib.aws_ec2.BlockDeviceVolume",version:"2.20.0"};var EbsDeviceVolumeType;(function(EbsDeviceVolumeType2){EbsDeviceVolumeType2.STANDARD="standard",EbsDeviceVolumeType2.IO1="io1",EbsDeviceVolumeType2.IO2="io2",EbsDeviceVolumeType2.GP2="gp2",EbsDeviceVolumeType2.GP3="gp3",EbsDeviceVolumeType2.ST1="st1",EbsDeviceVolumeType2.SC1="sc1",EbsDeviceVolumeType2.GENERAL_PURPOSE_SSD="gp2",EbsDeviceVolumeType2.GENERAL_PURPOSE_SSD_GP3="gp3",EbsDeviceVolumeType2.PROVISIONED_IOPS_SSD="io1",EbsDeviceVolumeType2.PROVISIONED_IOPS_SSD_IO2="io2",EbsDeviceVolumeType2.THROUGHPUT_OPTIMIZED_HDD="st1",EbsDeviceVolumeType2.COLD_HDD="sc1",EbsDeviceVolumeType2.MAGNETIC="standard"})(EbsDeviceVolumeType=exports.EbsDeviceVolumeType||(exports.EbsDeviceVolumeType={}));class VolumeBase extends core_1.Resource{grantAttachVolume(grantee,instances){const result=aws_iam_1.Grant.addToPrincipal({grantee,actions:["ec2:AttachVolume"],resourceArns:this.collectGrantResourceArns(instances)});return this.encryptionKey&&this.encryptionKey.grant(grantee,"kms:CreateGrant").principalStatement.addConditions({Bool:{"kms:GrantIsForAWSResource":!0},StringEquals:{"kms:ViaService":`ec2.${core_1.Stack.of(this).region}.amazonaws.com`,"kms:GrantConstraintType":"EncryptionContextSubset"}}),result}grantAttachVolumeByResourceTag(grantee,constructs,tagKeySuffix){const tagValue=this.calculateResourceTagValue([this,...constructs]),tagKey=`VolumeGrantAttach-${tagKeySuffix!=null?tagKeySuffix:tagValue.slice(0,10).toUpperCase()}`,grantCondition={};grantCondition[`ec2:ResourceTag/${tagKey}`]=tagValue;const result=this.grantAttachVolume(grantee);return result.principalStatement.addCondition("ForAnyValue:StringEquals",grantCondition),core_1.Tags.of(this).add(tagKey,tagValue),constructs.forEach(construct=>core_1.Tags.of(construct).add(tagKey,tagValue)),result}grantDetachVolume(grantee,instances){return aws_iam_1.Grant.addToPrincipal({grantee,actions:["ec2:DetachVolume"],resourceArns:this.collectGrantResourceArns(instances)})}grantDetachVolumeByResourceTag(grantee,constructs,tagKeySuffix){const tagValue=this.calculateResourceTagValue([this,...constructs]),tagKey=`VolumeGrantDetach-${tagKeySuffix!=null?tagKeySuffix:tagValue.slice(0,10).toUpperCase()}`,grantCondition={};grantCondition[`ec2:ResourceTag/${tagKey}`]=tagValue;const result=this.grantDetachVolume(grantee);return result.principalStatement.addCondition("ForAnyValue:StringEquals",grantCondition),core_1.Tags.of(this).add(tagKey,tagValue),constructs.forEach(construct=>core_1.Tags.of(construct).add(tagKey,tagValue)),result}collectGrantResourceArns(instances){const stack=core_1.Stack.of(this),resourceArns=[`arn:${stack.partition}:ec2:${stack.region}:${stack.account}:volume/${this.volumeId}`],instanceArnPrefix=`arn:${stack.partition}:ec2:${stack.region}:${stack.account}:instance`;return instances?instances.forEach(instance=>resourceArns.push(`${instanceArnPrefix}/${instance==null?void 0:instance.instanceId}`)):resourceArns.push(`${instanceArnPrefix}/*`),resourceArns}calculateResourceTagValue(constructs){const md5=crypto.createHash("md5");return constructs.forEach(construct=>md5.update(core_1.Names.uniqueId(construct))),md5.digest("hex")}}class Volume extends VolumeBase{constructor(scope,id,props){var _c,_d,_e,_f,_g;super(scope,id,{physicalName:props.volumeName});jsiiDeprecationWarnings.aws_cdk_lib_aws_ec2_VolumeProps(props),this.validateProps(props);const resource=new ec2_generated_1.CfnVolume(this,"Resource",{availabilityZone:props.availabilityZone,autoEnableIo:props.autoEnableIo,encrypted:props.encrypted,kmsKeyId:(_c=props.encryptionKey)===null||_c===void 0?void 0:_c.keyArn,iops:props.iops,multiAttachEnabled:(_d=props.enableMultiAttach)!==null&&_d!==void 0?_d:!1,size:(_e=props.size)===null||_e===void 0?void 0:_e.toGibibytes({rounding:core_1.SizeRoundingBehavior.FAIL}),snapshotId:props.snapshotId,volumeType:(_f=props.volumeType)!==null&&_f!==void 0?_f:EbsDeviceVolumeType.GENERAL_PURPOSE_SSD});if(resource.applyRemovalPolicy(props.removalPolicy),props.volumeName&&core_1.Tags.of(resource).add("Name",props.volumeName),this.volumeId=resource.ref,this.availabilityZone=props.availabilityZone,this.encryptionKey=props.encryptionKey,this.encryptionKey){const principal=new aws_kms_1.ViaServicePrincipal(`ec2.${core_1.Stack.of(this).region}.amazonaws.com`,new aws_iam_1.AccountRootPrincipal).withConditions({StringEquals:{"kms:CallerAccount":core_1.Stack.of(this).account}}),grant=this.encryptionKey.grant(principal,"kms:DescribeKey","kms:GenerateDataKeyWithoutPlainText");props.snapshotId&&((_g=grant.principalStatement)===null||_g===void 0||_g.addActions("kms:ReEncrypt*"))}}static fromVolumeAttributes(scope,id,attrs){jsiiDeprecationWarnings.aws_cdk_lib_aws_ec2_VolumeAttributes(attrs);class Import extends VolumeBase{constructor(){super(...arguments);this.volumeId=attrs.volumeId,this.availabilityZone=attrs.availabilityZone,this.encryptionKey=attrs.encryptionKey}}if(!core_1.Token.isUnresolved(attrs.volumeId)&&!/^vol-[0-9a-fA-F]+$/.test(attrs.volumeId))throw new Error("`volumeId` does not match expected pattern. Expected `vol-<hexadecmial value>` (ex: `vol-05abe246af`) or a Token");return new Import(scope,id)}validateProps(props){var _c,_d,_e;if(jsiiDeprecationWarnings.aws_cdk_lib_aws_ec2_VolumeProps(props),!(props.size||props.snapshotId))throw new Error("Must provide at least one of `size` or `snapshotId`");if(props.snapshotId&&!core_1.Token.isUnresolved(props.snapshotId)&&!/^snap-[0-9a-fA-F]+$/.test(props.snapshotId))throw new Error("`snapshotId` does match expected pattern. Expected `snap-<hexadecmial value>` (ex: `snap-05abe246af`) or Token");if(props.encryptionKey&&!props.encrypted)throw new Error("`encrypted` must be true when providing an `encryptionKey`.");if(props.volumeType&&[EbsDeviceVolumeType.PROVISIONED_IOPS_SSD,EbsDeviceVolumeType.PROVISIONED_IOPS_SSD_IO2].includes(props.volumeType)&&!props.iops)throw new Error("`iops` must be specified if the `volumeType` is `PROVISIONED_IOPS_SSD` or `PROVISIONED_IOPS_SSD_IO2`.");if(props.iops){const volumeType=(_c=props.volumeType)!==null&&_c!==void 0?_c:EbsDeviceVolumeType.GENERAL_PURPOSE_SSD;if(![EbsDeviceVolumeType.PROVISIONED_IOPS_SSD,EbsDeviceVolumeType.PROVISIONED_IOPS_SSD_IO2,EbsDeviceVolumeType.GENERAL_PURPOSE_SSD_GP3].includes(volumeType))throw new Error("`iops` may only be specified if the `volumeType` is `PROVISIONED_IOPS_SSD`, `PROVISIONED_IOPS_SSD_IO2` or `GENERAL_PURPOSE_SSD_GP3`.");const iopsRanges={};iopsRanges[EbsDeviceVolumeType.GENERAL_PURPOSE_SSD_GP3]={Min:3e3,Max:16e3},iopsRanges[EbsDeviceVolumeType.PROVISIONED_IOPS_SSD]={Min:100,Max:64e3},iopsRanges[EbsDeviceVolumeType.PROVISIONED_IOPS_SSD_IO2]={Min:100,Max:64e3};const{Min,Max}=iopsRanges[volumeType];if(props.iops<Min||props.iops>Max)throw new Error(`\`${volumeType}\` volumes iops must be between ${Min} and ${Max}.`);const maximumRatios={};maximumRatios[EbsDeviceVolumeType.GENERAL_PURPOSE_SSD_GP3]=500,maximumRatios[EbsDeviceVolumeType.PROVISIONED_IOPS_SSD]=50,maximumRatios[EbsDeviceVolumeType.PROVISIONED_IOPS_SSD_IO2]=500;const maximumRatio=maximumRatios[volumeType];if(props.size&&props.iops>maximumRatio*props.size.toGibibytes({rounding:core_1.SizeRoundingBehavior.FAIL}))throw new Error(`\`${volumeType}\` volumes iops has a maximum ratio of ${maximumRatio} IOPS/GiB.`)}if(props.enableMultiAttach){const volumeType=(_d=props.volumeType)!==null&&_d!==void 0?_d:EbsDeviceVolumeType.GENERAL_PURPOSE_SSD;if(![EbsDeviceVolumeType.PROVISIONED_IOPS_SSD,EbsDeviceVolumeType.PROVISIONED_IOPS_SSD_IO2].includes(volumeType))throw new Error("multi-attach is supported exclusively on `PROVISIONED_IOPS_SSD` and `PROVISIONED_IOPS_SSD_IO2` volumes.")}if(props.size){const size=props.size.toGibibytes({rounding:core_1.SizeRoundingBehavior.FAIL}),sizeRanges={};sizeRanges[EbsDeviceVolumeType.GENERAL_PURPOSE_SSD]={Min:1,Max:16384},sizeRanges[EbsDeviceVolumeType.GENERAL_PURPOSE_SSD_GP3]={Min:1,Max:16384},sizeRanges[EbsDeviceVolumeType.PROVISIONED_IOPS_SSD]={Min:4,Max:16384},sizeRanges[EbsDeviceVolumeType.PROVISIONED_IOPS_SSD_IO2]={Min:4,Max:16384},sizeRanges[EbsDeviceVolumeType.THROUGHPUT_OPTIMIZED_HDD]={Min:125,Max:16384},sizeRanges[EbsDeviceVolumeType.COLD_HDD]={Min:125,Max:16384},sizeRanges[EbsDeviceVolumeType.MAGNETIC]={Min:1,Max:1024};const volumeType=(_e=props.volumeType)!==null&&_e!==void 0?_e:EbsDeviceVolumeType.GENERAL_PURPOSE_SSD,{Min,Max}=sizeRanges[volumeType];if(size<Min||size>Max)throw new Error(`\`${volumeType}\` volumes must be between ${Min} GiB and ${Max} GiB in size.`)}}}exports.Volume=Volume,_b=JSII_RTTI_SYMBOL_1,Volume[_b]={fqn:"aws-cdk-lib.aws_ec2.Volume",version:"2.20.0"};
//# sourceMappingURL=volume.js.map
