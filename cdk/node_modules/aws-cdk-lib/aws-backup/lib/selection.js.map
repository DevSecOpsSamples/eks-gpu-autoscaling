{
  "version": 3,
  "sources": ["selection.ts"],
  "sourcesContent": ["import * as iam from '../../aws-iam';\nimport { Lazy, Resource, Aspects } from '../../core';\nimport { Construct } from 'constructs';\nimport { CfnBackupSelection } from './backup.generated';\nimport { BackupableResourcesCollector } from './backupable-resources-collector';\nimport { IBackupPlan } from './plan';\nimport { BackupResource, TagOperation } from './resource';\n\n/**\n * Options for a BackupSelection\n */\nexport interface BackupSelectionOptions {\n  /**\n   * The resources to backup.\n   * Use the helper static methods defined on `BackupResource`.\n   */\n  readonly resources: BackupResource[];\n\n  /**\n   * The name for this selection\n   *\n   * @default - a CDK generated name\n   */\n  readonly backupSelectionName?: string;\n\n  /**\n   * The role that AWS Backup uses to authenticate when backuping or restoring\n   * the resources. The `AWSBackupServiceRolePolicyForBackup` managed policy\n   * will be attached to this role.\n   *\n   * @default - a new role will be created\n   */\n  readonly role?: iam.IRole;\n\n  /**\n   * Whether to automatically give restores permissions to the role that AWS\n   * Backup uses. If `true`, the `AWSBackupServiceRolePolicyForRestores` managed\n   * policy will be attached to the role.\n   *\n   * @default false\n   */\n  readonly allowRestores?: boolean;\n}\n\n/**\n * Properties for a BackupSelection\n */\nexport interface BackupSelectionProps extends BackupSelectionOptions {\n  /**\n   * The backup plan for this selection\n   */\n  readonly backupPlan: IBackupPlan;\n}\n\n/**\n * A backup selection\n */\nexport class BackupSelection extends Resource implements iam.IGrantable {\n  /**\n   * The identifier of the backup plan.\n   *\n   * @attribute\n   */\n  public readonly backupPlanId: string;\n\n  /**\n   * The identifier of the backup selection.\n   *\n   * @attribute\n   */\n  public readonly selectionId: string;\n\n  /**\n   * The principal to grant permissions to\n   */\n  public readonly grantPrincipal: iam.IPrincipal;\n\n  private listOfTags: CfnBackupSelection.ConditionResourceTypeProperty[] = [];\n  private resources: string[] = [];\n  private readonly backupableResourcesCollector = new BackupableResourcesCollector();\n\n  constructor(scope: Construct, id: string, props: BackupSelectionProps) {\n    super(scope, id);\n\n    const role = props.role || new iam.Role(this, 'Role', {\n      assumedBy: new iam.ServicePrincipal('backup.amazonaws.com'),\n    });\n    role.addManagedPolicy(iam.ManagedPolicy.fromAwsManagedPolicyName('service-role/AWSBackupServiceRolePolicyForBackup'));\n    if (props.allowRestores) {\n      role.addManagedPolicy(iam.ManagedPolicy.fromAwsManagedPolicyName('service-role/AWSBackupServiceRolePolicyForRestores'));\n    }\n    this.grantPrincipal = role;\n\n    const selection = new CfnBackupSelection(this, 'Resource', {\n      backupPlanId: props.backupPlan.backupPlanId,\n      backupSelection: {\n        iamRoleArn: role.roleArn,\n        selectionName: props.backupSelectionName || this.node.id,\n        listOfTags: Lazy.any({\n          produce: () => this.listOfTags,\n        }, { omitEmptyArray: true }),\n        resources: Lazy.list({\n          produce: () => [...this.resources, ...this.backupableResourcesCollector.resources],\n        }, { omitEmpty: true }),\n      },\n    });\n\n    this.backupPlanId = selection.attrBackupPlanId;\n    this.selectionId = selection.attrSelectionId;\n\n    for (const resource of props.resources) {\n      this.addResource(resource);\n    }\n  }\n\n  private addResource(resource: BackupResource) {\n    if (resource.tagCondition) {\n      this.listOfTags.push({\n        conditionKey: resource.tagCondition.key,\n        conditionType: resource.tagCondition.operation || TagOperation.STRING_EQUALS,\n        conditionValue: resource.tagCondition.value,\n      });\n    }\n\n    if (resource.resource) {\n      this.resources.push(resource.resource);\n    }\n\n    if (resource.construct) {\n      Aspects.of(resource.construct).add(this.backupableResourcesCollector);\n      // Cannot push `this.backupableResourcesCollector.resources` to\n      // `this.resources` here because it has not been evaluated yet.\n      // Will be concatenated to `this.resources` in a `Lazy.list`\n      // in the constructor instead.\n    }\n  }\n}\n"],
  "mappings": "sNAAA,IAAA,QAAA,eAAA,EACA,OAAA,QAAA,YAAA,EAEA,mBAAA,QAAA,oBAAA,EACA,iCAAA,QAAA,kCAAA,EAEA,WAAA,QAAA,YAAA,EAmDA,MAAa,uBAAwB,QAAA,QAAQ,CAwB3C,YAAY,MAAkB,GAAY,MAA2B,CACnE,MAAM,MAAO,EAAE,EALT,KAAA,WAAiE,CAAA,EACjE,KAAA,UAAsB,CAAA,EACb,KAAA,6BAA+B,GAAI,kCAAA,wGAKlD,KAAM,MAAO,MAAM,MAAQ,GAAI,KAAI,KAAK,KAAM,OAAQ,CACpD,UAAW,GAAI,KAAI,iBAAiB,sBAAsB,EAC3D,EACD,KAAK,iBAAiB,IAAI,cAAc,yBAAyB,kDAAkD,CAAC,EAChH,MAAM,eACR,KAAK,iBAAiB,IAAI,cAAc,yBAAyB,oDAAoD,CAAC,EAExH,KAAK,eAAiB,KAEtB,KAAM,WAAY,GAAI,oBAAA,mBAAmB,KAAM,WAAY,CACzD,aAAc,MAAM,WAAW,aAC/B,gBAAiB,CACf,WAAY,KAAK,QACjB,cAAe,MAAM,qBAAuB,KAAK,KAAK,GACtD,WAAY,OAAA,KAAK,IAAI,CACnB,QAAS,IAAM,KAAK,YACnB,CAAE,eAAgB,EAAI,CAAE,EAC3B,UAAW,OAAA,KAAK,KAAK,CACnB,QAAS,IAAM,CAAC,GAAG,KAAK,UAAW,GAAG,KAAK,6BAA6B,SAAS,GAChF,CAAE,UAAW,EAAI,CAAE,GAEzB,EAED,KAAK,aAAe,UAAU,iBAC9B,KAAK,YAAc,UAAU,gBAE7B,SAAW,YAAY,OAAM,UAC3B,KAAK,YAAY,QAAQ,EAIrB,YAAY,SAAwB,CAC1C,AAAI,SAAS,cACX,KAAK,WAAW,KAAK,CACnB,aAAc,SAAS,aAAa,IACpC,cAAe,SAAS,aAAa,WAAa,WAAA,aAAa,cAC/D,eAAgB,SAAS,aAAa,MACvC,EAGC,SAAS,UACX,KAAK,UAAU,KAAK,SAAS,QAAQ,EAGnC,SAAS,WACX,OAAA,QAAQ,GAAG,SAAS,SAAS,EAAE,IAAI,KAAK,4BAA4B,GAxE1E,QAAA,gBAAA",
  "names": []
}
