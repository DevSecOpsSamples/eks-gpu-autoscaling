{
  "version": 3,
  "sources": ["cluster.ts"],
  "sourcesContent": ["import * as fs from 'fs';\nimport * as path from 'path';\nimport * as autoscaling from '../../aws-autoscaling';\nimport * as ec2 from '../../aws-ec2';\nimport * as iam from '../../aws-iam';\nimport * as kms from '../../aws-kms';\nimport * as lambda from '../../aws-lambda';\nimport * as ssm from '../../aws-ssm';\nimport { Annotations, CfnOutput, CfnResource, IResource, Resource, Stack, Tags, Token, Duration, Size } from '../../core';\nimport { Construct, Node } from 'constructs';\nimport * as YAML from 'yaml';\nimport { AlbController, AlbControllerOptions } from './alb-controller';\nimport { AwsAuth } from './aws-auth';\nimport { ClusterResource, clusterArnComponents } from './cluster-resource';\nimport { FargateProfile, FargateProfileOptions } from './fargate-profile';\nimport { HelmChart, HelmChartOptions } from './helm-chart';\nimport { INSTANCE_TYPES } from './instance-types';\nimport { KubernetesManifest, KubernetesManifestOptions } from './k8s-manifest';\nimport { KubernetesObjectValue } from './k8s-object-value';\nimport { KubernetesPatch } from './k8s-patch';\nimport { IKubectlProvider, KubectlProvider } from './kubectl-provider';\nimport { Nodegroup, NodegroupOptions } from './managed-nodegroup';\nimport { OpenIdConnectProvider } from './oidc-provider';\nimport { BottleRocketImage } from './private/bottlerocket';\nimport { ServiceAccount, ServiceAccountOptions } from './service-account';\nimport { LifecycleLabel, renderAmazonLinuxUserData, renderBottlerocketUserData } from './user-data';\n\n// defaults are based on https://eksctl.io\nconst DEFAULT_CAPACITY_COUNT = 2;\nconst DEFAULT_CAPACITY_TYPE = ec2.InstanceType.of(ec2.InstanceClass.M5, ec2.InstanceSize.LARGE);\n\n/**\n * An EKS cluster\n */\nexport interface ICluster extends IResource, ec2.IConnectable {\n  /**\n   * The VPC in which this Cluster was created\n   */\n  readonly vpc: ec2.IVpc;\n\n  /**\n   * The physical name of the Cluster\n   * @attribute\n   */\n  readonly clusterName: string;\n\n  /**\n   * The unique ARN assigned to the service by AWS\n   * in the form of arn:aws:eks:\n   * @attribute\n   */\n  readonly clusterArn: string;\n\n  /**\n   * The API Server endpoint URL\n   * @attribute\n   */\n  readonly clusterEndpoint: string;\n\n  /**\n   * The certificate-authority-data for your cluster.\n   * @attribute\n   */\n  readonly clusterCertificateAuthorityData: string;\n\n  /**\n   * The id of the cluster security group that was created by Amazon EKS for the cluster.\n   * @attribute\n   */\n  readonly clusterSecurityGroupId: string;\n\n  /**\n   * The cluster security group that was created by Amazon EKS for the cluster.\n   * @attribute\n   */\n  readonly clusterSecurityGroup: ec2.ISecurityGroup;\n\n  /**\n   * Amazon Resource Name (ARN) or alias of the customer master key (CMK).\n   * @attribute\n   */\n  readonly clusterEncryptionConfigKeyArn: string;\n\n  /**\n   * The Open ID Connect Provider of the cluster used to configure Service Accounts.\n   */\n  readonly openIdConnectProvider: iam.IOpenIdConnectProvider;\n\n  /**\n   * An IAM role that can perform kubectl operations against this cluster.\n   *\n   * The role should be mapped to the `system:masters` Kubernetes RBAC role.\n   */\n  readonly kubectlRole?: iam.IRole;\n\n  /**\n   * Custom environment variables when running `kubectl` against this cluster.\n   */\n  readonly kubectlEnvironment?: { [key: string]: string };\n\n  /**\n   * A security group to use for `kubectl` execution.\n   *\n   * If this is undefined, the k8s endpoint is expected to be accessible\n   * publicly.\n   */\n  readonly kubectlSecurityGroup?: ec2.ISecurityGroup;\n\n  /**\n   * Subnets to host the `kubectl` compute resources.\n   *\n   * If this is undefined, the k8s endpoint is expected to be accessible\n   * publicly.\n   */\n  readonly kubectlPrivateSubnets?: ec2.ISubnet[];\n\n  /**\n   * An IAM role that can perform kubectl operations against this cluster.\n   *\n   * The role should be mapped to the `system:masters` Kubernetes RBAC role.\n   *\n   * This role is directly passed to the lambda handler that sends Kube Ctl commands to the cluster.\n   */\n  readonly kubectlLambdaRole?: iam.IRole;\n\n  /**\n   * An AWS Lambda layer that includes `kubectl`, `helm` and the `aws` CLI.\n   *\n   * If not defined, a default layer will be used.\n   */\n  readonly kubectlLayer?: lambda.ILayerVersion;\n\n  /**\n   * Kubectl Provider for issuing kubectl commands against it\n   *\n   * If not defined, a default provider will be used\n   */\n  readonly kubectlProvider?: IKubectlProvider;\n\n  /**\n   * Amount of memory to allocate to the provider's lambda function.\n   */\n  readonly kubectlMemory?: Size;\n\n  /**\n   * A security group to associate with the Cluster Handler's Lambdas.\n   * The Cluster Handler's Lambdas are responsible for calling AWS's EKS API.\n   *\n   * Requires `placeClusterHandlerInVpc` to be set to true.\n   *\n   * @default - No security group.\n   * @attribute\n   */\n  readonly clusterHandlerSecurityGroup?: ec2.ISecurityGroup;\n\n  /**\n   * An AWS Lambda layer that includes the NPM dependency `proxy-agent`.\n   *\n   * If not defined, a default layer will be used.\n   */\n  readonly onEventLayer?: lambda.ILayerVersion;\n\n  /**\n   * Indicates whether Kubernetes resources can be automatically pruned. When\n   * this is enabled (default), prune labels will be allocated and injected to\n   * each resource. These labels will then be used when issuing the `kubectl\n   * apply` operation with the `--prune` switch.\n   */\n  readonly prune: boolean;\n\n  /**\n   * Creates a new service account with corresponding IAM Role (IRSA).\n   *\n   * @param id logical id of service account\n   * @param options service account options\n   */\n  addServiceAccount(id: string, options?: ServiceAccountOptions): ServiceAccount;\n\n  /**\n   * Defines a Kubernetes resource in this cluster.\n   *\n   * The manifest will be applied/deleted using kubectl as needed.\n   *\n   * @param id logical id of this manifest\n   * @param manifest a list of Kubernetes resource specifications\n   * @returns a `KubernetesManifest` object.\n   */\n  addManifest(id: string, ...manifest: Record<string, any>[]): KubernetesManifest;\n\n  /**\n   * Defines a Helm chart in this cluster.\n   *\n   * @param id logical id of this chart.\n   * @param options options of this chart.\n   * @returns a `HelmChart` construct\n   */\n  addHelmChart(id: string, options: HelmChartOptions): HelmChart;\n\n  /**\n   * Defines a CDK8s chart in this cluster.\n   *\n   * @param id logical id of this chart.\n   * @param chart the cdk8s chart.\n   * @returns a `KubernetesManifest` construct representing the chart.\n   */\n  addCdk8sChart(id: string, chart: Construct, options?: KubernetesManifestOptions): KubernetesManifest;\n\n  /**\n   * Connect capacity in the form of an existing AutoScalingGroup to the EKS cluster.\n   *\n   * The AutoScalingGroup must be running an EKS-optimized AMI containing the\n   * /etc/eks/bootstrap.sh script. This method will configure Security Groups,\n   * add the right policies to the instance role, apply the right tags, and add\n   * the required user data to the instance's launch configuration.\n   *\n   * Spot instances will be labeled `lifecycle=Ec2Spot` and tainted with `PreferNoSchedule`.\n   * If kubectl is enabled, the\n   * [spot interrupt handler](https://github.com/awslabs/ec2-spot-labs/tree/master/ec2-spot-eks-solution/spot-termination-handler)\n   * daemon will be installed on all spot instances to handle\n   * [EC2 Spot Instance Termination Notices](https://aws.amazon.com/blogs/aws/new-ec2-spot-instance-termination-notices/).\n   *\n   * Prefer to use `addAutoScalingGroupCapacity` if possible.\n   *\n   * @see https://docs.aws.amazon.com/eks/latest/userguide/launch-workers.html\n   * @param autoScalingGroup [disable-awslint:ref-via-interface]\n   * @param options options for adding auto scaling groups, like customizing the bootstrap script\n   */\n  connectAutoScalingGroupCapacity(autoScalingGroup: autoscaling.AutoScalingGroup, options: AutoScalingGroupOptions): void;\n}\n\n/**\n * Attributes for EKS clusters.\n */\nexport interface ClusterAttributes {\n  /**\n   * The VPC in which this Cluster was created\n   * @default - if not specified `cluster.vpc` will throw an error\n   */\n  readonly vpc?: ec2.IVpc;\n\n  /**\n   * The physical name of the Cluster\n   */\n  readonly clusterName: string;\n\n  /**\n   * The API Server endpoint URL\n   * @default - if not specified `cluster.clusterEndpoint` will throw an error.\n   */\n  readonly clusterEndpoint?: string;\n\n  /**\n   * The certificate-authority-data for your cluster.\n   * @default - if not specified `cluster.clusterCertificateAuthorityData` will\n   * throw an error\n   */\n  readonly clusterCertificateAuthorityData?: string;\n\n  /**\n   * The cluster security group that was created by Amazon EKS for the cluster.\n   * @default - if not specified `cluster.clusterSecurityGroupId` will throw an\n   * error\n   */\n  readonly clusterSecurityGroupId?: string;\n\n  /**\n   * Amazon Resource Name (ARN) or alias of the customer master key (CMK).\n   * @default - if not specified `cluster.clusterEncryptionConfigKeyArn` will\n   * throw an error\n   */\n  readonly clusterEncryptionConfigKeyArn?: string;\n\n  /**\n   * Additional security groups associated with this cluster.\n   * @default - if not specified, no additional security groups will be\n   * considered in `cluster.connections`.\n   */\n  readonly securityGroupIds?: string[];\n\n  /**\n   * An IAM role with cluster administrator and \"system:masters\" permissions.\n   * @default - if not specified, it not be possible to issue `kubectl` commands\n   * against an imported cluster.\n   */\n  readonly kubectlRoleArn?: string;\n\n  /**\n   * An IAM role that can perform kubectl operations against this cluster.\n   *\n   * The role should be mapped to the `system:masters` Kubernetes RBAC role.\n   *\n   * This role is directly passed to the lambda handler that sends Kube Ctl commands\n   * to the cluster.\n   * @default - if not specified, the default role created by a lambda function will\n   * be used.\n   */\n  readonly kubectlLambdaRole?: iam.IRole;\n\n  /**\n   * Environment variables to use when running `kubectl` against this cluster.\n   * @default - no additional variables\n   */\n  readonly kubectlEnvironment?: { [name: string]: string };\n\n  /**\n   * A security group to use for `kubectl` execution. If not specified, the k8s\n   * endpoint is expected to be accessible publicly.\n   * @default - k8s endpoint is expected to be accessible publicly\n   */\n  readonly kubectlSecurityGroupId?: string;\n\n  /**\n   * Subnets to host the `kubectl` compute resources. If not specified, the k8s\n   * endpoint is expected to be accessible publicly.\n   * @default - k8s endpoint is expected to be accessible publicly\n   */\n  readonly kubectlPrivateSubnetIds?: string[];\n\n  /**\n   * An Open ID Connect provider for this cluster that can be used to configure service accounts.\n   * You can either import an existing provider using `iam.OpenIdConnectProvider.fromProviderArn`,\n   * or create a new provider using `new eks.OpenIdConnectProvider`\n   * @default - if not specified `cluster.openIdConnectProvider` and `cluster.addServiceAccount` will throw an error.\n   */\n  readonly openIdConnectProvider?: iam.IOpenIdConnectProvider;\n\n  /**\n   * An AWS Lambda Layer which includes `kubectl`, Helm and the AWS CLI. This layer\n   * is used by the kubectl handler to apply manifests and install helm charts.\n   *\n   * The handler expects the layer to include the following executables:\n   *\n   *    helm/helm\n   *    kubectl/kubectl\n   *    awscli/aws\n   *\n   * @default - a layer bundled with this module.\n   */\n  readonly kubectlLayer?: lambda.ILayerVersion;\n\n  /**\n   * KubectlProvider for issuing kubectl commands.\n   *\n   * @default - Default CDK provider\n   */\n  readonly kubectlProvider?: IKubectlProvider;\n\n  /**\n   * Amount of memory to allocate to the provider's lambda function.\n   *\n   * @default Size.gibibytes(1)\n   */\n  readonly kubectlMemory?: Size;\n\n  /**\n   * A security group id to associate with the Cluster Handler's Lambdas.\n   * The Cluster Handler's Lambdas are responsible for calling AWS's EKS API.\n   *\n   * @default - No security group.\n   */\n  readonly clusterHandlerSecurityGroupId?: string;\n\n  /**\n   * An AWS Lambda Layer which includes the NPM dependency `proxy-agent`. This layer\n   * is used by the onEvent handler to route AWS SDK requests through a proxy.\n   *\n   * The handler expects the layer to include the following node_modules:\n   *\n   *    proxy-agent\n   *\n   * @default - a layer bundled with this module.\n   */\n  readonly onEventLayer?: lambda.ILayerVersion;\n\n  /**\n   * Indicates whether Kubernetes resources added through `addManifest()` can be\n   * automatically pruned. When this is enabled (default), prune labels will be\n   * allocated and injected to each resource. These labels will then be used\n   * when issuing the `kubectl apply` operation with the `--prune` switch.\n   *\n   * @default true\n   */\n  readonly prune?: boolean;\n}\n\n/**\n * Options for configuring an EKS cluster.\n */\nexport interface CommonClusterOptions {\n  /**\n   * The VPC in which to create the Cluster.\n   *\n   * @default - a VPC with default configuration will be created and can be accessed through `cluster.vpc`.\n   */\n  readonly vpc?: ec2.IVpc;\n\n  /**\n   * Where to place EKS Control Plane ENIs\n   *\n   * If you want to create public load balancers, this must include public subnets.\n   *\n   * For example, to only select private subnets, supply the following:\n   *\n   * `vpcSubnets: [{ subnetType: ec2.SubnetType.PRIVATE }]`\n   *\n   * @default - All public and private subnets\n   */\n  readonly vpcSubnets?: ec2.SubnetSelection[];\n\n  /**\n   * Role that provides permissions for the Kubernetes control plane to make calls to AWS API operations on your behalf.\n   *\n   * @default - A role is automatically created for you\n   */\n  readonly role?: iam.IRole;\n\n  /**\n   * Name for the cluster.\n   *\n   * @default - Automatically generated name\n   */\n  readonly clusterName?: string;\n\n  /**\n   * Security Group to use for Control Plane ENIs\n   *\n   * @default - A security group is automatically created\n   */\n  readonly securityGroup?: ec2.ISecurityGroup;\n\n  /**\n   * The Kubernetes version to run in the cluster\n   */\n  readonly version: KubernetesVersion;\n\n  /**\n   * Determines whether a CloudFormation output with the name of the cluster\n   * will be synthesized.\n   *\n   * @default false\n   */\n  readonly outputClusterName?: boolean;\n\n  /**\n   * Determines whether a CloudFormation output with the `aws eks\n   * update-kubeconfig` command will be synthesized. This command will include\n   * the cluster name and, if applicable, the ARN of the masters IAM role.\n   *\n   * @default true\n   */\n  readonly outputConfigCommand?: boolean;\n}\n\n/**\n * Options for EKS clusters.\n */\nexport interface ClusterOptions extends CommonClusterOptions {\n  /**\n   * An IAM role that will be added to the `system:masters` Kubernetes RBAC\n   * group.\n   *\n   * @see https://kubernetes.io/docs/reference/access-authn-authz/rbac/#default-roles-and-role-bindings\n   *\n   * @default - a role that assumable by anyone with permissions in the same\n   * account will automatically be defined\n   */\n  readonly mastersRole?: iam.IRole;\n\n  /**\n   * Controls the \"eks.amazonaws.com/compute-type\" annotation in the CoreDNS\n   * configuration on your cluster to determine which compute type to use\n   * for CoreDNS.\n   *\n   * @default CoreDnsComputeType.EC2 (for `FargateCluster` the default is FARGATE)\n   */\n  readonly coreDnsComputeType?: CoreDnsComputeType;\n\n  /**\n   * Determines whether a CloudFormation output with the ARN of the \"masters\"\n   * IAM role will be synthesized (if `mastersRole` is specified).\n   *\n   * @default false\n   */\n  readonly outputMastersRoleArn?: boolean;\n\n  /**\n   * Configure access to the Kubernetes API server endpoint..\n   *\n   * @see https://docs.aws.amazon.com/eks/latest/userguide/cluster-endpoint.html\n   *\n   * @default EndpointAccess.PUBLIC_AND_PRIVATE\n   */\n  readonly endpointAccess?: EndpointAccess;\n\n  /**\n   * Environment variables for the kubectl execution. Only relevant for kubectl enabled clusters.\n   *\n   * @default - No environment variables.\n   */\n  readonly kubectlEnvironment?: { [key: string]: string };\n\n  /**\n   * An AWS Lambda Layer which includes `kubectl`, Helm and the AWS CLI.\n   *\n   * By default, the provider will use the layer included in the\n   * \"aws-lambda-layer-kubectl\" SAR application which is available in all\n   * commercial regions.\n   *\n   * To deploy the layer locally, visit\n   * https://github.com/aws-samples/aws-lambda-layer-kubectl/blob/master/cdk/README.md\n   * for instructions on how to prepare the .zip file and then define it in your\n   * app as follows:\n   *\n   * ```ts\n   * const layer = new lambda.LayerVersion(this, 'kubectl-layer', {\n   *   code: lambda.Code.fromAsset(`${__dirname}/layer.zip`),\n   *   compatibleRuntimes: [lambda.Runtime.PROVIDED],\n   * });\n   * ```\n   *\n   * @default - the layer provided by the `aws-lambda-layer-kubectl` SAR app.\n   * @see https://github.com/aws-samples/aws-lambda-layer-kubectl\n   */\n  readonly kubectlLayer?: lambda.ILayerVersion;\n\n  /**\n   * Amount of memory to allocate to the provider's lambda function.\n   *\n   * @default Size.gibibytes(1)\n   */\n  readonly kubectlMemory?: Size;\n\n  /**\n   * Custom environment variables when interacting with the EKS endpoint to manage the cluster lifecycle.\n   *\n   * @default - No environment variables.\n   */\n  readonly clusterHandlerEnvironment?: { [key: string]: string };\n\n  /**\n   * A security group to associate with the Cluster Handler's Lambdas.\n   * The Cluster Handler's Lambdas are responsible for calling AWS's EKS API.\n   *\n   * Requires `placeClusterHandlerInVpc` to be set to true.\n   *\n   * @default - No security group.\n   */\n  readonly clusterHandlerSecurityGroup?: ec2.ISecurityGroup;\n\n  /**\n   * An AWS Lambda Layer which includes the NPM dependency `proxy-agent`. This layer\n   * is used by the onEvent handler to route AWS SDK requests through a proxy.\n   *\n   * By default, the provider will use the layer included in the\n   * \"aws-lambda-layer-node-proxy-agent\" SAR application which is available in all\n   * commercial regions.\n   *\n   * To deploy the layer locally define it in your app as follows:\n   *\n   * ```ts\n   * const layer = new lambda.LayerVersion(this, 'proxy-agent-layer', {\n   *   code: lambda.Code.fromAsset(`${__dirname}/layer.zip`),\n   *   compatibleRuntimes: [lambda.Runtime.NODEJS_12_X],\n   * });\n   * ```\n   *\n   * @default - a layer bundled with this module.\n   */\n  readonly onEventLayer?: lambda.ILayerVersion;\n\n  /**\n   * Indicates whether Kubernetes resources added through `addManifest()` can be\n   * automatically pruned. When this is enabled (default), prune labels will be\n   * allocated and injected to each resource. These labels will then be used\n   * when issuing the `kubectl apply` operation with the `--prune` switch.\n   *\n   * @default true\n   */\n  readonly prune?: boolean;\n\n  /**\n   * If set to true, the cluster handler functions will be placed in the private subnets\n   * of the cluster vpc, subject to the `vpcSubnets` selection strategy.\n   *\n   * @default false\n   */\n  readonly placeClusterHandlerInVpc?: boolean;\n\n  /**\n   * KMS secret for envelope encryption for Kubernetes secrets.\n   *\n   * @default - By default, Kubernetes stores all secret object data within etcd and\n   *            all etcd volumes used by Amazon EKS are encrypted at the disk-level\n   *            using AWS-Managed encryption keys.\n   */\n  readonly secretsEncryptionKey?: kms.IKey;\n\n  /**\n   * The CIDR block to assign Kubernetes service IP addresses from.\n   *\n   * @default - Kubernetes assigns addresses from either the\n   *            10.100.0.0/16 or 172.20.0.0/16 CIDR blocks\n   * @see https://docs.aws.amazon.com/eks/latest/APIReference/API_KubernetesNetworkConfigRequest.html#AmazonEKS-Type-KubernetesNetworkConfigRequest-serviceIpv4Cidr\n   */\n  readonly serviceIpv4Cidr?: string;\n\n  /**\n   * Install the AWS Load Balancer Controller onto the cluster.\n   *\n   * @see https://kubernetes-sigs.github.io/aws-load-balancer-controller\n   *\n   * @default - The controller is not installed.\n   */\n  readonly albController?: AlbControllerOptions;\n}\n\n/**\n * Group access configuration together.\n */\ninterface EndpointAccessConfig {\n\n  /**\n   * Indicates if private access is enabled.\n   */\n  readonly privateAccess: boolean;\n\n  /**\n   * Indicates if public access is enabled.\n   */\n  readonly publicAccess: boolean;\n  /**\n   * Public access is allowed only from these CIDR blocks.\n   * An empty array means access is open to any address.\n   *\n   * @default - No restrictions.\n   */\n  readonly publicCidrs?: string[];\n\n}\n\n/**\n * Endpoint access characteristics.\n */\nexport class EndpointAccess {\n\n  /**\n   * The cluster endpoint is accessible from outside of your VPC.\n   * Worker node traffic will leave your VPC to connect to the endpoint.\n   *\n   * By default, the endpoint is exposed to all adresses. You can optionally limit the CIDR blocks that can access the public endpoint using the `PUBLIC.onlyFrom` method.\n   * If you limit access to specific CIDR blocks, you must ensure that the CIDR blocks that you\n   * specify include the addresses that worker nodes and Fargate pods (if you use them)\n   * access the public endpoint from.\n   *\n   * @param cidr The CIDR blocks.\n   */\n  public static readonly PUBLIC = new EndpointAccess({ privateAccess: false, publicAccess: true });\n\n  /**\n   * The cluster endpoint is only accessible through your VPC.\n   * Worker node traffic to the endpoint will stay within your VPC.\n   */\n  public static readonly PRIVATE = new EndpointAccess({ privateAccess: true, publicAccess: false });\n\n  /**\n   * The cluster endpoint is accessible from outside of your VPC.\n   * Worker node traffic to the endpoint will stay within your VPC.\n   *\n   * By default, the endpoint is exposed to all adresses. You can optionally limit the CIDR blocks that can access the public endpoint using the `PUBLIC_AND_PRIVATE.onlyFrom` method.\n   * If you limit access to specific CIDR blocks, you must ensure that the CIDR blocks that you\n   * specify include the addresses that worker nodes and Fargate pods (if you use them)\n   * access the public endpoint from.\n   *\n   * @param cidr The CIDR blocks.\n   */\n  public static readonly PUBLIC_AND_PRIVATE = new EndpointAccess({ privateAccess: true, publicAccess: true });\n\n  private constructor(\n    /**\n     * Configuration properties.\n     *\n     * @internal\n     */\n    public readonly _config: EndpointAccessConfig) {\n    if (!_config.publicAccess && _config.publicCidrs && _config.publicCidrs.length > 0) {\n      throw new Error('CIDR blocks can only be configured when public access is enabled');\n    }\n  }\n\n\n  /**\n   * Restrict public access to specific CIDR blocks.\n   * If public access is disabled, this method will result in an error.\n   *\n   * @param cidr CIDR blocks.\n   */\n  public onlyFrom(...cidr: string[]) {\n    if (!this._config.privateAccess) {\n      // when private access is disabled, we can't restric public\n      // access since it will render the kubectl provider unusable.\n      throw new Error('Cannot restric public access to endpoint when private access is disabled. Use PUBLIC_AND_PRIVATE.onlyFrom() instead.');\n    }\n    return new EndpointAccess({\n      ...this._config,\n      // override CIDR\n      publicCidrs: cidr,\n    });\n  }\n}\n\n/**\n * Common configuration props for EKS clusters.\n */\nexport interface ClusterProps extends ClusterOptions {\n\n  /**\n   * Number of instances to allocate as an initial capacity for this cluster.\n   * Instance type can be configured through `defaultCapacityInstanceType`,\n   * which defaults to `m5.large`.\n   *\n   * Use `cluster.addAutoScalingGroupCapacity` to add additional customized capacity. Set this\n   * to `0` is you wish to avoid the initial capacity allocation.\n   *\n   * @default 2\n   */\n  readonly defaultCapacity?: number;\n\n  /**\n   * The instance type to use for the default capacity. This will only be taken\n   * into account if `defaultCapacity` is > 0.\n   *\n   * @default m5.large\n   */\n  readonly defaultCapacityInstance?: ec2.InstanceType;\n\n  /**\n   * The default capacity type for the cluster.\n   *\n   * @default NODEGROUP\n   */\n  readonly defaultCapacityType?: DefaultCapacityType;\n\n  /**\n   * The IAM role to pass to the Kubectl Lambda Handler.\n   *\n   * @default - Default Lambda IAM Execution Role\n   */\n  readonly kubectlLambdaRole?: iam.IRole;\n\n  /**\n   * The tags assigned to the EKS cluster\n   *\n   * @default - none\n   */\n  readonly tags?: { [key: string]: string };\n\n  /**\n   * The cluster log types which you want to enable.\n   *\n   * @default - none\n   */\n  readonly clusterLogging?: ClusterLoggingTypes[];\n}\n\n/**\n * Kubernetes cluster version\n */\nexport class KubernetesVersion {\n  /**\n   * Kubernetes version 1.14\n   * @deprecated Use newer version of EKS\n   */\n  public static readonly V1_14 = KubernetesVersion.of('1.14');\n\n  /**\n   * Kubernetes version 1.15\n   * @deprecated Use newer version of EKS\n   */\n  public static readonly V1_15 = KubernetesVersion.of('1.15');\n\n  /**\n   * Kubernetes version 1.16\n   * @deprecated Use newer version of EKS\n   */\n  public static readonly V1_16 = KubernetesVersion.of('1.16');\n\n  /**\n   * Kubernetes version 1.17\n   * @deprecated Use newer version of EKS\n   */\n  public static readonly V1_17 = KubernetesVersion.of('1.17');\n\n  /**\n   * Kubernetes version 1.18\n   * @deprecated Use newer version of EKS\n   */\n  public static readonly V1_18 = KubernetesVersion.of('1.18');\n\n  /**\n   * Kubernetes version 1.19\n   */\n  public static readonly V1_19 = KubernetesVersion.of('1.19');\n\n  /**\n   * Kubernetes version 1.20\n   */\n  public static readonly V1_20 = KubernetesVersion.of('1.20');\n\n  /**\n   * Kubernetes version 1.21\n   */\n  public static readonly V1_21 = KubernetesVersion.of('1.21');\n\n  /**\n   * Kubernetes version 1.22\n   */\n  public static readonly V1_22 = KubernetesVersion.of('1.22');\n\n  /**\n   * Custom cluster version\n   * @param version custom version number\n   */\n  public static of(version: string) { return new KubernetesVersion(version); }\n  /**\n   *\n   * @param version cluster version number\n   */\n  private constructor(public readonly version: string) { }\n}\n\n/**\n * EKS cluster logging types\n */\nexport enum ClusterLoggingTypes {\n  /**\n   * Logs pertaining to API requests to the cluster.\n   */\n  API = 'api',\n  /**\n   * Logs pertaining to cluster access via the Kubernetes API.\n   */\n  AUDIT = 'audit',\n  /**\n   * Logs pertaining to authentication requests into the cluster.\n   */\n  AUTHENTICATOR = 'authenticator',\n  /**\n   * Logs pertaining to state of cluster controllers.\n   */\n  CONTROLLER_MANAGER = 'controllerManager',\n  /**\n   * Logs pertaining to scheduling decisions.\n   */\n  SCHEDULER = 'scheduler',\n}\n\nabstract class ClusterBase extends Resource implements ICluster {\n  public abstract readonly connections: ec2.Connections;\n  public abstract readonly vpc: ec2.IVpc;\n  public abstract readonly clusterName: string;\n  public abstract readonly clusterArn: string;\n  public abstract readonly clusterEndpoint: string;\n  public abstract readonly clusterCertificateAuthorityData: string;\n  public abstract readonly clusterSecurityGroupId: string;\n  public abstract readonly clusterSecurityGroup: ec2.ISecurityGroup;\n  public abstract readonly clusterEncryptionConfigKeyArn: string;\n  public abstract readonly kubectlRole?: iam.IRole;\n  public abstract readonly kubectlLambdaRole?: iam.IRole;\n  public abstract readonly kubectlEnvironment?: { [key: string]: string };\n  public abstract readonly kubectlSecurityGroup?: ec2.ISecurityGroup;\n  public abstract readonly kubectlPrivateSubnets?: ec2.ISubnet[];\n  public abstract readonly kubectlMemory?: Size;\n  public abstract readonly clusterHandlerSecurityGroup?: ec2.ISecurityGroup;\n  public abstract readonly prune: boolean;\n  public abstract readonly openIdConnectProvider: iam.IOpenIdConnectProvider;\n  public abstract readonly awsAuth: AwsAuth;\n\n  private _spotInterruptHandler?: HelmChart;\n\n  /**\n   * Manages the aws-auth config map.\n   *\n   * @internal\n   */\n  protected _awsAuth?: AwsAuth;\n\n  /**\n   * Defines a Kubernetes resource in this cluster.\n   *\n   * The manifest will be applied/deleted using kubectl as needed.\n   *\n   * @param id logical id of this manifest\n   * @param manifest a list of Kubernetes resource specifications\n   * @returns a `KubernetesResource` object.\n   */\n  public addManifest(id: string, ...manifest: Record<string, any>[]): KubernetesManifest {\n    return new KubernetesManifest(this, `manifest-${id}`, { cluster: this, manifest });\n  }\n\n  /**\n   * Defines a Helm chart in this cluster.\n   *\n   * @param id logical id of this chart.\n   * @param options options of this chart.\n   * @returns a `HelmChart` construct\n   */\n  public addHelmChart(id: string, options: HelmChartOptions): HelmChart {\n    return new HelmChart(this, `chart-${id}`, { cluster: this, ...options });\n  }\n\n  /**\n   * Defines a CDK8s chart in this cluster.\n   *\n   * @param id logical id of this chart.\n   * @param chart the cdk8s chart.\n   * @returns a `KubernetesManifest` construct representing the chart.\n   */\n  public addCdk8sChart(id: string, chart: Construct, options: KubernetesManifestOptions = {}): KubernetesManifest {\n\n    const cdk8sChart = chart as any;\n\n    // see https://github.com/awslabs/cdk8s/blob/master/packages/cdk8s/src/chart.ts#L84\n    if (typeof cdk8sChart.toJson !== 'function') {\n      throw new Error(`Invalid cdk8s chart. Must contain a 'toJson' method, but found ${typeof cdk8sChart.toJson}`);\n    }\n\n    const manifest = new KubernetesManifest(this, id, {\n      cluster: this,\n      manifest: cdk8sChart.toJson(),\n      ...options,\n    });\n\n    return manifest;\n  }\n\n  public addServiceAccount(id: string, options: ServiceAccountOptions = {}): ServiceAccount {\n    return new ServiceAccount(this, id, {\n      ...options,\n      cluster: this,\n    });\n  }\n\n  /**\n   * Installs the AWS spot instance interrupt handler on the cluster if it's not\n   * already added.\n   */\n  private addSpotInterruptHandler() {\n    if (!this._spotInterruptHandler) {\n      this._spotInterruptHandler = this.addHelmChart('spot-interrupt-handler', {\n        chart: 'aws-node-termination-handler',\n        version: '0.18.0',\n        repository: 'https://aws.github.io/eks-charts',\n        namespace: 'kube-system',\n        values: {\n          nodeSelector: {\n            lifecycle: LifecycleLabel.SPOT,\n          },\n        },\n      });\n    }\n\n    return this._spotInterruptHandler;\n  }\n\n  /**\n   * Connect capacity in the form of an existing AutoScalingGroup to the EKS cluster.\n   *\n   * The AutoScalingGroup must be running an EKS-optimized AMI containing the\n   * /etc/eks/bootstrap.sh script. This method will configure Security Groups,\n   * add the right policies to the instance role, apply the right tags, and add\n   * the required user data to the instance's launch configuration.\n   *\n   * Spot instances will be labeled `lifecycle=Ec2Spot` and tainted with `PreferNoSchedule`.\n   * If kubectl is enabled, the\n   * [spot interrupt handler](https://github.com/awslabs/ec2-spot-labs/tree/master/ec2-spot-eks-solution/spot-termination-handler)\n   * daemon will be installed on all spot instances to handle\n   * [EC2 Spot Instance Termination Notices](https://aws.amazon.com/blogs/aws/new-ec2-spot-instance-termination-notices/).\n   *\n   * Prefer to use `addAutoScalingGroupCapacity` if possible.\n   *\n   * @see https://docs.aws.amazon.com/eks/latest/userguide/launch-workers.html\n   * @param autoScalingGroup [disable-awslint:ref-via-interface]\n   * @param options options for adding auto scaling groups, like customizing the bootstrap script\n   */\n  public connectAutoScalingGroupCapacity(autoScalingGroup: autoscaling.AutoScalingGroup, options: AutoScalingGroupOptions) {\n    // self rules\n    autoScalingGroup.connections.allowInternally(ec2.Port.allTraffic());\n\n    // Cluster to:nodes rules\n    autoScalingGroup.connections.allowFrom(this, ec2.Port.tcp(443));\n    autoScalingGroup.connections.allowFrom(this, ec2.Port.tcpRange(1025, 65535));\n\n    // Allow HTTPS from Nodes to Cluster\n    autoScalingGroup.connections.allowTo(this, ec2.Port.tcp(443));\n\n    // Allow all node outbound traffic\n    autoScalingGroup.connections.allowToAnyIpv4(ec2.Port.allTcp());\n    autoScalingGroup.connections.allowToAnyIpv4(ec2.Port.allUdp());\n    autoScalingGroup.connections.allowToAnyIpv4(ec2.Port.allIcmp());\n\n    // allow traffic to/from managed node groups (eks attaches this security group to the managed nodes)\n    autoScalingGroup.addSecurityGroup(this.clusterSecurityGroup);\n\n    const bootstrapEnabled = options.bootstrapEnabled ?? true;\n    if (options.bootstrapOptions && !bootstrapEnabled) {\n      throw new Error('Cannot specify \"bootstrapOptions\" if \"bootstrapEnabled\" is false');\n    }\n\n    if (bootstrapEnabled) {\n      const userData = options.machineImageType === MachineImageType.BOTTLEROCKET ?\n        renderBottlerocketUserData(this) :\n        renderAmazonLinuxUserData(this, autoScalingGroup, options.bootstrapOptions);\n      autoScalingGroup.addUserData(...userData);\n    }\n\n    autoScalingGroup.role.addManagedPolicy(iam.ManagedPolicy.fromAwsManagedPolicyName('AmazonEKSWorkerNodePolicy'));\n    autoScalingGroup.role.addManagedPolicy(iam.ManagedPolicy.fromAwsManagedPolicyName('AmazonEKS_CNI_Policy'));\n    autoScalingGroup.role.addManagedPolicy(iam.ManagedPolicy.fromAwsManagedPolicyName('AmazonEC2ContainerRegistryReadOnly'));\n\n    // EKS Required Tags\n    // https://docs.aws.amazon.com/eks/latest/userguide/worker.html\n    Tags.of(autoScalingGroup).add(`kubernetes.io/cluster/${this.clusterName}`, 'owned', {\n      applyToLaunchedInstances: true,\n      // exclude security groups to avoid multiple \"owned\" security groups.\n      // (the cluster security group already has this tag)\n      excludeResourceTypes: ['AWS::EC2::SecurityGroup'],\n    });\n\n    // do not attempt to map the role if `kubectl` is not enabled for this\n    // cluster or if `mapRole` is set to false. By default this should happen.\n    let mapRole = options.mapRole ?? true;\n    if (mapRole && !(this instanceof Cluster)) {\n      // do the mapping...\n      Annotations.of(autoScalingGroup).addWarning('Auto-mapping aws-auth role for imported cluster is not supported, please map role manually');\n      mapRole = false;\n    }\n    if (mapRole) {\n      // see https://docs.aws.amazon.com/en_us/eks/latest/userguide/add-user-role.html\n      this.awsAuth.addRoleMapping(autoScalingGroup.role, {\n        username: 'system:node:{{EC2PrivateDNSName}}',\n        groups: [\n          'system:bootstrappers',\n          'system:nodes',\n        ],\n      });\n    } else {\n      // since we are not mapping the instance role to RBAC, synthesize an\n      // output so it can be pasted into `aws-auth-cm.yaml`\n      new CfnOutput(autoScalingGroup, 'InstanceRoleARN', {\n        value: autoScalingGroup.role.roleArn,\n      });\n    }\n\n    const addSpotInterruptHandler = options.spotInterruptHandler ?? true;\n    // if this is an ASG with spot instances, install the spot interrupt handler (only if kubectl is enabled).\n    if (autoScalingGroup.spotPrice && addSpotInterruptHandler) {\n      this.addSpotInterruptHandler();\n    }\n\n    if (this instanceof Cluster && this.albController) {\n      // the controller runs on the worker nodes so they cannot\n      // be deleted before the controller.\n      Node.of(this.albController).addDependency(autoScalingGroup);\n    }\n  }\n}\n\n/**\n * Options for fetching a ServiceLoadBalancerAddress.\n */\nexport interface ServiceLoadBalancerAddressOptions {\n\n  /**\n   * Timeout for waiting on the load balancer address.\n   *\n   * @default Duration.minutes(5)\n   */\n  readonly timeout?: Duration;\n\n  /**\n   * The namespace the service belongs to.\n   *\n   * @default 'default'\n   */\n  readonly namespace?: string;\n\n}\n\n/**\n * Options for fetching an IngressLoadBalancerAddress.\n */\nexport interface IngressLoadBalancerAddressOptions extends ServiceLoadBalancerAddressOptions {};\n\n/**\n * A Cluster represents a managed Kubernetes Service (EKS)\n *\n * This is a fully managed cluster of API Servers (control-plane)\n * The user is still required to create the worker nodes.\n */\nexport class Cluster extends ClusterBase {\n  /**\n   * Import an existing cluster\n   *\n   * @param scope the construct scope, in most cases 'this'\n   * @param id the id or name to import as\n   * @param attrs the cluster properties to use for importing information\n   */\n  public static fromClusterAttributes(scope: Construct, id: string, attrs: ClusterAttributes): ICluster {\n    return new ImportedCluster(scope, id, attrs);\n  }\n\n  /**\n   * The VPC in which this Cluster was created\n   */\n  public readonly vpc: ec2.IVpc;\n\n  /**\n   * The Name of the created EKS Cluster\n   */\n  public readonly clusterName: string;\n\n  /**\n   * The AWS generated ARN for the Cluster resource\n   *\n   * For example, `arn:aws:eks:us-west-2:666666666666:cluster/prod`\n   */\n  public readonly clusterArn: string;\n\n  /**\n   * The endpoint URL for the Cluster\n   *\n   * This is the URL inside the kubeconfig file to use with kubectl\n   *\n   * For example, `https://5E1D0CEXAMPLEA591B746AFC5AB30262.yl4.us-west-2.eks.amazonaws.com`\n   */\n  public readonly clusterEndpoint: string;\n\n  /**\n   * The certificate-authority-data for your cluster.\n   */\n  public readonly clusterCertificateAuthorityData: string;\n\n  /**\n   * The id of the cluster security group that was created by Amazon EKS for the cluster.\n   */\n  public readonly clusterSecurityGroupId: string;\n\n  /**\n   * The cluster security group that was created by Amazon EKS for the cluster.\n   */\n  public readonly clusterSecurityGroup: ec2.ISecurityGroup;\n\n  /**\n   * Amazon Resource Name (ARN) or alias of the customer master key (CMK).\n   */\n  public readonly clusterEncryptionConfigKeyArn: string;\n\n  /**\n   * Manages connection rules (Security Group Rules) for the cluster\n   *\n   * @type {ec2.Connections}\n   * @memberof Cluster\n   */\n  public readonly connections: ec2.Connections;\n\n  /**\n   * IAM role assumed by the EKS Control Plane\n   */\n  public readonly role: iam.IRole;\n\n  /**\n   * The auto scaling group that hosts the default capacity for this cluster.\n   * This will be `undefined` if the `defaultCapacityType` is not `EC2` or\n   * `defaultCapacityType` is `EC2` but default capacity is set to 0.\n   */\n  public readonly defaultCapacity?: autoscaling.AutoScalingGroup;\n\n  /**\n   * The node group that hosts the default capacity for this cluster.\n   * This will be `undefined` if the `defaultCapacityType` is `EC2` or\n   * `defaultCapacityType` is `NODEGROUP` but default capacity is set to 0.\n   */\n  public readonly defaultNodegroup?: Nodegroup;\n\n  /**\n   * An IAM role that can perform kubectl operations against this cluster.\n   *\n   * The role should be mapped to the `system:masters` Kubernetes RBAC role.\n   */\n  public readonly kubectlRole?: iam.IRole;\n\n  /**\n   * An IAM role that can perform kubectl operations against this cluster.\n   *\n   * The role should be mapped to the `system:masters` Kubernetes RBAC role.\n   *\n   * This role is directly passed to the lambda handler that sends Kube Ctl commands to the cluster.\n   * @default - if not specified, the default role created by a lambda function will\n   * be used.\n   */\n\n  public readonly kubectlLambdaRole?: iam.IRole;\n\n  /**\n   * Custom environment variables when running `kubectl` against this cluster.\n   */\n  public readonly kubectlEnvironment?: { [key: string]: string };\n\n  /**\n   * A security group to use for `kubectl` execution.\n   *\n   * @default - If not specified, the k8s endpoint is expected to be accessible\n   * publicly.\n   */\n  public readonly kubectlSecurityGroup?: ec2.ISecurityGroup;\n\n  /**\n   * Subnets to host the `kubectl` compute resources.\n   *\n   * @default - If not specified, the k8s endpoint is expected to be accessible\n   * publicly.\n   */\n  public readonly kubectlPrivateSubnets?: ec2.ISubnet[];\n\n  /**\n   * An IAM role with administrative permissions to create or update the\n   * cluster. This role also has `systems:master` permissions.\n   */\n  public readonly adminRole: iam.Role;\n\n  /**\n   * If the cluster has one (or more) FargateProfiles associated, this array\n   * will hold a reference to each.\n   */\n  private readonly _fargateProfiles: FargateProfile[] = [];\n\n  /**\n   * an Open ID Connect Provider instance\n   */\n  private _openIdConnectProvider?: iam.IOpenIdConnectProvider;\n\n  /**\n   * The AWS Lambda layer that contains `kubectl`, `helm` and the AWS CLI. If\n   * undefined, a SAR app that contains this layer will be used.\n   */\n  public readonly kubectlLayer?: lambda.ILayerVersion;\n\n  /**\n   * The amount of memory allocated to the kubectl provider's lambda function.\n   */\n  public readonly kubectlMemory?: Size;\n\n  /**\n   * A security group to associate with the Cluster Handler's Lambdas.\n   * The Cluster Handler's Lambdas are responsible for calling AWS's EKS API.\n   *\n   * Requires `placeClusterHandlerInVpc` to be set to true.\n   *\n   * @default - No security group.\n   */\n  public readonly clusterHandlerSecurityGroup?: ec2.ISecurityGroup;\n\n  /**\n   * The AWS Lambda layer that contains the NPM dependency `proxy-agent`. If\n   * undefined, a SAR app that contains this layer will be used.\n   */\n  readonly onEventLayer?: lambda.ILayerVersion;\n\n  /**\n   * Determines if Kubernetes resources can be pruned automatically.\n   */\n  public readonly prune: boolean;\n\n  /**\n   * The ALB Controller construct defined for this cluster.\n   * Will be undefined if `albController` wasn't configured.\n   */\n  public readonly albController?: AlbController;\n\n  /**\n   * If this cluster is kubectl-enabled, returns the `ClusterResource` object\n   * that manages it. If this cluster is not kubectl-enabled (i.e. uses the\n   * stock `CfnCluster`), this is `undefined`.\n   */\n  private readonly _clusterResource: ClusterResource;\n\n  private _neuronDevicePlugin?: KubernetesManifest;\n\n  private readonly endpointAccess: EndpointAccess;\n\n  private readonly vpcSubnets: ec2.SubnetSelection[];\n\n  private readonly version: KubernetesVersion;\n\n  private readonly logging?: { [key: string]: [ { [key: string]: any } ] };\n\n  /**\n   * A dummy CloudFormation resource that is used as a wait barrier which\n   * represents that the cluster is ready to receive \"kubectl\" commands.\n   *\n   * Specifically, all fargate profiles are automatically added as a dependency\n   * of this barrier, which means that it will only be \"signaled\" when all\n   * fargate profiles have been successfully created.\n   *\n   * When kubectl resources call `_attachKubectlResourceScope()`, this resource\n   * is added as their dependency which implies that they can only be deployed\n   * after the cluster is ready.\n   */\n  private readonly _kubectlReadyBarrier: CfnResource;\n\n  private readonly _kubectlResourceProvider: KubectlProvider;\n\n  /**\n   * Initiates an EKS Cluster with the supplied arguments\n   *\n   * @param scope a Construct, most likely a cdk.Stack created\n   * @param id the id of the Construct to create\n   * @param props properties in the IClusterProps interface\n   */\n  constructor(scope: Construct, id: string, props: ClusterProps) {\n    super(scope, id, {\n      physicalName: props.clusterName,\n    });\n\n    const stack = Stack.of(this);\n\n    this.prune = props.prune ?? true;\n    this.vpc = props.vpc || new ec2.Vpc(this, 'DefaultVpc');\n    this.version = props.version;\n    this.kubectlLambdaRole = props.kubectlLambdaRole ? props.kubectlLambdaRole : undefined;\n\n    this.tagSubnets();\n\n    // this is the role used by EKS when interacting with AWS resources\n    this.role = props.role || new iam.Role(this, 'Role', {\n      assumedBy: new iam.ServicePrincipal('eks.amazonaws.com'),\n      managedPolicies: [\n        iam.ManagedPolicy.fromAwsManagedPolicyName('AmazonEKSClusterPolicy'),\n      ],\n    });\n\n    const securityGroup = props.securityGroup || new ec2.SecurityGroup(this, 'ControlPlaneSecurityGroup', {\n      vpc: this.vpc,\n      description: 'EKS Control Plane Security Group',\n    });\n\n    this.vpcSubnets = props.vpcSubnets ?? [{ subnetType: ec2.SubnetType.PUBLIC }, { subnetType: ec2.SubnetType.PRIVATE }];\n\n    const selectedSubnetIdsPerGroup = this.vpcSubnets.map(s => this.vpc.selectSubnets(s).subnetIds);\n    if (selectedSubnetIdsPerGroup.some(Token.isUnresolved) && selectedSubnetIdsPerGroup.length > 1) {\n      throw new Error('eks.Cluster: cannot select multiple subnet groups from a VPC imported from list tokens with unknown length. Select only one subnet group, pass a length to Fn.split, or switch to Vpc.fromLookup.');\n    }\n\n    // Get subnetIds for all selected subnets\n    const subnetIds = Array.from(new Set(flatten(selectedSubnetIdsPerGroup)));\n\n    this.logging = props.clusterLogging ? {\n      clusterLogging: [\n        {\n          enabled: true,\n          types: Object.values(props.clusterLogging),\n        },\n      ],\n    } : undefined;\n\n    this.endpointAccess = props.endpointAccess ?? EndpointAccess.PUBLIC_AND_PRIVATE;\n    this.kubectlEnvironment = props.kubectlEnvironment;\n    this.kubectlLayer = props.kubectlLayer;\n    this.kubectlMemory = props.kubectlMemory;\n\n    this.onEventLayer = props.onEventLayer;\n    this.clusterHandlerSecurityGroup = props.clusterHandlerSecurityGroup;\n\n    const privateSubnets = this.selectPrivateSubnets().slice(0, 16);\n    const publicAccessDisabled = !this.endpointAccess._config.publicAccess;\n    const publicAccessRestricted = !publicAccessDisabled\n      && this.endpointAccess._config.publicCidrs\n      && this.endpointAccess._config.publicCidrs.length !== 0;\n\n    // validate endpoint access configuration\n\n    if (privateSubnets.length === 0 && publicAccessDisabled) {\n      // no private subnets and no public access at all, no good.\n      throw new Error('Vpc must contain private subnets when public endpoint access is disabled');\n    }\n\n    if (privateSubnets.length === 0 && publicAccessRestricted) {\n      // no private subnets and public access is restricted, no good.\n      throw new Error('Vpc must contain private subnets when public endpoint access is restricted');\n    }\n\n    const placeClusterHandlerInVpc = props.placeClusterHandlerInVpc ?? false;\n\n    if (placeClusterHandlerInVpc && privateSubnets.length === 0) {\n      throw new Error('Cannot place cluster handler in the VPC since no private subnets could be selected');\n    }\n\n    if (props.clusterHandlerSecurityGroup && !placeClusterHandlerInVpc) {\n      throw new Error('Cannot specify clusterHandlerSecurityGroup without placeClusterHandlerInVpc set to true');\n    }\n\n    const resource = this._clusterResource = new ClusterResource(this, 'Resource', {\n      name: this.physicalName,\n      environment: props.clusterHandlerEnvironment,\n      roleArn: this.role.roleArn,\n      version: props.version.version,\n      resourcesVpcConfig: {\n        securityGroupIds: [securityGroup.securityGroupId],\n        subnetIds,\n      },\n      ...(props.secretsEncryptionKey ? {\n        encryptionConfig: [{\n          provider: {\n            keyArn: props.secretsEncryptionKey.keyArn,\n          },\n          resources: ['secrets'],\n        }],\n      } : {}),\n      kubernetesNetworkConfig: props.serviceIpv4Cidr ? {\n        serviceIpv4Cidr: props.serviceIpv4Cidr,\n      } : undefined,\n      endpointPrivateAccess: this.endpointAccess._config.privateAccess,\n      endpointPublicAccess: this.endpointAccess._config.publicAccess,\n      publicAccessCidrs: this.endpointAccess._config.publicCidrs,\n      secretsEncryptionKey: props.secretsEncryptionKey,\n      vpc: this.vpc,\n      subnets: placeClusterHandlerInVpc ? privateSubnets : undefined,\n      clusterHandlerSecurityGroup: this.clusterHandlerSecurityGroup,\n      onEventLayer: this.onEventLayer,\n      tags: props.tags,\n      logging: this.logging,\n    });\n\n    if (this.endpointAccess._config.privateAccess && privateSubnets.length !== 0) {\n\n      // when private access is enabled and the vpc has private subnets, lets connect\n      // the provider to the vpc so that it will work even when restricting public access.\n\n      // validate VPC properties according to: https://docs.aws.amazon.com/eks/latest/userguide/cluster-endpoint.html\n      if (this.vpc instanceof ec2.Vpc && !(this.vpc.dnsHostnamesEnabled && this.vpc.dnsSupportEnabled)) {\n        throw new Error('Private endpoint access requires the VPC to have DNS support and DNS hostnames enabled. Use `enableDnsHostnames: true` and `enableDnsSupport: true` when creating the VPC.');\n      }\n\n      this.kubectlPrivateSubnets = privateSubnets;\n\n      // the vpc must exist in order to properly delete the cluster (since we run `kubectl delete`).\n      // this ensures that.\n      this._clusterResource.node.addDependency(this.vpc);\n    }\n\n    this.adminRole = resource.adminRole;\n\n    // we use an SSM parameter as a barrier because it's free and fast.\n    this._kubectlReadyBarrier = new CfnResource(this, 'KubectlReadyBarrier', {\n      type: 'AWS::SSM::Parameter',\n      properties: {\n        Type: 'String',\n        Value: 'aws:cdk:eks:kubectl-ready',\n      },\n    });\n\n    // add the cluster resource itself as a dependency of the barrier\n    this._kubectlReadyBarrier.node.addDependency(this._clusterResource);\n\n    this.clusterName = this.getResourceNameAttribute(resource.ref);\n    this.clusterArn = this.getResourceArnAttribute(resource.attrArn, clusterArnComponents(this.physicalName));\n\n    this.clusterEndpoint = resource.attrEndpoint;\n    this.clusterCertificateAuthorityData = resource.attrCertificateAuthorityData;\n    this.clusterSecurityGroupId = resource.attrClusterSecurityGroupId;\n    this.clusterEncryptionConfigKeyArn = resource.attrEncryptionConfigKeyArn;\n\n    this.clusterSecurityGroup = ec2.SecurityGroup.fromSecurityGroupId(this, 'ClusterSecurityGroup', this.clusterSecurityGroupId);\n\n    this.connections = new ec2.Connections({\n      securityGroups: [this.clusterSecurityGroup, securityGroup],\n      defaultPort: ec2.Port.tcp(443), // Control Plane has an HTTPS API\n    });\n\n    // we can use the cluster security group since its already attached to the cluster\n    // and configured to allow connections from itself.\n    this.kubectlSecurityGroup = this.clusterSecurityGroup;\n\n    // use the cluster creation role to issue kubectl commands against the cluster because when the\n    // cluster is first created, that's the only role that has \"system:masters\" permissions\n    this.kubectlRole = this.adminRole;\n\n    this._kubectlResourceProvider = this.defineKubectlProvider();\n\n    const updateConfigCommandPrefix = `aws eks update-kubeconfig --name ${this.clusterName}`;\n    const getTokenCommandPrefix = `aws eks get-token --cluster-name ${this.clusterName}`;\n    const commonCommandOptions = [`--region ${stack.region}`];\n\n    if (props.outputClusterName) {\n      new CfnOutput(this, 'ClusterName', { value: this.clusterName });\n    }\n\n    // if an explicit role is not configured, define a masters role that can\n    // be assumed by anyone in the account (with sts:AssumeRole permissions of\n    // course)\n    const mastersRole = props.mastersRole ?? new iam.Role(this, 'MastersRole', {\n      assumedBy: new iam.AccountRootPrincipal(),\n    });\n\n    // map the IAM role to the `system:masters` group.\n    this.awsAuth.addMastersRole(mastersRole);\n\n    if (props.outputMastersRoleArn) {\n      new CfnOutput(this, 'MastersRoleArn', { value: mastersRole.roleArn });\n    }\n\n    commonCommandOptions.push(`--role-arn ${mastersRole.roleArn}`);\n\n    if (props.albController) {\n      this.albController = AlbController.create(this, { ...props.albController, cluster: this });\n    }\n\n    // allocate default capacity if non-zero (or default).\n    const minCapacity = props.defaultCapacity ?? DEFAULT_CAPACITY_COUNT;\n    if (minCapacity > 0) {\n      const instanceType = props.defaultCapacityInstance || DEFAULT_CAPACITY_TYPE;\n      this.defaultCapacity = props.defaultCapacityType === DefaultCapacityType.EC2 ?\n        this.addAutoScalingGroupCapacity('DefaultCapacity', { instanceType, minCapacity }) : undefined;\n\n      this.defaultNodegroup = props.defaultCapacityType !== DefaultCapacityType.EC2 ?\n        this.addNodegroupCapacity('DefaultCapacity', { instanceTypes: [instanceType], minSize: minCapacity }) : undefined;\n    }\n\n    const outputConfigCommand = props.outputConfigCommand ?? true;\n    if (outputConfigCommand) {\n      const postfix = commonCommandOptions.join(' ');\n      new CfnOutput(this, 'ConfigCommand', { value: `${updateConfigCommandPrefix} ${postfix}` });\n      new CfnOutput(this, 'GetTokenCommand', { value: `${getTokenCommandPrefix} ${postfix}` });\n    }\n\n    this.defineCoreDnsComputeType(props.coreDnsComputeType ?? CoreDnsComputeType.EC2);\n\n  }\n\n  /**\n   * Fetch the load balancer address of a service of type 'LoadBalancer'.\n   *\n   * @param serviceName The name of the service.\n   * @param options Additional operation options.\n   */\n  public getServiceLoadBalancerAddress(serviceName: string, options: ServiceLoadBalancerAddressOptions = {}): string {\n\n    const loadBalancerAddress = new KubernetesObjectValue(this, `${serviceName}LoadBalancerAddress`, {\n      cluster: this,\n      objectType: 'service',\n      objectName: serviceName,\n      objectNamespace: options.namespace,\n      jsonPath: '.status.loadBalancer.ingress[0].hostname',\n      timeout: options.timeout,\n    });\n\n    return loadBalancerAddress.value;\n\n  }\n\n  /**\n   * Fetch the load balancer address of an ingress backed by a load balancer.\n   *\n   * @param ingressName The name of the ingress.\n   * @param options Additional operation options.\n   */\n  public getIngressLoadBalancerAddress(ingressName: string, options: IngressLoadBalancerAddressOptions = {}): string {\n\n    const loadBalancerAddress = new KubernetesObjectValue(this, `${ingressName}LoadBalancerAddress`, {\n      cluster: this,\n      objectType: 'ingress',\n      objectName: ingressName,\n      objectNamespace: options.namespace,\n      jsonPath: '.status.loadBalancer.ingress[0].hostname',\n      timeout: options.timeout,\n    });\n\n    return loadBalancerAddress.value;\n\n  }\n\n  /**\n   * Add nodes to this EKS cluster\n   *\n   * The nodes will automatically be configured with the right VPC and AMI\n   * for the instance type and Kubernetes version.\n   *\n   * Note that if you specify `updateType: RollingUpdate` or `updateType: ReplacingUpdate`, your nodes might be replaced at deploy\n   * time without notice in case the recommended AMI for your machine image type has been updated by AWS.\n   * The default behavior for `updateType` is `None`, which means only new instances will be launched using the new AMI.\n   *\n   * Spot instances will be labeled `lifecycle=Ec2Spot` and tainted with `PreferNoSchedule`.\n   * In addition, the [spot interrupt handler](https://github.com/awslabs/ec2-spot-labs/tree/master/ec2-spot-eks-solution/spot-termination-handler)\n   * daemon will be installed on all spot instances to handle\n   * [EC2 Spot Instance Termination Notices](https://aws.amazon.com/blogs/aws/new-ec2-spot-instance-termination-notices/).\n   */\n  public addAutoScalingGroupCapacity(id: string, options: AutoScalingGroupCapacityOptions): autoscaling.AutoScalingGroup {\n    if (options.machineImageType === MachineImageType.BOTTLEROCKET && options.bootstrapOptions !== undefined) {\n      throw new Error('bootstrapOptions is not supported for Bottlerocket');\n    }\n    const asg = new autoscaling.AutoScalingGroup(this, id, {\n      ...options,\n      vpc: this.vpc,\n      machineImage: options.machineImageType === MachineImageType.BOTTLEROCKET ?\n        new BottleRocketImage({\n          kubernetesVersion: this.version.version,\n        }) :\n        new EksOptimizedImage({\n          nodeType: nodeTypeForInstanceType(options.instanceType),\n          cpuArch: cpuArchForInstanceType(options.instanceType),\n          kubernetesVersion: this.version.version,\n        }),\n    });\n\n    this.connectAutoScalingGroupCapacity(asg, {\n      mapRole: options.mapRole,\n      bootstrapOptions: options.bootstrapOptions,\n      bootstrapEnabled: options.bootstrapEnabled,\n      machineImageType: options.machineImageType,\n      spotInterruptHandler: options.spotInterruptHandler,\n    });\n\n    if (nodeTypeForInstanceType(options.instanceType) === NodeType.INFERENTIA) {\n      this.addNeuronDevicePlugin();\n    }\n\n    return asg;\n  }\n\n  /**\n   * Add managed nodegroup to this Amazon EKS cluster\n   *\n   * This method will create a new managed nodegroup and add into the capacity.\n   *\n   * @see https://docs.aws.amazon.com/eks/latest/userguide/managed-node-groups.html\n   * @param id The ID of the nodegroup\n   * @param options options for creating a new nodegroup\n   */\n  public addNodegroupCapacity(id: string, options?: NodegroupOptions): Nodegroup {\n    return new Nodegroup(this, `Nodegroup${id}`, {\n      cluster: this,\n      ...options,\n    });\n  }\n\n  /**\n   * Lazily creates the AwsAuth resource, which manages AWS authentication mapping.\n   */\n  public get awsAuth() {\n    if (!this._awsAuth) {\n      this._awsAuth = new AwsAuth(this, 'AwsAuth', { cluster: this });\n    }\n\n    return this._awsAuth;\n  }\n\n  /**\n   * If this cluster is kubectl-enabled, returns the OpenID Connect issuer url.\n   * This is because the values is only be retrieved by the API and not exposed\n   * by CloudFormation. If this cluster is not kubectl-enabled (i.e. uses the\n   * stock `CfnCluster`), this is `undefined`.\n   * @attribute\n   */\n  public get clusterOpenIdConnectIssuerUrl(): string {\n    return this._clusterResource.attrOpenIdConnectIssuerUrl;\n  }\n\n  /**\n   * If this cluster is kubectl-enabled, returns the OpenID Connect issuer.\n   * This is because the values is only be retrieved by the API and not exposed\n   * by CloudFormation. If this cluster is not kubectl-enabled (i.e. uses the\n   * stock `CfnCluster`), this is `undefined`.\n   * @attribute\n   */\n  public get clusterOpenIdConnectIssuer(): string {\n    return this._clusterResource.attrOpenIdConnectIssuer;\n  }\n\n  /**\n   * An `OpenIdConnectProvider` resource associated with this cluster, and which can be used\n   * to link this cluster to AWS IAM.\n   *\n   * A provider will only be defined if this property is accessed (lazy initialization).\n   */\n  public get openIdConnectProvider() {\n    if (!this._openIdConnectProvider) {\n      this._openIdConnectProvider = new OpenIdConnectProvider(this, 'OpenIdConnectProvider', {\n        url: this.clusterOpenIdConnectIssuerUrl,\n      });\n    }\n\n    return this._openIdConnectProvider;\n  }\n\n  /**\n   * Adds a Fargate profile to this cluster.\n   * @see https://docs.aws.amazon.com/eks/latest/userguide/fargate-profile.html\n   *\n   * @param id the id of this profile\n   * @param options profile options\n   */\n  public addFargateProfile(id: string, options: FargateProfileOptions) {\n    return new FargateProfile(this, `fargate-profile-${id}`, {\n      ...options,\n      cluster: this,\n    });\n  }\n\n  /**\n   * Internal API used by `FargateProfile` to keep inventory of Fargate profiles associated with\n   * this cluster, for the sake of ensuring the profiles are created sequentially.\n   *\n   * @returns the list of FargateProfiles attached to this cluster, including the one just attached.\n   * @internal\n   */\n  public _attachFargateProfile(fargateProfile: FargateProfile): FargateProfile[] {\n    this._fargateProfiles.push(fargateProfile);\n\n    // add all profiles as a dependency of the \"kubectl-ready\" barrier because all kubectl-\n    // resources can only be deployed after all fargate profiles are created.\n    this._kubectlReadyBarrier.node.addDependency(fargateProfile);\n\n    return this._fargateProfiles;\n  }\n\n  /**\n   * Adds a resource scope that requires `kubectl` to this cluster and returns\n   * the `KubectlProvider` which is the custom resource provider that should be\n   * used as the resource provider.\n   *\n   * Called from `HelmResource` and `KubernetesResource`\n   *\n   * @param resourceScope the construct scope in which kubectl resources are defined.\n   *\n   * @internal\n   */\n  public _attachKubectlResourceScope(resourceScope: Construct): KubectlProvider {\n    Node.of(resourceScope).addDependency(this._kubectlReadyBarrier);\n    return this._kubectlResourceProvider;\n  }\n\n  private defineKubectlProvider() {\n    const uid = '@aws-cdk/aws-eks.KubectlProvider';\n\n    // since we can't have the provider connect to multiple networks, and we\n    // wanted to avoid resource tear down, we decided for now that we will only\n    // support a single EKS cluster per CFN stack.\n    if (this.stack.node.tryFindChild(uid)) {\n      throw new Error('Only a single EKS cluster can be defined within a CloudFormation stack');\n    }\n\n    return new KubectlProvider(this.stack, uid, { cluster: this });\n  }\n\n  private selectPrivateSubnets(): ec2.ISubnet[] {\n    const privateSubnets: ec2.ISubnet[] = [];\n    const vpcPrivateSubnetIds = this.vpc.privateSubnets.map(s => s.subnetId);\n    const vpcPublicSubnetIds = this.vpc.publicSubnets.map(s => s.subnetId);\n\n    for (const placement of this.vpcSubnets) {\n\n      for (const subnet of this.vpc.selectSubnets(placement).subnets) {\n\n        if (vpcPrivateSubnetIds.includes(subnet.subnetId)) {\n          // definitely private, take it.\n          privateSubnets.push(subnet);\n          continue;\n        }\n\n        if (vpcPublicSubnetIds.includes(subnet.subnetId)) {\n          // definitely public, skip it.\n          continue;\n        }\n\n        // neither public and nor private - what is it then? this means its a subnet instance that was explicitly passed\n        // in the subnet selection. since ISubnet doesn't contain information on type, we have to assume its private and let it\n        // fail at deploy time :\\ (its better than filtering it out and preventing a possibly successful deployment)\n        privateSubnets.push(subnet);\n      }\n\n    }\n\n    return privateSubnets;\n  }\n\n  /**\n   * Installs the Neuron device plugin on the cluster if it's not\n   * already added.\n   */\n  private addNeuronDevicePlugin() {\n    if (!this._neuronDevicePlugin) {\n      const fileContents = fs.readFileSync(path.join(__dirname, 'addons/neuron-device-plugin.yaml'), 'utf8');\n      const sanitized = YAML.parse(fileContents);\n      this._neuronDevicePlugin = this.addManifest('NeuronDevicePlugin', sanitized);\n    }\n\n    return this._neuronDevicePlugin;\n  }\n\n  /**\n   * Opportunistically tag subnets with the required tags.\n   *\n   * If no subnets could be found (because this is an imported VPC), add a warning.\n   *\n   * @see https://docs.aws.amazon.com/eks/latest/userguide/network_reqs.html\n   */\n  private tagSubnets() {\n    const tagAllSubnets = (type: string, subnets: ec2.ISubnet[], tag: string) => {\n      for (const subnet of subnets) {\n        // if this is not a concrete subnet, attach a construct warning\n        if (!ec2.Subnet.isVpcSubnet(subnet)) {\n          // message (if token): \"could not auto-tag public/private subnet with tag...\"\n          // message (if not token): \"count not auto-tag public/private subnet xxxxx with tag...\"\n          const subnetID = Token.isUnresolved(subnet.subnetId) || Token.isUnresolved([subnet.subnetId]) ? '' : ` ${subnet.subnetId}`;\n          Annotations.of(this).addWarning(`Could not auto-tag ${type} subnet${subnetID} with \"${tag}=1\", please remember to do this manually`);\n          continue;\n        }\n\n        Tags.of(subnet).add(tag, '1');\n      }\n    };\n\n    // https://docs.aws.amazon.com/eks/latest/userguide/network_reqs.html\n    tagAllSubnets('private', this.vpc.privateSubnets, 'kubernetes.io/role/internal-elb');\n    tagAllSubnets('public', this.vpc.publicSubnets, 'kubernetes.io/role/elb');\n  }\n\n  /**\n   * Patches the CoreDNS deployment configuration and sets the \"eks.amazonaws.com/compute-type\"\n   * annotation to either \"ec2\" or \"fargate\". Note that if \"ec2\" is selected, the resource is\n   * omitted/removed, since the cluster is created with the \"ec2\" compute type by default.\n   */\n  private defineCoreDnsComputeType(type: CoreDnsComputeType) {\n    // ec2 is the \"built in\" compute type of the cluster so if this is the\n    // requested type we can simply omit the resource. since the resource's\n    // `restorePatch` is configured to restore the value to \"ec2\" this means\n    // that deletion of the resource will change to \"ec2\" as well.\n    if (type === CoreDnsComputeType.EC2) {\n      return;\n    }\n\n    // this is the json patch we merge into the resource based off of:\n    // https://docs.aws.amazon.com/eks/latest/userguide/fargate-getting-started.html#fargate-gs-coredns\n    const renderPatch = (computeType: CoreDnsComputeType) => ({\n      spec: {\n        template: {\n          metadata: {\n            annotations: {\n              'eks.amazonaws.com/compute-type': computeType,\n            },\n          },\n        },\n      },\n    });\n\n    new KubernetesPatch(this, 'CoreDnsComputeTypePatch', {\n      cluster: this,\n      resourceName: 'deployment/coredns',\n      resourceNamespace: 'kube-system',\n      applyPatch: renderPatch(CoreDnsComputeType.FARGATE),\n      restorePatch: renderPatch(CoreDnsComputeType.EC2),\n    });\n  }\n}\n\n/**\n * Options for adding worker nodes\n */\nexport interface AutoScalingGroupCapacityOptions extends autoscaling.CommonAutoScalingGroupProps {\n  /**\n   * Instance type of the instances to start\n   */\n  readonly instanceType: ec2.InstanceType;\n\n  /**\n   * Will automatically update the aws-auth ConfigMap to map the IAM instance\n   * role to RBAC.\n   *\n   * This cannot be explicitly set to `true` if the cluster has kubectl disabled.\n   *\n   * @default - true if the cluster has kubectl enabled (which is the default).\n   */\n  readonly mapRole?: boolean;\n\n  /**\n   * Configures the EC2 user-data script for instances in this autoscaling group\n   * to bootstrap the node (invoke `/etc/eks/bootstrap.sh`) and associate it\n   * with the EKS cluster.\n   *\n   * If you wish to provide a custom user data script, set this to `false` and\n   * manually invoke `autoscalingGroup.addUserData()`.\n   *\n   * @default true\n   */\n  readonly bootstrapEnabled?: boolean;\n\n  /**\n   * EKS node bootstrapping options.\n   *\n   * @default - none\n   */\n  readonly bootstrapOptions?: BootstrapOptions;\n\n  /**\n   * Machine image type\n   *\n   * @default MachineImageType.AMAZON_LINUX_2\n   */\n  readonly machineImageType?: MachineImageType;\n\n  /**\n   * Installs the AWS spot instance interrupt handler on the cluster if it's not\n   * already added. Only relevant if `spotPrice` is used.\n   *\n   * @default true\n   */\n  readonly spotInterruptHandler?: boolean;\n}\n\n/**\n * EKS node bootstrapping options.\n */\nexport interface BootstrapOptions {\n  /**\n   * Sets `--max-pods` for the kubelet based on the capacity of the EC2 instance.\n   *\n   * @default true\n   */\n  readonly useMaxPods?: boolean;\n\n  /**\n   * Restores the docker default bridge network.\n   *\n   * @default false\n   */\n  readonly enableDockerBridge?: boolean;\n\n  /**\n   * Number of retry attempts for AWS API call (DescribeCluster).\n   *\n   * @default 3\n   */\n  readonly awsApiRetryAttempts?: number;\n\n  /**\n   * The contents of the `/etc/docker/daemon.json` file. Useful if you want a\n   * custom config differing from the default one in the EKS AMI.\n   *\n   * @default - none\n   */\n  readonly dockerConfigJson?: string;\n\n  /**\n\n   * Overrides the IP address to use for DNS queries within the\n   * cluster.\n   *\n   * @default - 10.100.0.10 or 172.20.0.10 based on the IP\n   * address of the primary interface.\n   */\n  readonly dnsClusterIp?: string;\n\n  /**\n   * Extra arguments to add to the kubelet. Useful for adding labels or taints.\n   *\n   * For example, `--node-labels foo=bar,goo=far`.\n   *\n   * @default - none\n   */\n  readonly kubeletExtraArgs?: string;\n\n  /**\n   * Additional command line arguments to pass to the `/etc/eks/bootstrap.sh`\n   * command.\n   *\n   * @see https://github.com/awslabs/amazon-eks-ami/blob/master/files/bootstrap.sh\n   * @default - none\n   */\n  readonly additionalArgs?: string;\n}\n\n/**\n * Options for adding an AutoScalingGroup as capacity\n */\nexport interface AutoScalingGroupOptions {\n  /**\n   * Will automatically update the aws-auth ConfigMap to map the IAM instance\n   * role to RBAC.\n   *\n   * This cannot be explicitly set to `true` if the cluster has kubectl disabled.\n   *\n   * @default - true if the cluster has kubectl enabled (which is the default).\n   */\n  readonly mapRole?: boolean;\n\n  /**\n   * Configures the EC2 user-data script for instances in this autoscaling group\n   * to bootstrap the node (invoke `/etc/eks/bootstrap.sh`) and associate it\n   * with the EKS cluster.\n   *\n   * If you wish to provide a custom user data script, set this to `false` and\n   * manually invoke `autoscalingGroup.addUserData()`.\n   *\n   * @default true\n   */\n  readonly bootstrapEnabled?: boolean;\n\n  /**\n   * Allows options for node bootstrapping through EC2 user data.\n   * @default - default options\n   */\n  readonly bootstrapOptions?: BootstrapOptions;\n\n  /**\n   * Allow options to specify different machine image type\n   *\n   * @default MachineImageType.AMAZON_LINUX_2\n   */\n  readonly machineImageType?: MachineImageType;\n\n  /**\n   * Installs the AWS spot instance interrupt handler on the cluster if it's not\n   * already added. Only relevant if `spotPrice` is configured on the auto-scaling group.\n   *\n   * @default true\n   */\n  readonly spotInterruptHandler?: boolean;\n}\n\n/**\n * Import a cluster to use in another stack\n */\nclass ImportedCluster extends ClusterBase {\n  public readonly clusterName: string;\n  public readonly clusterArn: string;\n  public readonly connections = new ec2.Connections();\n  public readonly kubectlRole?: iam.IRole;\n  public readonly kubectlLambdaRole?: iam.IRole;\n  public readonly kubectlEnvironment?: { [key: string]: string; } | undefined;\n  public readonly kubectlSecurityGroup?: ec2.ISecurityGroup | undefined;\n  public readonly kubectlPrivateSubnets?: ec2.ISubnet[] | undefined;\n  public readonly kubectlLayer?: lambda.ILayerVersion;\n  public readonly kubectlProvider?: IKubectlProvider;\n  public readonly onEventLayer?: lambda.ILayerVersion;\n  public readonly kubectlMemory?: Size;\n  public readonly clusterHandlerSecurityGroup?: ec2.ISecurityGroup | undefined;\n  public readonly prune: boolean;\n\n  // so that `clusterSecurityGroup` on `ICluster` can be configured without optionality, avoiding users from having\n  // to null check on an instance of `Cluster`, which will always have this configured.\n  private readonly _clusterSecurityGroup?: ec2.ISecurityGroup;\n\n  constructor(scope: Construct, id: string, private readonly props: ClusterAttributes) {\n    super(scope, id);\n\n    this.clusterName = props.clusterName;\n    this.clusterArn = this.stack.formatArn(clusterArnComponents(props.clusterName));\n    this.kubectlRole = props.kubectlRoleArn ? iam.Role.fromRoleArn(this, 'KubectlRole', props.kubectlRoleArn) : undefined;\n    this.kubectlSecurityGroup = props.kubectlSecurityGroupId ? ec2.SecurityGroup.fromSecurityGroupId(this, 'KubectlSecurityGroup', props.kubectlSecurityGroupId) : undefined;\n    this.kubectlEnvironment = props.kubectlEnvironment;\n    this.kubectlPrivateSubnets = props.kubectlPrivateSubnetIds ? props.kubectlPrivateSubnetIds.map((subnetid, index) => ec2.Subnet.fromSubnetId(this, `KubectlSubnet${index}`, subnetid)) : undefined;\n    this.kubectlLayer = props.kubectlLayer;\n    this.kubectlMemory = props.kubectlMemory;\n    this.clusterHandlerSecurityGroup = props.clusterHandlerSecurityGroupId ? ec2.SecurityGroup.fromSecurityGroupId(this, 'ClusterHandlerSecurityGroup', props.clusterHandlerSecurityGroupId) : undefined;\n    this.kubectlProvider = props.kubectlProvider;\n    this.onEventLayer = props.onEventLayer;\n    this.prune = props.prune ?? true;\n\n    let i = 1;\n    for (const sgid of props.securityGroupIds ?? []) {\n      this.connections.addSecurityGroup(ec2.SecurityGroup.fromSecurityGroupId(this, `SecurityGroup${i}`, sgid));\n      i++;\n    }\n\n    if (props.clusterSecurityGroupId) {\n      this._clusterSecurityGroup = ec2.SecurityGroup.fromSecurityGroupId(this, 'ClusterSecurityGroup', this.clusterSecurityGroupId);\n      this.connections.addSecurityGroup(this._clusterSecurityGroup);\n    }\n  }\n\n  public get vpc() {\n    if (!this.props.vpc) {\n      throw new Error('\"vpc\" is not defined for this imported cluster');\n    }\n    return this.props.vpc;\n  }\n\n  public get clusterSecurityGroup(): ec2.ISecurityGroup {\n    if (!this._clusterSecurityGroup) {\n      throw new Error('\"clusterSecurityGroup\" is not defined for this imported cluster');\n    }\n    return this._clusterSecurityGroup;\n  }\n\n  public get clusterSecurityGroupId(): string {\n    if (!this.props.clusterSecurityGroupId) {\n      throw new Error('\"clusterSecurityGroupId\" is not defined for this imported cluster');\n    }\n    return this.props.clusterSecurityGroupId;\n  }\n\n  public get clusterEndpoint(): string {\n    if (!this.props.clusterEndpoint) {\n      throw new Error('\"clusterEndpoint\" is not defined for this imported cluster');\n    }\n    return this.props.clusterEndpoint;\n  }\n\n  public get clusterCertificateAuthorityData(): string {\n    if (!this.props.clusterCertificateAuthorityData) {\n      throw new Error('\"clusterCertificateAuthorityData\" is not defined for this imported cluster');\n    }\n    return this.props.clusterCertificateAuthorityData;\n  }\n\n  public get clusterEncryptionConfigKeyArn(): string {\n    if (!this.props.clusterEncryptionConfigKeyArn) {\n      throw new Error('\"clusterEncryptionConfigKeyArn\" is not defined for this imported cluster');\n    }\n    return this.props.clusterEncryptionConfigKeyArn;\n  }\n\n  public get openIdConnectProvider(): iam.IOpenIdConnectProvider {\n    if (!this.props.openIdConnectProvider) {\n      throw new Error('\"openIdConnectProvider\" is not defined for this imported cluster');\n    }\n    return this.props.openIdConnectProvider;\n  }\n\n  public get awsAuth(): AwsAuth {\n    throw new Error('\"awsAuth\" is not supported on imported clusters');\n  }\n}\n\n/**\n * Properties for EksOptimizedImage\n */\nexport interface EksOptimizedImageProps {\n  /**\n   * What instance type to retrieve the image for (standard or GPU-optimized)\n   *\n   * @default NodeType.STANDARD\n   */\n  readonly nodeType?: NodeType;\n\n  /**\n   * What cpu architecture to retrieve the image for (arm64 or x86_64)\n   *\n   * @default CpuArch.X86_64\n   */\n  readonly cpuArch?: CpuArch;\n\n  /**\n   * The Kubernetes version to use\n   *\n   * @default - The latest version\n   */\n  readonly kubernetesVersion?: string;\n}\n\n/**\n * Construct an Amazon Linux 2 image from the latest EKS Optimized AMI published in SSM\n */\nexport class EksOptimizedImage implements ec2.IMachineImage {\n  private readonly nodeType?: NodeType;\n  private readonly cpuArch?: CpuArch;\n  private readonly kubernetesVersion?: string;\n  private readonly amiParameterName: string;\n\n  /**\n   * Constructs a new instance of the EcsOptimizedAmi class.\n   */\n  public constructor(props: EksOptimizedImageProps = {}) {\n    this.nodeType = props.nodeType ?? NodeType.STANDARD;\n    this.cpuArch = props.cpuArch ?? CpuArch.X86_64;\n    this.kubernetesVersion = props.kubernetesVersion ?? LATEST_KUBERNETES_VERSION;\n\n    // set the SSM parameter name\n    this.amiParameterName = `/aws/service/eks/optimized-ami/${this.kubernetesVersion}/`\n      + (this.nodeType === NodeType.STANDARD ? this.cpuArch === CpuArch.X86_64 ?\n        'amazon-linux-2/' : 'amazon-linux-2-arm64/' : '')\n      + (this.nodeType === NodeType.GPU ? 'amazon-linux-2-gpu/' : '')\n      + (this.nodeType === NodeType.INFERENTIA ? 'amazon-linux-2-gpu/' : '')\n      + 'recommended/image_id';\n  }\n\n  /**\n   * Return the correct image\n   */\n  public getImage(scope: Construct): ec2.MachineImageConfig {\n    const ami = ssm.StringParameter.valueForStringParameter(scope, this.amiParameterName);\n    return {\n      imageId: ami,\n      osType: ec2.OperatingSystemType.LINUX,\n      userData: ec2.UserData.forLinux(),\n    };\n  }\n}\n\n// MAINTAINERS: use ./scripts/kube_bump.sh to update LATEST_KUBERNETES_VERSION\nconst LATEST_KUBERNETES_VERSION = '1.14';\n\n/**\n * Whether the worker nodes should support GPU or just standard instances\n */\nexport enum NodeType {\n  /**\n   * Standard instances\n   */\n  STANDARD = 'Standard',\n\n  /**\n   * GPU instances\n   */\n  GPU = 'GPU',\n\n  /**\n   * Inferentia instances\n   */\n  INFERENTIA = 'INFERENTIA',\n}\n\n/**\n * CPU architecture\n */\nexport enum CpuArch {\n  /**\n   * arm64 CPU type\n   */\n  ARM_64 = 'arm64',\n\n  /**\n   * x86_64 CPU type\n   */\n  X86_64 = 'x86_64',\n}\n\n/**\n * The type of compute resources to use for CoreDNS.\n */\nexport enum CoreDnsComputeType {\n  /**\n   * Deploy CoreDNS on EC2 instances.\n   */\n  EC2 = 'ec2',\n\n  /**\n   * Deploy CoreDNS on Fargate-managed instances.\n   */\n  FARGATE = 'fargate'\n}\n\n/**\n * The default capacity type for the cluster\n */\nexport enum DefaultCapacityType {\n  /**\n   * managed node group\n   */\n  NODEGROUP,\n  /**\n   * EC2 autoscaling group\n   */\n  EC2\n}\n\n/**\n * The machine image type\n */\nexport enum MachineImageType {\n  /**\n   * Amazon EKS-optimized Linux AMI\n   */\n  AMAZON_LINUX_2,\n  /**\n   * Bottlerocket AMI\n   */\n  BOTTLEROCKET\n}\n\nfunction nodeTypeForInstanceType(instanceType: ec2.InstanceType) {\n  return INSTANCE_TYPES.gpu.includes(instanceType.toString().substring(0, 2)) ? NodeType.GPU :\n    INSTANCE_TYPES.inferentia.includes(instanceType.toString().substring(0, 4)) ? NodeType.INFERENTIA :\n      NodeType.STANDARD;\n}\n\nfunction cpuArchForInstanceType(instanceType: ec2.InstanceType) {\n  return INSTANCE_TYPES.graviton2.includes(instanceType.toString().substring(0, 3)) ? CpuArch.ARM_64 :\n    INSTANCE_TYPES.graviton.includes(instanceType.toString().substring(0, 2)) ? CpuArch.ARM_64 :\n      CpuArch.X86_64;\n}\n\nfunction flatten<A>(xss: A[][]): A[] {\n  return Array.prototype.concat.call([], ...xss);\n}\n"],
  "mappings": "+aAAA,GAAA,QAAA,IAAA,EACA,KAAA,QAAA,MAAA,EACA,YAAA,QAAA,uBAAA,EACA,IAAA,QAAA,eAAA,EACA,IAAA,QAAA,eAAA,EAGA,IAAA,QAAA,eAAA,EACA,OAAA,QAAA,YAAA,EACA,aAAA,QAAA,YAAA,EACA,KAAA,QAAA,MAAA,EACA,iBAAA,QAAA,kBAAA,EACA,WAAA,QAAA,YAAA,EACA,mBAAA,QAAA,oBAAA,EACA,kBAAA,QAAA,mBAAA,EACA,aAAA,QAAA,cAAA,EACA,iBAAA,QAAA,kBAAA,EACA,eAAA,QAAA,gBAAA,EACA,mBAAA,QAAA,oBAAA,EACA,YAAA,QAAA,aAAA,EACA,mBAAA,QAAA,oBAAA,EACA,oBAAA,QAAA,qBAAA,EACA,gBAAA,QAAA,iBAAA,EACA,eAAA,QAAA,wBAAA,EACA,kBAAA,QAAA,mBAAA,EACA,YAAA,QAAA,aAAA,EAGM,uBAAyB,EACzB,sBAAwB,IAAI,aAAa,GAAG,IAAI,cAAc,GAAI,IAAI,aAAa,KAAK,EAsmB9F,MAAa,cAAc,CAkCzB,YAMkB,QAA6B,CAC7C,GADgB,KAAA,QAAA,QACZ,CAAC,QAAQ,cAAgB,QAAQ,aAAe,QAAQ,YAAY,OAAS,EAC/E,KAAM,IAAI,OAAM,kEAAkE,EAW/E,YAAY,KAAc,CAC/B,GAAI,CAAC,KAAK,QAAQ,cAGhB,KAAM,IAAI,OAAM,sHAAsH,EAExI,MAAO,IAAI,gBAAe,IACrB,KAAK,QAER,YAAa,KACd,GA/DL,QAAA,eAAA,oHAayB,eAAA,OAAS,GAAI,gBAAe,CAAE,cAAe,GAAO,aAAc,EAAI,CAAE,EAMxE,eAAA,QAAU,GAAI,gBAAe,CAAE,cAAe,GAAM,aAAc,EAAK,CAAE,EAazE,eAAA,mBAAqB,GAAI,gBAAe,CAAE,cAAe,GAAM,aAAc,EAAI,CAAE,EA4F5G,MAAa,iBAAiB,CA4D5B,YAAoC,QAAe,CAAf,KAAA,QAAA,cALtB,IAAG,QAAe,CAAI,MAAO,IAAI,mBAAkB,OAAO,CAAE,EAvD5E,QAAA,kBAAA,6HAKyB,kBAAA,MAAQ,kBAAkB,GAAG,MAAM,EAMnC,kBAAA,MAAQ,kBAAkB,GAAG,MAAM,EAMnC,kBAAA,MAAQ,kBAAkB,GAAG,MAAM,EAMnC,kBAAA,MAAQ,kBAAkB,GAAG,MAAM,EAMnC,kBAAA,MAAQ,kBAAkB,GAAG,MAAM,EAKnC,kBAAA,MAAQ,kBAAkB,GAAG,MAAM,EAKnC,kBAAA,MAAQ,kBAAkB,GAAG,MAAM,EAKnC,kBAAA,MAAQ,kBAAkB,GAAG,MAAM,EAKnC,kBAAA,MAAQ,kBAAkB,GAAG,MAAM,EAiB5D,GAAY,qBAAZ,AAAA,UAAY,qBAAmB,CAI7B,qBAAA,IAAA,MAIA,qBAAA,MAAA,QAIA,qBAAA,cAAA,gBAIA,qBAAA,mBAAA,oBAIA,qBAAA,UAAA,WACF,GArBY,oBAAA,QAAA,qBAAA,SAAA,oBAAmB,CAAA,EAAA,EAuB/B,MAAe,mBAAoB,QAAA,QAAQ,CAuClC,YAAY,MAAe,SAA+B,CAC/D,MAAO,IAAI,gBAAA,mBAAmB,KAAM,YAAY,KAAM,CAAE,QAAS,KAAM,QAAQ,CAAE,EAU5E,aAAa,GAAY,QAAyB,CACvD,MAAO,IAAI,cAAA,UAAU,KAAM,SAAS,KAAM,CAAE,QAAS,QAAS,OAAO,CAAE,EAUlE,cAAc,GAAY,MAAkB,QAAqC,CAAA,EAAE,CAExF,KAAM,YAAa,MAGnB,GAAI,MAAO,YAAW,QAAW,WAC/B,KAAM,IAAI,OAAM,kEAAkE,MAAO,YAAW,QAAQ,EAS9G,MANiB,IAAI,gBAAA,mBAAmB,KAAM,GAAI,CAChD,QAAS,KACT,SAAU,WAAW,OAAM,KACxB,QACJ,EAKI,kBAAkB,GAAY,QAAiC,CAAA,EAAE,CACtE,MAAO,IAAI,mBAAA,eAAe,KAAM,GAAI,IAC/B,QACH,QAAS,KACV,EAOK,yBAAuB,CAC7B,MAAK,MAAK,uBACR,MAAK,sBAAwB,KAAK,aAAa,yBAA0B,CACvE,MAAO,+BACP,QAAS,SACT,WAAY,mCACZ,UAAW,cACX,OAAQ,CACN,aAAc,CACZ,UAAW,YAAA,eAAe,OAG/B,GAGI,KAAK,sBAuBP,gCAAgC,iBAAgD,QAAgC,cAErH,iBAAiB,YAAY,gBAAgB,IAAI,KAAK,WAAU,CAAE,EAGlE,iBAAiB,YAAY,UAAU,KAAM,IAAI,KAAK,IAAI,GAAG,CAAC,EAC9D,iBAAiB,YAAY,UAAU,KAAM,IAAI,KAAK,SAAS,KAAM,KAAK,CAAC,EAG3E,iBAAiB,YAAY,QAAQ,KAAM,IAAI,KAAK,IAAI,GAAG,CAAC,EAG5D,iBAAiB,YAAY,eAAe,IAAI,KAAK,OAAM,CAAE,EAC7D,iBAAiB,YAAY,eAAe,IAAI,KAAK,OAAM,CAAE,EAC7D,iBAAiB,YAAY,eAAe,IAAI,KAAK,QAAO,CAAE,EAG9D,iBAAiB,iBAAiB,KAAK,oBAAoB,EAE3D,KAAM,kBAAgB,IAAG,QAAQ,oBAAgB,MAAA,KAAA,OAAA,GAAI,GACrD,GAAI,QAAQ,kBAAoB,CAAC,iBAC/B,KAAM,IAAI,OAAM,kEAAkE,EAGpF,GAAI,iBAAkB,CACpB,KAAM,UAAW,QAAQ,mBAAqB,iBAAiB,aAC7D,YAAA,2BAA2B,IAAI,EAC/B,YAAA,0BAA0B,KAAM,iBAAkB,QAAQ,gBAAgB,EAC5E,iBAAiB,YAAY,GAAG,QAAQ,EAG1C,iBAAiB,KAAK,iBAAiB,IAAI,cAAc,yBAAyB,2BAA2B,CAAC,EAC9G,iBAAiB,KAAK,iBAAiB,IAAI,cAAc,yBAAyB,sBAAsB,CAAC,EACzG,iBAAiB,KAAK,iBAAiB,IAAI,cAAc,yBAAyB,oCAAoC,CAAC,EAIvH,OAAA,KAAK,GAAG,gBAAgB,EAAE,IAAI,yBAAyB,KAAK,cAAe,QAAS,CAClF,yBAA0B,GAG1B,qBAAsB,CAAC,yBAAyB,EACjD,EAID,GAAI,SAAO,IAAG,QAAQ,WAAO,MAAA,KAAA,OAAA,GAAI,GACjC,AAAI,SAAW,CAAE,gBAAgB,WAE/B,QAAA,YAAY,GAAG,gBAAgB,EAAE,WAAW,4FAA4F,EACxI,QAAU,IAEZ,AAAI,QAEF,KAAK,QAAQ,eAAe,iBAAiB,KAAM,CACjD,SAAU,oCACV,OAAQ,CACN,uBACA,gBAEH,EAID,GAAI,QAAA,UAAU,iBAAkB,kBAAmB,CACjD,MAAO,iBAAiB,KAAK,QAC9B,EAGH,KAAM,yBAAuB,IAAG,QAAQ,wBAAoB,MAAA,KAAA,OAAA,GAAI,GAEhE,AAAI,iBAAiB,WAAa,yBAChC,KAAK,wBAAuB,EAG1B,eAAgB,UAAW,KAAK,eAGlC,aAAA,KAAK,GAAG,KAAK,aAAa,EAAE,cAAc,gBAAgB,GAqChE,MAAa,eAAgB,YAAW,CA4NtC,YAAY,MAAkB,GAAY,MAAmB,6BAC3D,MAAM,MAAO,GAAI,CACf,aAAc,MAAM,YACrB,EAxFc,KAAA,iBAAqC,CAAA,kEA0FpD,KAAM,OAAQ,OAAA,MAAM,GAAG,IAAI,EAE3B,KAAK,MAAK,IAAG,MAAM,SAAK,MAAA,KAAA,OAAA,GAAI,GAC5B,KAAK,IAAM,MAAM,KAAO,GAAI,KAAI,IAAI,KAAM,YAAY,EACtD,KAAK,QAAU,MAAM,QACrB,KAAK,kBAAoB,MAAM,kBAAoB,MAAM,kBAAoB,OAE7E,KAAK,WAAU,EAGf,KAAK,KAAO,MAAM,MAAQ,GAAI,KAAI,KAAK,KAAM,OAAQ,CACnD,UAAW,GAAI,KAAI,iBAAiB,mBAAmB,EACvD,gBAAiB,CACf,IAAI,cAAc,yBAAyB,wBAAwB,GAEtE,EAED,KAAM,eAAgB,MAAM,eAAiB,GAAI,KAAI,cAAc,KAAM,4BAA6B,CACpG,IAAK,KAAK,IACV,YAAa,mCACd,EAED,KAAK,WAAU,IAAG,MAAM,cAAU,MAAA,KAAA,OAAA,GAAI,CAAC,CAAE,WAAY,IAAI,WAAW,MAAM,EAAI,CAAE,WAAY,IAAI,WAAW,OAAO,CAAE,EAEpH,KAAM,2BAA4B,KAAK,WAAW,IAAI,GAAK,KAAK,IAAI,cAAc,CAAC,EAAE,SAAS,EAC9F,GAAI,0BAA0B,KAAK,OAAA,MAAM,YAAY,GAAK,0BAA0B,OAAS,EAC3F,KAAM,IAAI,OAAM,mMAAmM,EAIrN,KAAM,WAAY,MAAM,KAAK,GAAI,KAAI,QAAQ,yBAAyB,CAAC,CAAC,EAExE,KAAK,QAAU,MAAM,eAAiB,CACpC,eAAgB,CACd,CACE,QAAS,GACT,MAAO,OAAO,OAAO,MAAM,cAAc,KAG3C,OAEJ,KAAK,eAAc,IAAG,MAAM,kBAAc,MAAA,KAAA,OAAA,GAAI,eAAe,mBAC7D,KAAK,mBAAqB,MAAM,mBAChC,KAAK,aAAe,MAAM,aAC1B,KAAK,cAAgB,MAAM,cAE3B,KAAK,aAAe,MAAM,aAC1B,KAAK,4BAA8B,MAAM,4BAEzC,KAAM,gBAAiB,KAAK,qBAAoB,EAAG,MAAM,EAAG,EAAE,EACxD,qBAAuB,CAAC,KAAK,eAAe,QAAQ,aACpD,uBAAyB,CAAC,sBAC3B,KAAK,eAAe,QAAQ,aAC5B,KAAK,eAAe,QAAQ,YAAY,SAAW,EAIxD,GAAI,eAAe,SAAW,GAAK,qBAEjC,KAAM,IAAI,OAAM,0EAA0E,EAG5F,GAAI,eAAe,SAAW,GAAK,uBAEjC,KAAM,IAAI,OAAM,4EAA4E,EAG9F,KAAM,0BAAwB,IAAG,MAAM,4BAAwB,MAAA,KAAA,OAAA,GAAI,GAEnE,GAAI,0BAA4B,eAAe,SAAW,EACxD,KAAM,IAAI,OAAM,oFAAoF,EAGtG,GAAI,MAAM,6BAA+B,CAAC,yBACxC,KAAM,IAAI,OAAM,yFAAyF,EAG3G,KAAM,UAAW,KAAK,iBAAmB,GAAI,oBAAA,gBAAgB,KAAM,WAAY,CAC7E,KAAM,KAAK,aACX,YAAa,MAAM,0BACnB,QAAS,KAAK,KAAK,QACnB,QAAS,MAAM,QAAQ,QACvB,mBAAoB,CAClB,iBAAkB,CAAC,cAAc,eAAe,EAChD,cAEE,MAAM,qBAAuB,CAC/B,iBAAkB,CAAC,CACjB,SAAU,CACR,OAAQ,MAAM,qBAAqB,QAErC,UAAW,CAAC,SAAS,EACtB,GACC,CAAA,EACJ,wBAAyB,MAAM,gBAAkB,CAC/C,gBAAiB,MAAM,iBACrB,OACJ,sBAAuB,KAAK,eAAe,QAAQ,cACnD,qBAAsB,KAAK,eAAe,QAAQ,aAClD,kBAAmB,KAAK,eAAe,QAAQ,YAC/C,qBAAsB,MAAM,qBAC5B,IAAK,KAAK,IACV,QAAS,yBAA2B,eAAiB,OACrD,4BAA6B,KAAK,4BAClC,aAAc,KAAK,aACnB,KAAM,MAAM,KACZ,QAAS,KAAK,QACf,EAED,GAAI,KAAK,eAAe,QAAQ,eAAiB,eAAe,SAAW,EAAG,CAM5E,GAAI,KAAK,cAAe,KAAI,KAAO,CAAE,MAAK,IAAI,qBAAuB,KAAK,IAAI,mBAC5E,KAAM,IAAI,OAAM,4KAA4K,EAG9L,KAAK,sBAAwB,eAI7B,KAAK,iBAAiB,KAAK,cAAc,KAAK,GAAG,EAGnD,KAAK,UAAY,SAAS,UAG1B,KAAK,qBAAuB,GAAI,QAAA,YAAY,KAAM,sBAAuB,CACvE,KAAM,sBACN,WAAY,CACV,KAAM,SACN,MAAO,6BAEV,EAGD,KAAK,qBAAqB,KAAK,cAAc,KAAK,gBAAgB,EAElE,KAAK,YAAc,KAAK,yBAAyB,SAAS,GAAG,EAC7D,KAAK,WAAa,KAAK,wBAAwB,SAAS,QAAS,mBAAA,qBAAqB,KAAK,YAAY,CAAC,EAExG,KAAK,gBAAkB,SAAS,aAChC,KAAK,gCAAkC,SAAS,6BAChD,KAAK,uBAAyB,SAAS,2BACvC,KAAK,8BAAgC,SAAS,2BAE9C,KAAK,qBAAuB,IAAI,cAAc,oBAAoB,KAAM,uBAAwB,KAAK,sBAAsB,EAE3H,KAAK,YAAc,GAAI,KAAI,YAAY,CACrC,eAAgB,CAAC,KAAK,qBAAsB,aAAa,EACzD,YAAa,IAAI,KAAK,IAAI,GAAG,EAC9B,EAID,KAAK,qBAAuB,KAAK,qBAIjC,KAAK,YAAc,KAAK,UAExB,KAAK,yBAA2B,KAAK,sBAAqB,EAE1D,KAAM,2BAA4B,oCAAoC,KAAK,cACrE,sBAAwB,oCAAoC,KAAK,cACjE,qBAAuB,CAAC,YAAY,MAAM,QAAQ,EAExD,AAAI,MAAM,mBACR,GAAI,QAAA,UAAU,KAAM,cAAe,CAAE,MAAO,KAAK,WAAW,CAAE,EAMhE,KAAM,aAAW,IAAG,MAAM,eAAW,MAAA,KAAA,OAAA,GAAI,GAAI,KAAI,KAAK,KAAM,cAAe,CACzE,UAAW,GAAI,KAAI,qBACpB,EAGD,KAAK,QAAQ,eAAe,WAAW,EAEnC,MAAM,sBACR,GAAI,QAAA,UAAU,KAAM,iBAAkB,CAAE,MAAO,YAAY,OAAO,CAAE,EAGtE,qBAAqB,KAAK,cAAc,YAAY,SAAS,EAEzD,MAAM,eACR,MAAK,cAAgB,iBAAA,cAAc,OAAO,KAAM,IAAK,MAAM,cAAe,QAAS,IAAI,CAAE,GAI3F,KAAM,aAAW,IAAG,MAAM,mBAAe,MAAA,KAAA,OAAA,GAAI,uBAC7C,GAAI,YAAc,EAAG,CACnB,KAAM,cAAe,MAAM,yBAA2B,sBACtD,KAAK,gBAAkB,MAAM,sBAAwB,oBAAoB,IACvE,KAAK,4BAA4B,kBAAmB,CAAE,aAAc,WAAW,CAAE,EAAI,OAEvF,KAAK,iBAAmB,MAAM,sBAAwB,oBAAoB,IACxE,KAAK,qBAAqB,kBAAmB,CAAE,cAAe,CAAC,YAAY,EAAG,QAAS,WAAW,CAAE,EAAI,OAI5G,GADyB,IAAG,MAAM,uBAAmB,MAAA,KAAA,OAAA,GAAI,GAChC,CACvB,KAAM,SAAU,qBAAqB,KAAK,GAAG,EAC7C,GAAI,QAAA,UAAU,KAAM,gBAAiB,CAAE,MAAO,GAAG,6BAA6B,SAAS,CAAE,EACzF,GAAI,QAAA,UAAU,KAAM,kBAAmB,CAAE,MAAO,GAAG,yBAAyB,SAAS,CAAE,EAGzF,KAAK,yBAAwB,IAAC,MAAM,sBAAkB,MAAA,KAAA,OAAA,GAAI,mBAAmB,GAAG,QA5apE,uBAAsB,MAAkB,GAAY,MAAwB,6EACjF,GAAI,iBAAgB,MAAO,GAAI,KAAK,EAqbtC,8BAA8B,YAAqB,QAA6C,CAAA,EAAE,+FAWhG,AATqB,GAAI,oBAAA,sBAAsB,KAAM,GAAG,iCAAkC,CAC/F,QAAS,KACT,WAAY,UACZ,WAAY,YACZ,gBAAiB,QAAQ,UACzB,SAAU,2CACV,QAAS,QAAQ,QAClB,EAE0B,MAUtB,8BAA8B,YAAqB,QAA6C,CAAA,EAAE,+FAWhG,AATqB,GAAI,oBAAA,sBAAsB,KAAM,GAAG,iCAAkC,CAC/F,QAAS,KACT,WAAY,UACZ,WAAY,YACZ,gBAAiB,QAAQ,UACzB,SAAU,2CACV,QAAS,QAAQ,QAClB,EAE0B,MAmBtB,4BAA4B,GAAY,QAAwC,CACrF,wFAAI,QAAQ,mBAAqB,iBAAiB,cAAgB,QAAQ,mBAAqB,OAC7F,KAAM,IAAI,OAAM,oDAAoD,EAEtE,KAAM,KAAM,GAAI,aAAY,iBAAiB,KAAM,GAAI,IAClD,QACH,IAAK,KAAK,IACV,aAAc,QAAQ,mBAAqB,iBAAiB,aAC1D,GAAI,gBAAA,kBAAkB,CACpB,kBAAmB,KAAK,QAAQ,QACjC,EACD,GAAI,mBAAkB,CACpB,SAAU,wBAAwB,QAAQ,YAAY,EACtD,QAAS,uBAAuB,QAAQ,YAAY,EACpD,kBAAmB,KAAK,QAAQ,QACjC,EACJ,EAED,YAAK,gCAAgC,IAAK,CACxC,QAAS,QAAQ,QACjB,iBAAkB,QAAQ,iBAC1B,iBAAkB,QAAQ,iBAC1B,iBAAkB,QAAQ,iBAC1B,qBAAsB,QAAQ,qBAC/B,EAEG,wBAAwB,QAAQ,YAAY,IAAM,SAAS,YAC7D,KAAK,sBAAqB,EAGrB,IAYF,qBAAqB,GAAY,QAA0B,8EACzD,GAAI,qBAAA,UAAU,KAAM,YAAY,KAAM,CAC3C,QAAS,QACN,QACJ,KAMQ,UAAO,CAChB,MAAK,MAAK,UACR,MAAK,SAAW,GAAI,YAAA,QAAQ,KAAM,UAAW,CAAE,QAAS,IAAI,CAAE,GAGzD,KAAK,YAUH,gCAA6B,CACtC,MAAO,MAAK,iBAAiB,8BAUpB,6BAA0B,CACnC,MAAO,MAAK,iBAAiB,2BASpB,wBAAqB,CAC9B,MAAK,MAAK,wBACR,MAAK,uBAAyB,GAAI,iBAAA,sBAAsB,KAAM,wBAAyB,CACrF,IAAK,KAAK,8BACX,GAGI,KAAK,uBAUP,kBAAkB,GAAY,QAA8B,mFAC1D,GAAI,mBAAA,eAAe,KAAM,mBAAmB,KAAM,IACpD,QACH,QAAS,KACV,EAUI,sBAAsB,eAA8B,CACzD,YAAK,iBAAiB,KAAK,cAAc,EAIzC,KAAK,qBAAqB,KAAK,cAAc,cAAc,EAEpD,KAAK,iBAcP,4BAA4B,cAAwB,CACzD,oBAAA,KAAK,GAAG,aAAa,EAAE,cAAc,KAAK,oBAAoB,EACvD,KAAK,yBAGN,uBAAqB,CAC3B,KAAM,KAAM,mCAKZ,GAAI,KAAK,MAAM,KAAK,aAAa,GAAG,EAClC,KAAM,IAAI,OAAM,wEAAwE,EAG1F,MAAO,IAAI,oBAAA,gBAAgB,KAAK,MAAO,IAAK,CAAE,QAAS,IAAI,CAAE,EAGvD,sBAAoB,CAC1B,KAAM,gBAAgC,CAAA,EAChC,oBAAsB,KAAK,IAAI,eAAe,IAAI,GAAK,EAAE,QAAQ,EACjE,mBAAqB,KAAK,IAAI,cAAc,IAAI,GAAK,EAAE,QAAQ,EAErE,SAAW,aAAa,MAAK,WAE3B,SAAW,UAAU,MAAK,IAAI,cAAc,SAAS,EAAE,QAAS,CAE9D,GAAI,oBAAoB,SAAS,OAAO,QAAQ,EAAG,CAEjD,eAAe,KAAK,MAAM,EAC1B,SAGF,AAAI,mBAAmB,SAAS,OAAO,QAAQ,GAQ/C,eAAe,KAAK,MAAM,EAK9B,MAAO,gBAOD,uBAAqB,CAC3B,GAAI,CAAC,KAAK,oBAAqB,CAC7B,KAAM,cAAe,GAAG,aAAa,KAAK,KAAK,UAAW,kCAAkC,EAAG,MAAM,EAC/F,UAAY,KAAK,MAAM,YAAY,EACzC,KAAK,oBAAsB,KAAK,YAAY,qBAAsB,SAAS,EAG7E,MAAO,MAAK,oBAUN,YAAU,CAChB,KAAM,eAAgB,CAAC,KAAc,QAAwB,MAAe,CAC1E,SAAW,UAAU,SAAS,CAE5B,GAAI,CAAC,IAAI,OAAO,YAAY,MAAM,EAAG,CAGnC,KAAM,UAAW,OAAA,MAAM,aAAa,OAAO,QAAQ,GAAK,OAAA,MAAM,aAAa,CAAC,OAAO,QAAQ,CAAC,EAAI,GAAK,IAAI,OAAO,WAChH,OAAA,YAAY,GAAG,IAAI,EAAE,WAAW,sBAAsB,cAAc,kBAAkB,6CAA6C,EACnI,SAGF,OAAA,KAAK,GAAG,MAAM,EAAE,IAAI,IAAK,GAAG,EAEhC,EAGA,cAAc,UAAW,KAAK,IAAI,eAAgB,iCAAiC,EACnF,cAAc,SAAU,KAAK,IAAI,cAAe,wBAAwB,EAQlE,yBAAyB,KAAwB,CAKvD,GAAI,OAAS,mBAAmB,IAC9B,OAKF,KAAM,aAAc,AAAC,aAAqC,EACxD,KAAM,CACJ,SAAU,CACR,SAAU,CACR,YAAa,CACX,iCAAkC,kBAO5C,GAAI,aAAA,gBAAgB,KAAM,0BAA2B,CACnD,QAAS,KACT,aAAc,qBACd,kBAAmB,cACnB,WAAY,YAAY,mBAAmB,OAAO,EAClD,aAAc,YAAY,mBAAmB,GAAG,EACjD,GA1vBL,QAAA,QAAA,+FAq6BA,MAAM,uBAAwB,YAAW,CAoBvC,YAAY,MAAkB,GAA6B,MAAwB,WACjF,MAAM,MAAO,EAAE,EAD0C,KAAA,MAAA,MAjB3C,KAAA,YAAc,GAAI,KAAI,YAoBpC,KAAK,YAAc,MAAM,YACzB,KAAK,WAAa,KAAK,MAAM,UAAU,mBAAA,qBAAqB,MAAM,WAAW,CAAC,EAC9E,KAAK,YAAc,MAAM,eAAiB,IAAI,KAAK,YAAY,KAAM,cAAe,MAAM,cAAc,EAAI,OAC5G,KAAK,qBAAuB,MAAM,uBAAyB,IAAI,cAAc,oBAAoB,KAAM,uBAAwB,MAAM,sBAAsB,EAAI,OAC/J,KAAK,mBAAqB,MAAM,mBAChC,KAAK,sBAAwB,MAAM,wBAA0B,MAAM,wBAAwB,IAAI,CAAC,SAAU,QAAU,IAAI,OAAO,aAAa,KAAM,gBAAgB,QAAS,QAAQ,CAAC,EAAI,OACxL,KAAK,aAAe,MAAM,aAC1B,KAAK,cAAgB,MAAM,cAC3B,KAAK,4BAA8B,MAAM,8BAAgC,IAAI,cAAc,oBAAoB,KAAM,8BAA+B,MAAM,6BAA6B,EAAI,OAC3L,KAAK,gBAAkB,MAAM,gBAC7B,KAAK,aAAe,MAAM,aAC1B,KAAK,MAAK,IAAG,MAAM,SAAK,MAAA,KAAA,OAAA,GAAI,GAE5B,GAAI,GAAI,EACR,SAAW,QAAI,IAAI,MAAM,oBAAgB,MAAA,KAAA,OAAA,GAAI,CAAA,EAC3C,KAAK,YAAY,iBAAiB,IAAI,cAAc,oBAAoB,KAAM,gBAAgB,IAAK,IAAI,CAAC,EACxG,IAGF,AAAI,MAAM,wBACR,MAAK,sBAAwB,IAAI,cAAc,oBAAoB,KAAM,uBAAwB,KAAK,sBAAsB,EAC5H,KAAK,YAAY,iBAAiB,KAAK,qBAAqB,MAIrD,MAAG,CACZ,GAAI,CAAC,KAAK,MAAM,IACd,KAAM,IAAI,OAAM,gDAAgD,EAElE,MAAO,MAAK,MAAM,OAGT,uBAAoB,CAC7B,GAAI,CAAC,KAAK,sBACR,KAAM,IAAI,OAAM,iEAAiE,EAEnF,MAAO,MAAK,yBAGH,yBAAsB,CAC/B,GAAI,CAAC,KAAK,MAAM,uBACd,KAAM,IAAI,OAAM,mEAAmE,EAErF,MAAO,MAAK,MAAM,0BAGT,kBAAe,CACxB,GAAI,CAAC,KAAK,MAAM,gBACd,KAAM,IAAI,OAAM,4DAA4D,EAE9E,MAAO,MAAK,MAAM,mBAGT,kCAA+B,CACxC,GAAI,CAAC,KAAK,MAAM,gCACd,KAAM,IAAI,OAAM,4EAA4E,EAE9F,MAAO,MAAK,MAAM,mCAGT,gCAA6B,CACtC,GAAI,CAAC,KAAK,MAAM,8BACd,KAAM,IAAI,OAAM,0EAA0E,EAE5F,MAAO,MAAK,MAAM,iCAGT,wBAAqB,CAC9B,GAAI,CAAC,KAAK,MAAM,sBACd,KAAM,IAAI,OAAM,kEAAkE,EAEpF,MAAO,MAAK,MAAM,yBAGT,UAAO,CAChB,KAAM,IAAI,OAAM,iDAAiD,GAiCrE,MAAa,iBAAiB,CAS5B,YAAmB,MAAgC,CAAA,EAAE,wFACnD,KAAK,SAAQ,IAAG,MAAM,YAAQ,MAAA,KAAA,OAAA,GAAI,SAAS,SAC3C,KAAK,QAAO,IAAG,MAAM,WAAO,MAAA,KAAA,OAAA,GAAI,QAAQ,OACxC,KAAK,kBAAiB,IAAG,MAAM,qBAAiB,MAAA,KAAA,OAAA,GAAI,0BAGpD,KAAK,iBAAmB,kCAAkC,KAAK,qBAC1D,MAAK,WAAa,SAAS,SAAW,KAAK,UAAY,QAAQ,OAChE,kBAAoB,wBAA0B,IAC7C,MAAK,WAAa,SAAS,IAAM,sBAAwB,IACzD,MAAK,WAAa,SAAS,WAAa,sBAAwB,IACjE,uBAMC,SAAS,MAAgB,CAE9B,MAAO,CACL,QAFU,IAAI,gBAAgB,wBAAwB,MAAO,KAAK,gBAAgB,EAGlF,OAAQ,IAAI,oBAAoB,MAChC,SAAU,IAAI,SAAS,SAAQ,IA/BrC,QAAA,kBAAA,6HAqCA,KAAM,2BAA4B,OAKlC,GAAY,UAAZ,AAAA,UAAY,UAAQ,CAIlB,UAAA,SAAA,WAKA,UAAA,IAAA,MAKA,UAAA,WAAA,YACF,GAfY,SAAA,QAAA,UAAA,SAAA,SAAQ,CAAA,EAAA,EAoBpB,GAAY,SAAZ,AAAA,UAAY,SAAO,CAIjB,SAAA,OAAA,QAKA,SAAA,OAAA,QACF,GAVY,QAAA,QAAA,SAAA,SAAA,QAAO,CAAA,EAAA,EAenB,GAAY,oBAAZ,AAAA,UAAY,oBAAkB,CAI5B,oBAAA,IAAA,MAKA,oBAAA,QAAA,SACF,GAVY,mBAAA,QAAA,oBAAA,SAAA,mBAAkB,CAAA,EAAA,EAe9B,GAAY,qBAAZ,AAAA,UAAY,qBAAmB,CAI7B,qBAAA,qBAAA,UAAA,GAAA,YAIA,qBAAA,qBAAA,IAAA,GAAA,KACF,GATY,oBAAA,QAAA,qBAAA,SAAA,oBAAmB,CAAA,EAAA,EAc/B,GAAY,kBAAZ,AAAA,UAAY,kBAAgB,CAI1B,kBAAA,kBAAA,eAAA,GAAA,iBAIA,kBAAA,kBAAA,aAAA,GAAA,cACF,GATY,iBAAA,QAAA,kBAAA,SAAA,iBAAgB,CAAA,EAAA,EAW5B,iCAAiC,aAA8B,CAC7D,MAAO,kBAAA,eAAe,IAAI,SAAS,aAAa,SAAQ,EAAG,UAAU,EAAG,CAAC,CAAC,EAAI,SAAS,IACrF,iBAAA,eAAe,WAAW,SAAS,aAAa,SAAQ,EAAG,UAAU,EAAG,CAAC,CAAC,EAAI,SAAS,WACrF,SAAS,QACf,CAEA,gCAAgC,aAA8B,CAC5D,MAAO,kBAAA,eAAe,UAAU,SAAS,aAAa,SAAQ,EAAG,UAAU,EAAG,CAAC,CAAC,GAC9E,iBAAA,eAAe,SAAS,SAAS,aAAa,SAAQ,EAAG,UAAU,EAAG,CAAC,CAAC,EADU,QAAQ,OAExF,QAAQ,MACd,CAEA,iBAAoB,IAAU,CAC5B,MAAO,OAAM,UAAU,OAAO,KAAK,CAAA,EAAI,GAAG,GAAG,CAC/C",
  "names": []
}
