{
  "version": 3,
  "sources": ["aws-auth.ts"],
  "sourcesContent": ["import * as iam from '../../aws-iam';\nimport { Lazy, Stack } from '../../core';\nimport { Construct, IConstruct } from 'constructs';\nimport { AwsAuthMapping } from './aws-auth-mapping';\nimport { Cluster } from './cluster';\nimport { KubernetesManifest } from './k8s-manifest';\n\n/**\n * Configuration props for the AwsAuth construct.\n */\nexport interface AwsAuthProps {\n  /**\n   * The EKS cluster to apply this configuration to.\n   *\n   * [disable-awslint:ref-via-interface]\n   */\n  readonly cluster: Cluster;\n}\n\n/**\n * Manages mapping between IAM users and roles to Kubernetes RBAC configuration.\n *\n * @see https://docs.aws.amazon.com/en_us/eks/latest/userguide/add-user-role.html\n */\nexport class AwsAuth extends Construct {\n  private readonly stack: Stack;\n  private readonly roleMappings = new Array<{ role: iam.IRole, mapping: AwsAuthMapping }>();\n  private readonly userMappings = new Array<{ user: iam.IUser, mapping: AwsAuthMapping }>();\n  private readonly accounts = new Array<string>();\n\n  constructor(scope: Construct, id: string, props: AwsAuthProps) {\n    super(scope, id);\n\n    this.stack = Stack.of(this);\n\n    new KubernetesManifest(this, 'manifest', {\n      cluster: props.cluster,\n      overwrite: true, // this config map is auto-created by the cluster\n      manifest: [\n        {\n          apiVersion: 'v1',\n          kind: 'ConfigMap',\n          metadata: {\n            name: 'aws-auth',\n            namespace: 'kube-system',\n          },\n          data: {\n            mapRoles: this.synthesizeMapRoles(),\n            mapUsers: this.synthesizeMapUsers(),\n            mapAccounts: this.synthesizeMapAccounts(),\n          },\n        },\n      ],\n    });\n  }\n\n  /**\n   * Adds the specified IAM role to the `system:masters` RBAC group, which means\n   * that anyone that can assume it will be able to administer this Kubernetes system.\n   *\n   * @param role The IAM role to add\n   * @param username Optional user (defaults to the role ARN)\n   */\n  public addMastersRole(role: iam.IRole, username?: string) {\n    this.addRoleMapping(role, {\n      username,\n      groups: ['system:masters'],\n    });\n  }\n\n  /**\n   * Adds a mapping between an IAM role to a Kubernetes user and groups.\n   *\n   * @param role The IAM role to map\n   * @param mapping Mapping to k8s user name and groups\n   */\n  public addRoleMapping(role: iam.IRole, mapping: AwsAuthMapping) {\n    this.assertSameStack(role);\n    this.roleMappings.push({ role, mapping });\n  }\n\n  /**\n   * Adds a mapping between an IAM user to a Kubernetes user and groups.\n   *\n   * @param user The IAM user to map\n   * @param mapping Mapping to k8s user name and groups\n   */\n  public addUserMapping(user: iam.IUser, mapping: AwsAuthMapping) {\n    this.assertSameStack(user);\n    this.userMappings.push({ user, mapping });\n  }\n\n  /**\n   * Additional AWS account to add to the aws-auth configmap.\n   * @param accountId account number\n   */\n  public addAccount(accountId: string) {\n    this.accounts.push(accountId);\n  }\n\n  private assertSameStack(construct: IConstruct) {\n\n    const thisStack = Stack.of(this);\n\n    if (Stack.of(construct) !== thisStack) {\n      // aws-auth is always part of the cluster stack, and since resources commonly take\n      // a dependency on the cluster, allowing those resources to be in a different stack,\n      // will create a circular dependency. granted, it won't always be the case,\n      // but we opted for the more causious and restrictive approach for now.\n      throw new Error(`${construct.node.path} should be defined in the scope of the ${thisStack.stackName} stack to prevent circular dependencies`);\n    }\n  }\n\n  private synthesizeMapRoles() {\n    return Lazy.any({\n      produce: () => this.stack.toJsonString(this.roleMappings.map(m => ({\n        rolearn: m.role.roleArn,\n        username: m.mapping.username ?? m.role.roleArn,\n        groups: m.mapping.groups,\n      }))),\n    });\n  }\n\n  private synthesizeMapUsers() {\n    return Lazy.any({\n      produce: () => this.stack.toJsonString(this.userMappings.map(m => ({\n        userarn: m.user.userArn,\n        username: m.mapping.username ?? m.user.userArn,\n        groups: m.mapping.groups,\n      }))),\n    });\n  }\n\n  private synthesizeMapAccounts() {\n    return Lazy.any({\n      produce: () => this.stack.toJsonString(this.accounts),\n    });\n  }\n}\n"],
  "mappings": "8MACA,OAAA,QAAA,YAAA,EACA,aAAA,QAAA,YAAA,EAGA,eAAA,QAAA,gBAAA,EAmBA,MAAa,eAAgB,cAAA,SAAS,CAMpC,YAAY,MAAkB,GAAY,MAAmB,CAC3D,MAAM,MAAO,EAAE,EALA,KAAA,aAAe,GAAI,OACnB,KAAA,aAAe,GAAI,OACnB,KAAA,SAAW,GAAI,uEAK9B,KAAK,MAAQ,OAAA,MAAM,GAAG,IAAI,EAE1B,GAAI,gBAAA,mBAAmB,KAAM,WAAY,CACvC,QAAS,MAAM,QACf,UAAW,GACX,SAAU,CACR,CACE,WAAY,KACZ,KAAM,YACN,SAAU,CACR,KAAM,WACN,UAAW,eAEb,KAAM,CACJ,SAAU,KAAK,mBAAkB,EACjC,SAAU,KAAK,mBAAkB,EACjC,YAAa,KAAK,sBAAqB,KAI9C,EAUI,eAAe,KAAiB,SAAiB,yDACtD,KAAK,eAAe,KAAM,CACxB,SACA,OAAQ,CAAC,gBAAgB,EAC1B,EASI,eAAe,KAAiB,QAAuB,6HAC5D,KAAK,gBAAgB,IAAI,EACzB,KAAK,aAAa,KAAK,CAAE,KAAM,OAAO,CAAE,EASnC,eAAe,KAAiB,QAAuB,6HAC5D,KAAK,gBAAgB,IAAI,EACzB,KAAK,aAAa,KAAK,CAAE,KAAM,OAAO,CAAE,EAOnC,WAAW,UAAiB,CACjC,KAAK,SAAS,KAAK,SAAS,EAGtB,gBAAgB,UAAqB,CAE3C,KAAM,WAAY,OAAA,MAAM,GAAG,IAAI,EAE/B,GAAI,OAAA,MAAM,GAAG,SAAS,IAAM,UAK1B,KAAM,IAAI,OAAM,GAAG,UAAU,KAAK,8CAA8C,UAAU,kDAAkD,EAIxI,oBAAkB,CACxB,MAAO,QAAA,KAAK,IAAI,CACd,QAAS,IAAM,KAAK,MAAM,aAAa,KAAK,aAAa,IAAI,GAAI,QAAC,MAAC,CACjE,QAAS,EAAE,KAAK,QAChB,SAAQ,IAAE,EAAE,QAAQ,YAAQ,MAAA,KAAA,OAAA,GAAI,EAAE,KAAK,QACvC,OAAQ,EAAE,QAAQ,QAClB,CAAC,EACJ,EAGK,oBAAkB,CACxB,MAAO,QAAA,KAAK,IAAI,CACd,QAAS,IAAM,KAAK,MAAM,aAAa,KAAK,aAAa,IAAI,GAAI,QAAC,MAAC,CACjE,QAAS,EAAE,KAAK,QAChB,SAAQ,IAAE,EAAE,QAAQ,YAAQ,MAAA,KAAA,OAAA,GAAI,EAAE,KAAK,QACvC,OAAQ,EAAE,QAAQ,QAClB,CAAC,EACJ,EAGK,uBAAqB,CAC3B,MAAO,QAAA,KAAK,IAAI,CACd,QAAS,IAAM,KAAK,MAAM,aAAa,KAAK,QAAQ,EACrD,GAhHL,QAAA,QAAA",
  "names": []
}
