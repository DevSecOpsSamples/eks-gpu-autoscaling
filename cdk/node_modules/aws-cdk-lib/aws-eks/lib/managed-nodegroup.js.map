{
  "version": 3,
  "sources": ["managed-nodegroup.ts"],
  "sourcesContent": ["import { InstanceType, ISecurityGroup, SubnetSelection, InstanceArchitecture } from '../../aws-ec2';\nimport { IRole, ManagedPolicy, Role, ServicePrincipal } from '../../aws-iam';\nimport { IResource, Resource, Annotations, withResolved } from '../../core';\nimport { Construct, Node } from 'constructs';\nimport { Cluster, ICluster } from './cluster';\nimport { CfnNodegroup } from './eks.generated';\n\n/**\n * NodeGroup interface\n */\nexport interface INodegroup extends IResource {\n  /**\n   * Name of the nodegroup\n   * @attribute\n   */\n  readonly nodegroupName: string;\n}\n\n/**\n * The AMI type for your node group. GPU instance types should use the `AL2_x86_64_GPU` AMI type, which uses the\n * Amazon EKS-optimized Linux AMI with GPU support. Non-GPU instances should use the `AL2_x86_64` AMI type, which\n * uses the Amazon EKS-optimized Linux AMI.\n */\nexport enum NodegroupAmiType {\n  /**\n   * Amazon Linux 2 (x86-64)\n   */\n  AL2_X86_64 = 'AL2_x86_64',\n  /**\n   * Amazon Linux 2 with GPU support\n   */\n  AL2_X86_64_GPU = 'AL2_x86_64_GPU',\n  /**\n   * Amazon Linux 2 (ARM-64)\n   */\n  AL2_ARM_64 = 'AL2_ARM_64',\n  /**\n   *  Bottlerocket Linux(ARM-64)\n   */\n  BOTTLEROCKET_ARM_64 = 'BOTTLEROCKET_ARM_64',\n  /**\n   * Bottlerocket(x86-64)\n   */\n  BOTTLEROCKET_X86_64 = 'BOTTLEROCKET_x86_64',\n}\n\n/**\n * Capacity type of the managed node group\n */\nexport enum CapacityType {\n  /**\n   * spot instances\n   */\n  SPOT = 'SPOT',\n  /**\n   * on-demand instances\n   */\n  ON_DEMAND = 'ON_DEMAND'\n}\n\n/**\n * The remote access (SSH) configuration to use with your node group.\n *\n * @see https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-eks-nodegroup-remoteaccess.html\n */\nexport interface NodegroupRemoteAccess {\n  /**\n   * The Amazon EC2 SSH key that provides access for SSH communication with the worker nodes in the managed node group.\n   */\n  readonly sshKeyName: string;\n  /**\n   * The security groups that are allowed SSH access (port 22) to the worker nodes. If you specify an Amazon EC2 SSH\n   * key but do not specify a source security group when you create a managed node group, then port 22 on the worker\n   * nodes is opened to the internet (0.0.0.0/0).\n   *\n   * @default - port 22 on the worker nodes is opened to the internet (0.0.0.0/0)\n   */\n  readonly sourceSecurityGroups?: ISecurityGroup[];\n}\n\n/**\n * Launch template property specification\n */\nexport interface LaunchTemplateSpec {\n  /**\n   * The Launch template ID\n   */\n  readonly id: string;\n  /**\n   * The launch template version to be used (optional).\n   *\n   * @default - the default version of the launch template\n   */\n  readonly version?: string;\n}\n\n/**\n * Effect types of kubernetes node taint.\n */\nexport enum TaintEffect {\n  /**\n   * NoSchedule\n   */\n  NO_SCHEDULE = 'NO_SCHEDULE',\n  /**\n   * PreferNoSchedule\n   */\n  PREFER_NO_SCHEDULE = 'PREFER_NO_SCHEDULE',\n  /**\n   * NoExecute\n   */\n  NO_EXECUTE = 'NO_EXECUTE',\n}\n\n/**\n * Taint interface\n */\nexport interface TaintSpec {\n  /**\n   * Effect type\n   *\n   * @default - None\n   */\n  readonly effect?: TaintEffect;\n  /**\n   * Taint key\n   *\n   * @default - None\n   */\n  readonly key?: string;\n  /**\n   * Taint value\n   *\n   * @default - None\n   */\n  readonly value?: string;\n}\n\n/**\n * The Nodegroup Options for addNodeGroup() method\n */\nexport interface NodegroupOptions {\n  /**\n   * Name of the Nodegroup\n   *\n   * @default - resource ID\n   */\n  readonly nodegroupName?: string;\n  /**\n   * The subnets to use for the Auto Scaling group that is created for your node group. By specifying the\n   * SubnetSelection, the selected subnets will automatically apply required tags i.e.\n   * `kubernetes.io/cluster/CLUSTER_NAME` with a value of `shared`, where `CLUSTER_NAME` is replaced with\n   * the name of your cluster.\n   *\n   * @default - private subnets\n   */\n  readonly subnets?: SubnetSelection;\n  /**\n   * The AMI type for your node group. If you explicitly specify the launchTemplate with custom AMI, do not specify this property, or\n   * the node group deployment will fail. In other cases, you will need to specify correct amiType for the nodegroup.\n   *\n   * @default - auto-determined from the instanceTypes property when launchTemplateSpec property is not specified\n   */\n  readonly amiType?: NodegroupAmiType;\n  /**\n   * The root device disk size (in GiB) for your node group instances.\n   *\n   * @default 20\n   */\n  readonly diskSize?: number;\n  /**\n   * The current number of worker nodes that the managed node group should maintain. If not specified,\n   * the nodewgroup will initially create `minSize` instances.\n   *\n   * @default 2\n   */\n  readonly desiredSize?: number;\n  /**\n   * The maximum number of worker nodes that the managed node group can scale out to. Managed node groups can support up to 100 nodes by default.\n   *\n   * @default - desiredSize\n   */\n  readonly maxSize?: number;\n  /**\n   * The minimum number of worker nodes that the managed node group can scale in to. This number must be greater than or equal to zero.\n   *\n   * @default 1\n   */\n  readonly minSize?: number;\n  /**\n   * Force the update if the existing node group's pods are unable to be drained due to a pod disruption budget issue.\n   * If an update fails because pods could not be drained, you can force the update after it fails to terminate the old\n   * node whether or not any pods are\n   * running on the node.\n   *\n   * @default true\n   */\n  readonly forceUpdate?: boolean;\n  /**\n   * The instance type to use for your node group. Currently, you can specify a single instance type for a node group.\n   * The default value for this parameter is `t3.medium`. If you choose a GPU instance type, be sure to specify the\n   * `AL2_x86_64_GPU` with the amiType parameter.\n   *\n   * @default t3.medium\n   * @deprecated Use `instanceTypes` instead.\n   */\n  readonly instanceType?: InstanceType;\n  /**\n   * The instance types to use for your node group.\n   * @default t3.medium will be used according to the cloudformation document.\n   * @see - https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-eks-nodegroup.html#cfn-eks-nodegroup-instancetypes\n   */\n  readonly instanceTypes?: InstanceType[];\n  /**\n   * The Kubernetes labels to be applied to the nodes in the node group when they are created.\n   *\n   * @default - None\n   */\n  readonly labels?: { [name: string]: string };\n  /**\n   * The Kubernetes taints to be applied to the nodes in the node group when they are created.\n   *\n   * @default - None\n   */\n  readonly taints?: TaintSpec[];\n  /**\n   * The IAM role to associate with your node group. The Amazon EKS worker node kubelet daemon\n   * makes calls to AWS APIs on your behalf. Worker nodes receive permissions for these API calls through\n   * an IAM instance profile and associated policies. Before you can launch worker nodes and register them\n   * into a cluster, you must create an IAM role for those worker nodes to use when they are launched.\n   *\n   * @default - None. Auto-generated if not specified.\n   */\n  readonly nodeRole?: IRole;\n  /**\n   * The AMI version of the Amazon EKS-optimized AMI to use with your node group (for example, `1.14.7-YYYYMMDD`).\n   *\n   * @default - The latest available AMI version for the node group's current Kubernetes version is used.\n   */\n  readonly releaseVersion?: string;\n  /**\n   * The remote access (SSH) configuration to use with your node group. Disabled by default, however, if you\n   * specify an Amazon EC2 SSH key but do not specify a source security group when you create a managed node group,\n   * then port 22 on the worker nodes is opened to the internet (0.0.0.0/0)\n   *\n   * @default - disabled\n   */\n  readonly remoteAccess?: NodegroupRemoteAccess;\n  /**\n   * The metadata to apply to the node group to assist with categorization and organization. Each tag consists of\n   * a key and an optional value, both of which you define. Node group tags do not propagate to any other resources\n   * associated with the node group, such as the Amazon EC2 instances or subnets.\n   *\n   * @default - None\n   */\n  readonly tags?: { [name: string]: string };\n  /**\n   * Launch template specification used for the nodegroup\n   * @see - https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html\n   * @default - no launch template\n   */\n  readonly launchTemplateSpec?: LaunchTemplateSpec;\n  /**\n   * The capacity type of the nodegroup.\n   *\n   * @default - ON_DEMAND\n   */\n  readonly capacityType?: CapacityType;\n}\n\n/**\n * NodeGroup properties interface\n */\nexport interface NodegroupProps extends NodegroupOptions {\n  /**\n   * Cluster resource\n   */\n  readonly cluster: ICluster;\n}\n\n/**\n * The Nodegroup resource class\n */\nexport class Nodegroup extends Resource implements INodegroup {\n  /**\n   * Import the Nodegroup from attributes\n   */\n  public static fromNodegroupName(scope: Construct, id: string, nodegroupName: string): INodegroup {\n    class Import extends Resource implements INodegroup {\n      public readonly nodegroupName = nodegroupName;\n    }\n    return new Import(scope, id);\n  }\n  /**\n   * ARN of the nodegroup\n   *\n   * @attribute\n   */\n  public readonly nodegroupArn: string;\n  /**\n   * Nodegroup name\n   *\n   * @attribute\n   */\n  public readonly nodegroupName: string;\n  /**\n   * the Amazon EKS cluster resource\n   *\n   * @attribute ClusterName\n   */\n  public readonly cluster: ICluster;\n  /**\n   * IAM role of the instance profile for the nodegroup\n   */\n  public readonly role: IRole;\n\n  private readonly desiredSize: number;\n  private readonly maxSize: number;\n  private readonly minSize: number;\n\n  constructor(scope: Construct, id: string, props: NodegroupProps) {\n    super(scope, id, {\n      physicalName: props.nodegroupName,\n    });\n\n    this.cluster = props.cluster;\n\n    this.desiredSize = props.desiredSize ?? props.minSize ?? 2;\n    this.maxSize = props.maxSize ?? this.desiredSize;\n    this.minSize = props.minSize ?? 1;\n\n    withResolved(this.desiredSize, this.maxSize, (desired, max) => {\n      if (desired === undefined) {return ;}\n      if (desired > max) {\n        throw new Error(`Desired capacity ${desired} can't be greater than max size ${max}`);\n      }\n    });\n\n    withResolved(this.desiredSize, this.minSize, (desired, min) => {\n      if (desired === undefined) {return ;}\n      if (desired < min) {\n        throw new Error(`Minimum capacity ${min} can't be greater than desired size ${desired}`);\n      }\n    });\n\n    if (props.launchTemplateSpec && props.diskSize) {\n      // see - https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html\n      // and https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-eks-nodegroup.html#cfn-eks-nodegroup-disksize\n      throw new Error('diskSize must be specified within the launch template');\n    }\n\n    if (props.instanceType && props.instanceTypes) {\n      throw new Error('\"instanceType is deprecated, please use \"instanceTypes\" only.');\n    }\n\n    if (props.instanceType) {\n      Annotations.of(this).addWarning('\"instanceType\" is deprecated and will be removed in the next major version. please use \"instanceTypes\" instead');\n    }\n    const instanceTypes = props.instanceTypes ?? (props.instanceType ? [props.instanceType] : undefined);\n    let possibleAmiTypes: NodegroupAmiType[] = [];\n\n    if (instanceTypes && instanceTypes.length > 0) {\n      /**\n       * if the user explicitly configured instance types, we can't caculate the expected ami type as we support\n       * Amazon Linux 2 and Bottlerocket now. However we can check:\n       *\n       * 1. instance types of different CPU architectures are not mixed(e.g. X86 with ARM).\n       * 2. user-specified amiType should be included in `possibleAmiTypes`.\n       */\n      possibleAmiTypes = getPossibleAmiTypes(instanceTypes);\n\n      // if the user explicitly configured an ami type, make sure it's included in the possibleAmiTypes\n      if (props.amiType && !possibleAmiTypes.includes(props.amiType)) {\n        throw new Error(`The specified AMI does not match the instance types architecture, either specify one of ${possibleAmiTypes} or don't specify any`);\n      }\n    }\n\n    if (!props.nodeRole) {\n      const ngRole = new Role(this, 'NodeGroupRole', {\n        assumedBy: new ServicePrincipal('ec2.amazonaws.com'),\n      });\n\n      ngRole.addManagedPolicy(ManagedPolicy.fromAwsManagedPolicyName('AmazonEKSWorkerNodePolicy'));\n      ngRole.addManagedPolicy(ManagedPolicy.fromAwsManagedPolicyName('AmazonEKS_CNI_Policy'));\n      ngRole.addManagedPolicy(ManagedPolicy.fromAwsManagedPolicyName('AmazonEC2ContainerRegistryReadOnly'));\n      this.role = ngRole;\n    } else {\n      this.role = props.nodeRole;\n    }\n\n    const resource = new CfnNodegroup(this, 'Resource', {\n      clusterName: this.cluster.clusterName,\n      nodegroupName: props.nodegroupName,\n      nodeRole: this.role.roleArn,\n      subnets: this.cluster.vpc.selectSubnets(props.subnets).subnetIds,\n      /**\n       * Case 1: If launchTemplate is explicitly specified with custom AMI, we cannot specify amiType, or the node group deployment will fail.\n       * As we don't know if the custom AMI is specified in the lauchTemplate, we just use props.amiType.\n       *\n       * Case 2: If launchTemplate is not specified, we try to determine amiType from the instanceTypes and it could be either AL2 or Bottlerocket.\n       * To avoid breaking changes, we use possibleAmiTypes[0] if amiType is undefined and make sure AL2 is always the first element in possibleAmiTypes\n       * as AL2 is previously the `expectedAmi` and this avoids breaking changes.\n       *\n       * That being said, users now either have to explicitly specify correct amiType or just leave it undefined.\n       */\n      amiType: props.launchTemplateSpec ? props.amiType : (props.amiType ?? possibleAmiTypes[0]),\n      capacityType: props.capacityType ? props.capacityType.valueOf() : undefined,\n      diskSize: props.diskSize,\n      forceUpdateEnabled: props.forceUpdate ?? true,\n\n      // note that we don't check if a launch template is configured here (even though it might configure instance types as well)\n      // because this doesn't have a default value, meaning the user had to explicitly configure this.\n      instanceTypes: instanceTypes?.map(t => t.toString()),\n      labels: props.labels,\n      taints: props.taints,\n      launchTemplate: props.launchTemplateSpec,\n      releaseVersion: props.releaseVersion,\n      remoteAccess: props.remoteAccess ? {\n        ec2SshKey: props.remoteAccess.sshKeyName,\n        sourceSecurityGroups: props.remoteAccess.sourceSecurityGroups ?\n          props.remoteAccess.sourceSecurityGroups.map(m => m.securityGroupId) : undefined,\n      } : undefined,\n      scalingConfig: {\n        desiredSize: this.desiredSize,\n        maxSize: this.maxSize,\n        minSize: this.minSize,\n      },\n      tags: props.tags,\n    });\n\n    // managed nodegroups update the `aws-auth` on creation, but we still need to track\n    // its state for consistency.\n    if (this.cluster instanceof Cluster) {\n      // see https://docs.aws.amazon.com/en_us/eks/latest/userguide/add-user-role.html\n      this.cluster.awsAuth.addRoleMapping(this.role, {\n        username: 'system:node:{{EC2PrivateDNSName}}',\n        groups: [\n          'system:bootstrappers',\n          'system:nodes',\n        ],\n      });\n\n      // the controller runs on the worker nodes so they cannot\n      // be deleted before the controller.\n      if (this.cluster.albController) {\n        Node.of(this.cluster.albController).addDependency(this);\n      }\n    }\n\n    this.nodegroupArn = this.getResourceArnAttribute(resource.attrArn, {\n      service: 'eks',\n      resource: 'nodegroup',\n      resourceName: this.physicalName,\n    });\n    this.nodegroupName = this.getResourceNameAttribute(resource.ref);\n  }\n}\n\n/**\n * AMI types of different architectures. Make sure AL2 is always the first element, which will be the default\n * AmiType if amiType and launchTemplateSpec are both undefined.\n */\nconst arm64AmiTypes: NodegroupAmiType[] = [NodegroupAmiType.AL2_ARM_64, NodegroupAmiType.BOTTLEROCKET_ARM_64];\nconst x8664AmiTypes: NodegroupAmiType[] = [NodegroupAmiType.AL2_X86_64, NodegroupAmiType.BOTTLEROCKET_X86_64];\nconst gpuAmiTypes: NodegroupAmiType[] = [NodegroupAmiType.AL2_X86_64_GPU];\n\n\n/**\n * This function check if the instanceType is GPU instance.\n * @param instanceType The EC2 instance type\n */\nfunction isGpuInstanceType(instanceType: InstanceType): boolean {\n  // capture the family, generation, capabilities, and size portions of the instance type id\n  const instanceTypeComponents = instanceType.toString().match(/^([a-z]+)(\\d{1,2})([a-z]*)\\.([a-z0-9]+)$/);\n  if (instanceTypeComponents == null) {\n    throw new Error('Malformed instance type identifier');\n  }\n  const family = instanceTypeComponents[1];\n  return ['p', 'g', 'inf'].includes(family);\n}\n\ntype AmiArchitecture = InstanceArchitecture | 'GPU';\n/**\n * This function examines the CPU architecture of every instance type and determines\n * what AMI types are compatible for all of them. it either throws or produces an array of possible AMI types because\n * instance types of different CPU architectures are not supported.\n * @param instanceTypes The instance types\n * @returns NodegroupAmiType[]\n */\nfunction getPossibleAmiTypes(instanceTypes: InstanceType[]): NodegroupAmiType[] {\n  function typeToArch(instanceType: InstanceType): AmiArchitecture {\n    return isGpuInstanceType(instanceType) ? 'GPU' : instanceType.architecture;\n  }\n  const archAmiMap = new Map<AmiArchitecture, NodegroupAmiType[]>([\n    [InstanceArchitecture.ARM_64, arm64AmiTypes],\n    [InstanceArchitecture.X86_64, x8664AmiTypes],\n    ['GPU', gpuAmiTypes],\n  ]);\n  const architectures: Set<AmiArchitecture> = new Set(instanceTypes.map(typeToArch));\n\n  if (architectures.size === 0) { // protective code, the current implementation will never result in this.\n    throw new Error(`Cannot determine any ami type comptaible with instance types: ${instanceTypes.map(i => i.toString).join(',')}`);\n  }\n\n  if (architectures.size > 1) {\n    throw new Error('instanceTypes of different architectures is not allowed');\n  }\n\n  return archAmiMap.get(Array.from(architectures)[0])!;\n}\n"],
  "mappings": "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",
  "names": []
}
