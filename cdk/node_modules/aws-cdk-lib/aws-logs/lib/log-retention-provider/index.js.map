{
  "version": 3,
  "sources": ["index.ts"],
  "sourcesContent": ["/* eslint-disable no-console */\n\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport * as AWS from 'aws-sdk';\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport type { RetryDelayOptions } from 'aws-sdk/lib/config-base';\n\ninterface SdkRetryOptions {\n  maxRetries?: number;\n  retryOptions?: RetryDelayOptions;\n}\n\n/**\n * Creates a log group and doesn't throw if it exists.\n *\n * @param logGroupName the name of the log group to create.\n * @param region to create the log group in\n * @param options CloudWatch API SDK options.\n */\nasync function createLogGroupSafe(logGroupName: string, region?: string, options?: SdkRetryOptions) {\n  // If we set the log retention for a lambda, then due to the async nature of\n  // Lambda logging there could be a race condition when the same log group is\n  // already being created by the lambda execution. This can sometime result in\n  // an error \"OperationAbortedException: A conflicting operation is currently\n  // in progress...Please try again.\"\n  // To avoid an error, we do as requested and try again.\n  let retryCount = options?.maxRetries == undefined ? 10 : options.maxRetries;\n  const delay = options?.retryOptions?.base == undefined ? 10 : options.retryOptions.base;\n  do {\n    try {\n      const cloudwatchlogs = new AWS.CloudWatchLogs({ apiVersion: '2014-03-28', region, ...options });\n      await cloudwatchlogs.createLogGroup({ logGroupName }).promise();\n      return;\n    } catch (error) {\n      if (error.code === 'ResourceAlreadyExistsException') {\n        // The log group is already created by the lambda execution\n        return;\n      }\n      if (error.code === 'OperationAbortedException') {\n        if (retryCount > 0) {\n          retryCount--;\n          await new Promise(resolve => setTimeout(resolve, delay));\n          continue;\n        } else {\n          // The log group is still being created by another execution but we are out of retries\n          throw new Error('Out of attempts to create a logGroup');\n        }\n      }\n      throw error;\n    }\n  } while (true); // exit happens on retry count check\n}\n\n/**\n * Puts or deletes a retention policy on a log group.\n *\n * @param logGroupName the name of the log group to create\n * @param region the region of the log group\n * @param options CloudWatch API SDK options.\n * @param retentionInDays the number of days to retain the log events in the specified log group.\n */\nasync function setRetentionPolicy(logGroupName: string, region?: string, options?: SdkRetryOptions, retentionInDays?: number) {\n  // The same as in createLogGroupSafe(), here we could end up with the race\n  // condition where a log group is either already being created or its retention\n  // policy is being updated. This would result in an OperationAbortedException,\n  // which we will try to catch and retry the command a number of times before failing\n  let retryCount = options?.maxRetries == undefined ? 10 : options.maxRetries;\n  const delay = options?.retryOptions?.base == undefined ? 10 : options.retryOptions.base;\n  do {\n    try {\n      const cloudwatchlogs = new AWS.CloudWatchLogs({ apiVersion: '2014-03-28', region, ...options });\n      if (!retentionInDays) {\n        await cloudwatchlogs.deleteRetentionPolicy({ logGroupName }).promise();\n      } else {\n        await cloudwatchlogs.putRetentionPolicy({ logGroupName, retentionInDays }).promise();\n      }\n      return;\n\n    } catch (error) {\n      if (error.code === 'OperationAbortedException') {\n        if (retryCount > 0) {\n          retryCount--;\n          await new Promise(resolve => setTimeout(resolve, delay));\n          continue;\n        } else {\n          // The log group is still being created by another execution but we are out of retries\n          throw new Error('Out of attempts to create a logGroup');\n        }\n      }\n      throw error;\n    }\n  } while (true); // exit happens on retry count check\n}\n\nexport async function handler(event: AWSLambda.CloudFormationCustomResourceEvent, context: AWSLambda.Context) {\n  try {\n    console.log(JSON.stringify(event));\n\n    // The target log group\n    const logGroupName = event.ResourceProperties.LogGroupName;\n\n    // The region of the target log group\n    const logGroupRegion = event.ResourceProperties.LogGroupRegion;\n\n    // Parse to AWS SDK retry options\n    const retryOptions = parseRetryOptions(event.ResourceProperties.SdkRetry);\n\n    if (event.RequestType === 'Create' || event.RequestType === 'Update') {\n      // Act on the target log group\n      await createLogGroupSafe(logGroupName, logGroupRegion, retryOptions);\n      await setRetentionPolicy(logGroupName, logGroupRegion, retryOptions, parseInt(event.ResourceProperties.RetentionInDays, 10));\n\n      if (event.RequestType === 'Create') {\n        // Set a retention policy of 1 day on the logs of this very function.\n        // Due to the async nature of the log group creation, the log group for this function might\n        // still be not created yet at this point. Therefore we attempt to create it.\n        // In case it is being created, createLogGroupSafe will handle the conflict.\n        const region = process.env.AWS_REGION;\n        await createLogGroupSafe(`/aws/lambda/${context.functionName}`, region, retryOptions);\n        // If createLogGroupSafe fails, the log group is not created even after multiple attempts.\n        // In this case we have nothing to set the retention policy on but an exception will skip\n        // the next line.\n        await setRetentionPolicy(`/aws/lambda/${context.functionName}`, region, retryOptions, 1);\n      }\n    }\n\n    await respond('SUCCESS', 'OK', logGroupName);\n  } catch (e) {\n    console.log(e);\n\n    await respond('FAILED', e.message, event.ResourceProperties.LogGroupName);\n  }\n\n  function respond(responseStatus: string, reason: string, physicalResourceId: string) {\n    const responseBody = JSON.stringify({\n      Status: responseStatus,\n      Reason: reason,\n      PhysicalResourceId: physicalResourceId,\n      StackId: event.StackId,\n      RequestId: event.RequestId,\n      LogicalResourceId: event.LogicalResourceId,\n      Data: {\n        // Add log group name as part of the response so that it's available via Fn::GetAtt\n        LogGroupName: event.ResourceProperties.LogGroupName,\n      },\n    });\n\n    console.log('Responding', responseBody);\n\n    // eslint-disable-next-line @typescript-eslint/no-require-imports\n    const parsedUrl = require('url').parse(event.ResponseURL);\n    const requestOptions = {\n      hostname: parsedUrl.hostname,\n      path: parsedUrl.path,\n      method: 'PUT',\n      headers: { 'content-type': '', 'content-length': responseBody.length },\n    };\n\n    return new Promise((resolve, reject) => {\n      try {\n        // eslint-disable-next-line @typescript-eslint/no-require-imports\n        const request = require('https').request(requestOptions, resolve);\n        request.on('error', reject);\n        request.write(responseBody);\n        request.end();\n      } catch (e) {\n        reject(e);\n      }\n    });\n  }\n\n  function parseRetryOptions(rawOptions: any): SdkRetryOptions {\n    const retryOptions: SdkRetryOptions = {};\n    if (rawOptions) {\n      if (rawOptions.maxRetries) {\n        retryOptions.maxRetries = parseInt(rawOptions.maxRetries, 10);\n      }\n      if (rawOptions.base) {\n        retryOptions.retryOptions = {\n          base: parseInt(rawOptions.base, 10),\n        };\n      }\n    }\n    return retryOptions;\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
