{
  "version": 3,
  "sources": ["log-group.ts"],
  "sourcesContent": ["import * as cloudwatch from '../../aws-cloudwatch';\nimport * as iam from '../../aws-iam';\nimport * as kms from '../../aws-kms';\nimport { Arn, ArnFormat, RemovalPolicy, Resource, Stack, Token } from '../../core';\nimport { Construct } from 'constructs';\nimport { LogStream } from './log-stream';\nimport { CfnLogGroup } from './logs.generated';\nimport { MetricFilter } from './metric-filter';\nimport { FilterPattern, IFilterPattern } from './pattern';\nimport { ResourcePolicy } from './policy';\nimport { ILogSubscriptionDestination, SubscriptionFilter } from './subscription-filter';\n\nexport interface ILogGroup extends iam.IResourceWithPolicy {\n  /**\n   * The ARN of this log group, with ':*' appended\n   *\n   * @attribute\n   */\n  readonly logGroupArn: string;\n\n  /**\n   * The name of this log group\n   * @attribute\n   */\n  readonly logGroupName: string;\n\n  /**\n   * Create a new Log Stream for this Log Group\n   *\n   * @param id Unique identifier for the construct in its parent\n   * @param props Properties for creating the LogStream\n   */\n  addStream(id: string, props?: StreamOptions): LogStream;\n\n  /**\n   * Create a new Subscription Filter on this Log Group\n   *\n   * @param id Unique identifier for the construct in its parent\n   * @param props Properties for creating the SubscriptionFilter\n   */\n  addSubscriptionFilter(id: string, props: SubscriptionFilterOptions): SubscriptionFilter;\n\n  /**\n   * Create a new Metric Filter on this Log Group\n   *\n   * @param id Unique identifier for the construct in its parent\n   * @param props Properties for creating the MetricFilter\n   */\n  addMetricFilter(id: string, props: MetricFilterOptions): MetricFilter;\n\n  /**\n   * Extract a metric from structured log events in the LogGroup\n   *\n   * Creates a MetricFilter on this LogGroup that will extract the value\n   * of the indicated JSON field in all records where it occurs.\n   *\n   * The metric will be available in CloudWatch Metrics under the\n   * indicated namespace and name.\n   *\n   * @param jsonField JSON field to extract (example: '$.myfield')\n   * @param metricNamespace Namespace to emit the metric under\n   * @param metricName Name to emit the metric under\n   * @returns A Metric object representing the extracted metric\n   */\n  extractMetric(jsonField: string, metricNamespace: string, metricName: string): cloudwatch.Metric;\n\n  /**\n   * Give permissions to write to create and write to streams in this log group\n   */\n  grantWrite(grantee: iam.IGrantable): iam.Grant;\n\n  /**\n   * Give the indicated permissions on this log group and all streams\n   */\n  grant(grantee: iam.IGrantable, ...actions: string[]): iam.Grant;\n\n  /**\n   * Public method to get the physical name of this log group\n   */\n  logGroupPhysicalName(): string;\n}\n\n/**\n * An CloudWatch Log Group\n */\nabstract class LogGroupBase extends Resource implements ILogGroup {\n  /**\n   * The ARN of this log group, with ':*' appended\n   */\n  public abstract readonly logGroupArn: string;\n\n  /**\n   * The name of this log group\n   */\n  public abstract readonly logGroupName: string;\n\n\n  private policy?: ResourcePolicy;\n\n  /**\n   * Create a new Log Stream for this Log Group\n   *\n   * @param id Unique identifier for the construct in its parent\n   * @param props Properties for creating the LogStream\n   */\n  public addStream(id: string, props: StreamOptions = {}): LogStream {\n    return new LogStream(this, id, {\n      logGroup: this,\n      ...props,\n    });\n  }\n\n  /**\n   * Create a new Subscription Filter on this Log Group\n   *\n   * @param id Unique identifier for the construct in its parent\n   * @param props Properties for creating the SubscriptionFilter\n   */\n  public addSubscriptionFilter(id: string, props: SubscriptionFilterOptions): SubscriptionFilter {\n    return new SubscriptionFilter(this, id, {\n      logGroup: this,\n      ...props,\n    });\n  }\n\n  /**\n   * Create a new Metric Filter on this Log Group\n   *\n   * @param id Unique identifier for the construct in its parent\n   * @param props Properties for creating the MetricFilter\n   */\n  public addMetricFilter(id: string, props: MetricFilterOptions): MetricFilter {\n    return new MetricFilter(this, id, {\n      logGroup: this,\n      ...props,\n    });\n  }\n\n  /**\n   * Extract a metric from structured log events in the LogGroup\n   *\n   * Creates a MetricFilter on this LogGroup that will extract the value\n   * of the indicated JSON field in all records where it occurs.\n   *\n   * The metric will be available in CloudWatch Metrics under the\n   * indicated namespace and name.\n   *\n   * @param jsonField JSON field to extract (example: '$.myfield')\n   * @param metricNamespace Namespace to emit the metric under\n   * @param metricName Name to emit the metric under\n   * @returns A Metric object representing the extracted metric\n   */\n  public extractMetric(jsonField: string, metricNamespace: string, metricName: string) {\n    new MetricFilter(this, `${metricNamespace}_${metricName}`, {\n      logGroup: this,\n      metricNamespace,\n      metricName,\n      filterPattern: FilterPattern.exists(jsonField),\n      metricValue: jsonField,\n    });\n\n    return new cloudwatch.Metric({ metricName, namespace: metricNamespace }).attachTo(this);\n  }\n\n  /**\n   * Give permissions to create and write to streams in this log group\n   */\n  public grantWrite(grantee: iam.IGrantable) {\n    return this.grant(grantee, 'logs:CreateLogStream', 'logs:PutLogEvents');\n  }\n\n  /**\n   * Give the indicated permissions on this log group and all streams\n   */\n  public grant(grantee: iam.IGrantable, ...actions: string[]) {\n    return iam.Grant.addToPrincipalOrResource({\n      grantee,\n      actions,\n      // A LogGroup ARN out of CloudFormation already includes a ':*' at the end to include the log streams under the group.\n      // See https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-logs-loggroup.html#w2ab1c21c10c63c43c11\n      resourceArns: [this.logGroupArn],\n      resource: this,\n    });\n  }\n\n  /**\n   * Public method to get the physical name of this log group\n   * @returns Physical name of log group\n   */\n  public logGroupPhysicalName(): string {\n    return this.physicalName;\n  }\n\n  /**\n   * Adds a statement to the resource policy associated with this log group.\n   * A resource policy will be automatically created upon the first call to `addToResourcePolicy`.\n   *\n   * Any ARN Principals inside of the statement will be converted into AWS Account ID strings\n   * because CloudWatch Logs Resource Policies do not accept ARN principals.\n   *\n   * @param statement The policy statement to add\n   */\n  public addToResourcePolicy(statement: iam.PolicyStatement): iam.AddToResourcePolicyResult {\n    if (!this.policy) {\n      this.policy = new ResourcePolicy(this, 'Policy');\n    }\n    this.policy.document.addStatements(statement.copy({\n      principals: statement.principals.map(p => this.convertArnPrincpalToAccountId(p)),\n    }));\n    return { statementAdded: true, policyDependable: this.policy };\n  }\n\n  private convertArnPrincpalToAccountId(principal: iam.IPrincipal) {\n    if (principal.principalAccount) {\n      // we use ArnPrincipal here because the constructor inserts the argument\n      // into the template without mutating it, which means that there is no\n      // ARN created by this call.\n      return new iam.ArnPrincipal(principal.principalAccount);\n    }\n\n    if (principal instanceof iam.ArnPrincipal) {\n      const parsedArn = Arn.split(principal.arn, ArnFormat.SLASH_RESOURCE_NAME);\n      if (parsedArn.account) {\n        return new iam.ArnPrincipal(parsedArn.account);\n      }\n    }\n\n    return principal;\n  }\n}\n\n/**\n * How long, in days, the log contents will be retained.\n */\nexport enum RetentionDays {\n  /**\n   * 1 day\n   */\n  ONE_DAY = 1,\n\n  /**\n   * 3 days\n   */\n  THREE_DAYS = 3,\n\n  /**\n   * 5 days\n   */\n  FIVE_DAYS = 5,\n\n  /**\n   * 1 week\n   */\n  ONE_WEEK = 7,\n\n  /**\n   * 2 weeks\n   */\n  TWO_WEEKS = 14,\n\n  /**\n   * 1 month\n   */\n  ONE_MONTH = 30,\n\n  /**\n   * 2 months\n   */\n  TWO_MONTHS = 60,\n\n  /**\n   * 3 months\n   */\n  THREE_MONTHS = 90,\n\n  /**\n   * 4 months\n   */\n  FOUR_MONTHS = 120,\n\n  /**\n   * 5 months\n   */\n  FIVE_MONTHS = 150,\n\n  /**\n   * 6 months\n   */\n  SIX_MONTHS = 180,\n\n  /**\n   * 1 year\n   */\n  ONE_YEAR = 365,\n\n  /**\n   * 13 months\n   */\n  THIRTEEN_MONTHS = 400,\n\n  /**\n   * 18 months\n   */\n  EIGHTEEN_MONTHS = 545,\n\n  /**\n   * 2 years\n   */\n  TWO_YEARS = 731,\n\n  /**\n   * 5 years\n   */\n  FIVE_YEARS = 1827,\n\n  /**\n   * 10 years\n   */\n  TEN_YEARS = 3653,\n\n  /**\n   * Retain logs forever\n   */\n  INFINITE = 9999,\n}\n\n/**\n * Properties for a LogGroup\n */\nexport interface LogGroupProps {\n  /**\n   * The KMS Key to encrypt the log group with.\n   *\n   * @default - log group is encrypted with the default master key\n   */\n  readonly encryptionKey?: kms.IKey;\n\n  /**\n   * Name of the log group.\n   *\n   * @default Automatically generated\n   */\n  readonly logGroupName?: string;\n\n  /**\n   * How long, in days, the log contents will be retained.\n   *\n   * To retain all logs, set this value to RetentionDays.INFINITE.\n   *\n   * @default RetentionDays.TWO_YEARS\n   */\n  readonly retention?: RetentionDays;\n\n  /**\n   * Determine the removal policy of this log group.\n   *\n   * Normally you want to retain the log group so you can diagnose issues\n   * from logs even after a deployment that no longer includes the log group.\n   * In that case, use the normal date-based retention policy to age out your\n   * logs.\n   *\n   * @default RemovalPolicy.Retain\n   */\n  readonly removalPolicy?: RemovalPolicy;\n}\n\n/**\n * Define a CloudWatch Log Group\n */\nexport class LogGroup extends LogGroupBase {\n  /**\n   * Import an existing LogGroup given its ARN\n   */\n  public static fromLogGroupArn(scope: Construct, id: string, logGroupArn: string): ILogGroup {\n    const baseLogGroupArn = logGroupArn.replace(/:\\*$/, '');\n\n    class Import extends LogGroupBase {\n      public readonly logGroupArn = `${baseLogGroupArn}:*`;\n      public readonly logGroupName = Stack.of(scope).splitArn(baseLogGroupArn, ArnFormat.COLON_RESOURCE_NAME).resourceName!;\n    }\n\n    return new Import(scope, id, {\n      environmentFromArn: baseLogGroupArn,\n    });\n  }\n\n  /**\n   * Import an existing LogGroup given its name\n   */\n  public static fromLogGroupName(scope: Construct, id: string, logGroupName: string): ILogGroup {\n    const baseLogGroupName = logGroupName.replace(/:\\*$/, '');\n\n    class Import extends LogGroupBase {\n      public readonly logGroupName = baseLogGroupName;\n      public readonly logGroupArn = Stack.of(scope).formatArn({\n        service: 'logs',\n        resource: 'log-group',\n        arnFormat: ArnFormat.COLON_RESOURCE_NAME,\n        resourceName: baseLogGroupName + ':*',\n      });\n    }\n\n    return new Import(scope, id);\n  }\n\n  /**\n   * The ARN of this log group\n   */\n  public readonly logGroupArn: string;\n\n  /**\n   * The name of this log group\n   */\n  public readonly logGroupName: string;\n\n  constructor(scope: Construct, id: string, props: LogGroupProps = {}) {\n    super(scope, id, {\n      physicalName: props.logGroupName,\n    });\n\n    let retentionInDays = props.retention;\n    if (retentionInDays === undefined) { retentionInDays = RetentionDays.TWO_YEARS; }\n    if (retentionInDays === Infinity || retentionInDays === RetentionDays.INFINITE) { retentionInDays = undefined; }\n\n    if (retentionInDays !== undefined && !Token.isUnresolved(retentionInDays) && retentionInDays <= 0) {\n      throw new Error(`retentionInDays must be positive, got ${retentionInDays}`);\n    }\n\n    const resource = new CfnLogGroup(this, 'Resource', {\n      kmsKeyId: props.encryptionKey?.keyArn,\n      logGroupName: this.physicalName,\n      retentionInDays,\n    });\n\n    resource.applyRemovalPolicy(props.removalPolicy);\n\n    this.logGroupArn = this.getResourceArnAttribute(resource.attrArn, {\n      service: 'logs',\n      resource: 'log-group',\n      resourceName: this.physicalName,\n      arnFormat: ArnFormat.COLON_RESOURCE_NAME,\n    });\n    this.logGroupName = this.getResourceNameAttribute(resource.ref);\n  }\n}\n\n/**\n * Properties for a new LogStream created from a LogGroup\n */\nexport interface StreamOptions {\n  /**\n   * The name of the log stream to create.\n   *\n   * The name must be unique within the log group.\n   *\n   * @default Automatically generated\n   */\n  readonly logStreamName?: string;\n}\n\n/**\n * Properties for a new SubscriptionFilter created from a LogGroup\n */\nexport interface SubscriptionFilterOptions {\n  /**\n   * The destination to send the filtered events to.\n   *\n   * For example, a Kinesis stream or a Lambda function.\n   */\n  readonly destination: ILogSubscriptionDestination;\n\n  /**\n   * Log events matching this pattern will be sent to the destination.\n   */\n  readonly filterPattern: IFilterPattern;\n}\n\n/**\n * Properties for a MetricFilter created from a LogGroup\n */\nexport interface MetricFilterOptions {\n  /**\n   * Pattern to search for log events.\n   */\n  readonly filterPattern: IFilterPattern;\n\n  /**\n   * The namespace of the metric to emit.\n   */\n  readonly metricNamespace: string;\n\n  /**\n   * The name of the metric to emit.\n   */\n  readonly metricName: string;\n\n  /**\n   * The value to emit for the metric.\n   *\n   * Can either be a literal number (typically \"1\"), or the name of a field in the structure\n   * to take the value from the matched event. If you are using a field value, the field\n   * value must have been matched using the pattern.\n   *\n   * If you want to specify a field from a matched JSON structure, use '$.fieldName',\n   * and make sure the field is in the pattern (if only as '$.fieldName = *').\n   *\n   * If you want to specify a field from a matched space-delimited structure,\n   * use '$fieldName'.\n   *\n   * @default \"1\"\n   */\n  readonly metricValue?: string;\n\n  /**\n   * The value to emit if the pattern does not match a particular event.\n   *\n   * @default No metric emitted.\n   */\n  readonly defaultValue?: number;\n}\n"],
  "mappings": "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",
  "names": []
}
