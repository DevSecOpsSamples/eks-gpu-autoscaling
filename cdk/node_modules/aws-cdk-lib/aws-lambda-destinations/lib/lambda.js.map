{
  "version": 3,
  "sources": ["lambda.ts"],
  "sourcesContent": ["import * as events from '../../aws-events';\nimport * as targets from '../../aws-events-targets';\nimport * as lambda from '../../aws-lambda';\nimport { EventBridgeDestination } from './event-bridge';\n\n// keep this import separate from other imports to reduce chance for merge conflicts with v2-main\n// eslint-disable-next-line no-duplicate-imports, import/order\nimport { Construct } from 'constructs';\n\n/**\n * Options for a Lambda destination\n */\nexport interface LambdaDestinationOptions {\n  /**\n   * Whether the destination function receives only the `responsePayload` of\n   * the source function.\n   *\n   * When set to `true` and used as `onSuccess` destination, the destination\n   * function will be invoked with the payload returned by the source function.\n   *\n   * When set to `true` and used as `onFailure` destination, the destination\n   * function will be invoked with the error object returned by source function.\n   *\n   * See the README of this module to see a full explanation of this option.\n   *\n   * @default false The destination function receives the full invocation record.\n   */\n  readonly responseOnly?: boolean;\n}\n\n/**\n * Use a Lambda function as a Lambda destination\n */\nexport class LambdaDestination implements lambda.IDestination {\n  constructor(private readonly fn: lambda.IFunction, private readonly options: LambdaDestinationOptions = {}) {\n  }\n\n  /**\n   * Returns a destination configuration\n   */\n  public bind(scope: Construct, fn: lambda.IFunction, options?: lambda.DestinationOptions): lambda.DestinationConfig {\n    // Normal Lambda destination (full invocation record)\n    if (!this.options.responseOnly) {\n      // deduplicated automatically\n      this.fn.grantInvoke(fn);\n\n      return {\n        destination: this.fn.functionArn,\n      };\n    }\n\n    // Otherwise add rule to extract the response payload and use EventBridge\n    // as destination\n    if (!options) { // `options` added to bind() as optionnal to avoid breaking change\n      throw new Error('Options must be defined when using `responseOnly`.');\n    }\n\n    // Match invocation result of the source function (`fn`) and use it\n    // to trigger the destination function (`this.fn`).\n    new events.Rule(scope, options.type, {\n      eventPattern: {\n        detailType: [`Lambda Function Invocation Result - ${options.type}`],\n        resources: [`${fn.functionArn}:$LATEST`],\n        source: ['lambda'],\n      },\n      targets: [\n        new targets.LambdaFunction(this.fn, {\n          event: events.RuleTargetInput.fromEventPath('$.detail.responsePayload'), // Extract response payload\n        }),\n      ],\n    });\n\n    const destination = new EventBridgeDestination(); // Use default event bus here\n    return destination.bind(scope, fn);\n  }\n}\n"],
  "mappings": "wNAAA,OAAA,QAAA,kBAAA,EACA,QAAA,QAAA,0BAAA,EAEA,eAAA,QAAA,gBAAA,EA8BA,MAAa,iBAAiB,CAC5B,YAA6B,GAAuC,QAAoC,CAAA,EAAE,CAA7E,KAAA,GAAA,GAAuC,KAAA,QAAA,mKAM7D,KAAK,MAAkB,GAAsB,QAAmC,CAErF,2IAAI,CAAC,KAAK,QAAQ,aAEhB,YAAK,GAAG,YAAY,EAAE,EAEf,CACL,YAAa,KAAK,GAAG,aAMzB,GAAI,CAAC,QACH,KAAM,IAAI,OAAM,oDAAoD,EAKtE,UAAI,QAAO,KAAK,MAAO,QAAQ,KAAM,CACnC,aAAc,CACZ,WAAY,CAAC,uCAAuC,QAAQ,MAAM,EAClE,UAAW,CAAC,GAAG,GAAG,qBAAqB,EACvC,OAAQ,CAAC,QAAQ,GAEnB,QAAS,CACP,GAAI,SAAQ,eAAe,KAAK,GAAI,CAClC,MAAO,OAAO,gBAAgB,cAAc,0BAA0B,EACvE,GAEJ,EAGM,AADa,GAAI,gBAAA,uBAAsB,EAC3B,KAAK,MAAO,EAAE,GAxCrC,QAAA,kBAAA",
  "names": []
}
