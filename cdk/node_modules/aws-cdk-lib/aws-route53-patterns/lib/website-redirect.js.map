{
  "version": 3,
  "sources": ["website-redirect.ts"],
  "sourcesContent": ["import * as crypto from 'crypto';\nimport { DnsValidatedCertificate, ICertificate } from '../../aws-certificatemanager';\nimport { CloudFrontWebDistribution, OriginProtocolPolicy, PriceClass, ViewerCertificate, ViewerProtocolPolicy } from '../../aws-cloudfront';\nimport { ARecord, AaaaRecord, IHostedZone, RecordTarget } from '../../aws-route53';\nimport { CloudFrontTarget } from '../../aws-route53-targets';\nimport { BlockPublicAccess, Bucket, RedirectProtocol } from '../../aws-s3';\nimport { ArnFormat, RemovalPolicy, Stack, Token } from '../../core';\nimport { Construct } from 'constructs';\n\n/**\n * Properties to configure an HTTPS Redirect\n */\nexport interface HttpsRedirectProps {\n  /**\n   * Hosted zone of the domain which will be used to create alias record(s) from\n   * domain names in the hosted zone to the target domain. The hosted zone must\n   * contain entries for the domain name(s) supplied through `recordNames` that\n   * will redirect to the target domain.\n   *\n   * Domain names in the hosted zone can include a specific domain (example.com)\n   * and its subdomains (acme.example.com, zenith.example.com).\n   *\n   */\n  readonly zone: IHostedZone;\n\n  /**\n   * The redirect target fully qualified domain name (FQDN). An alias record\n   * will be created that points to your CloudFront distribution. Root domain\n   * or sub-domain can be supplied.\n   */\n  readonly targetDomain: string;\n\n  /**\n   * The domain names that will redirect to `targetDomain`\n   *\n   * @default - the domain name of the hosted zone\n   */\n  readonly recordNames?: string[];\n\n  /**\n   * The AWS Certificate Manager (ACM) certificate that will be associated with\n   * the CloudFront distribution that will be created. If provided, the certificate must be\n   * stored in us-east-1 (N. Virginia)\n   *\n   * @default - A new certificate is created in us-east-1 (N. Virginia)\n   */\n  readonly certificate?: ICertificate;\n}\n\n/**\n * Allows creating a domainA -> domainB redirect using CloudFront and S3.\n * You can specify multiple domains to be redirected.\n */\nexport class HttpsRedirect extends Construct {\n  constructor(scope: Construct, id: string, props: HttpsRedirectProps) {\n    super(scope, id);\n\n    const domainNames = props.recordNames ?? [props.zone.zoneName];\n\n    if (props.certificate) {\n      const certificateRegion = Stack.of(this).splitArn(props.certificate.certificateArn, ArnFormat.SLASH_RESOURCE_NAME).region;\n      if (!Token.isUnresolved(certificateRegion) && certificateRegion !== 'us-east-1') {\n        throw new Error(`The certificate must be in the us-east-1 region and the certificate you provided is in ${certificateRegion}.`);\n      }\n    }\n\n    const redirectCert = props.certificate ?? new DnsValidatedCertificate(this, 'RedirectCertificate', {\n      domainName: domainNames[0],\n      subjectAlternativeNames: domainNames,\n      hostedZone: props.zone,\n      region: 'us-east-1',\n    });\n\n    const redirectBucket = new Bucket(this, 'RedirectBucket', {\n      websiteRedirect: {\n        hostName: props.targetDomain,\n        protocol: RedirectProtocol.HTTPS,\n      },\n      removalPolicy: RemovalPolicy.DESTROY,\n      blockPublicAccess: BlockPublicAccess.BLOCK_ALL,\n    });\n    const redirectDist = new CloudFrontWebDistribution(this, 'RedirectDistribution', {\n      defaultRootObject: '',\n      originConfigs: [{\n        behaviors: [{ isDefaultBehavior: true }],\n        customOriginSource: {\n          domainName: redirectBucket.bucketWebsiteDomainName,\n          originProtocolPolicy: OriginProtocolPolicy.HTTP_ONLY,\n        },\n      }],\n      viewerCertificate: ViewerCertificate.fromAcmCertificate(redirectCert, {\n        aliases: domainNames,\n      }),\n      comment: `Redirect to ${props.targetDomain} from ${domainNames.join(', ')}`,\n      priceClass: PriceClass.PRICE_CLASS_ALL,\n      viewerProtocolPolicy: ViewerProtocolPolicy.REDIRECT_TO_HTTPS,\n    });\n\n    domainNames.forEach((domainName) => {\n      const hash = crypto.createHash('md5').update(domainName).digest('hex').slice(0, 6);\n      const aliasProps = {\n        recordName: domainName,\n        zone: props.zone,\n        target: RecordTarget.fromAlias(new CloudFrontTarget(redirectDist)),\n      };\n      new ARecord(this, `RedirectAliasRecord${hash}`, aliasProps);\n      new AaaaRecord(this, `RedirectAliasRecordSix${hash}`, aliasProps);\n    });\n  }\n}\n"],
  "mappings": "oNAAA,OAAA,QAAA,QAAA,EACA,yBAAA,QAAA,8BAAA,EACA,iBAAA,QAAA,sBAAA,EACA,cAAA,QAAA,mBAAA,EACA,sBAAA,QAAA,2BAAA,EACA,SAAA,QAAA,cAAA,EACA,OAAA,QAAA,YAAA,EACA,aAAA,QAAA,YAAA,EA8CA,MAAa,qBAAsB,cAAA,SAAS,CAC1C,YAAY,MAAkB,GAAY,MAAyB,WACjE,MAAM,MAAO,EAAE,qFAEf,KAAM,aAAW,IAAG,MAAM,eAAW,MAAA,KAAA,OAAA,GAAI,CAAC,MAAM,KAAK,QAAQ,EAE7D,GAAI,MAAM,YAAa,CACrB,KAAM,mBAAoB,OAAA,MAAM,GAAG,IAAI,EAAE,SAAS,MAAM,YAAY,eAAgB,OAAA,UAAU,mBAAmB,EAAE,OACnH,GAAI,CAAC,OAAA,MAAM,aAAa,iBAAiB,GAAK,oBAAsB,YAClE,KAAM,IAAI,OAAM,0FAA0F,oBAAoB,EAIlI,KAAM,cAAY,IAAG,MAAM,eAAW,MAAA,KAAA,OAAA,GAAI,GAAI,0BAAA,wBAAwB,KAAM,sBAAuB,CACjG,WAAY,YAAY,GACxB,wBAAyB,YACzB,WAAY,MAAM,KAClB,OAAQ,YACT,EAEK,eAAiB,GAAI,UAAA,OAAO,KAAM,iBAAkB,CACxD,gBAAiB,CACf,SAAU,MAAM,aAChB,SAAU,SAAA,iBAAiB,OAE7B,cAAe,OAAA,cAAc,QAC7B,kBAAmB,SAAA,kBAAkB,UACtC,EACK,aAAe,GAAI,kBAAA,0BAA0B,KAAM,uBAAwB,CAC/E,kBAAmB,GACnB,cAAe,CAAC,CACd,UAAW,CAAC,CAAE,kBAAmB,EAAI,CAAE,EACvC,mBAAoB,CAClB,WAAY,eAAe,wBAC3B,qBAAsB,iBAAA,qBAAqB,WAE9C,EACD,kBAAmB,iBAAA,kBAAkB,mBAAmB,aAAc,CACpE,QAAS,YACV,EACD,QAAS,eAAe,MAAM,qBAAqB,YAAY,KAAK,IAAI,IACxE,WAAY,iBAAA,WAAW,gBACvB,qBAAsB,iBAAA,qBAAqB,kBAC5C,EAED,YAAY,QAAQ,AAAC,YAAc,CACjC,KAAM,MAAO,OAAO,WAAW,KAAK,EAAE,OAAO,UAAU,EAAE,OAAO,KAAK,EAAE,MAAM,EAAG,CAAC,EAC3E,WAAa,CACjB,WAAY,WACZ,KAAM,MAAM,KACZ,OAAQ,cAAA,aAAa,UAAU,GAAI,uBAAA,iBAAiB,YAAY,CAAC,GAEnE,GAAI,eAAA,QAAQ,KAAM,sBAAsB,OAAQ,UAAU,EAC1D,GAAI,eAAA,WAAW,KAAM,yBAAyB,OAAQ,UAAU,CAClE,CAAC,GAtDL,QAAA,cAAA",
  "names": []
}
