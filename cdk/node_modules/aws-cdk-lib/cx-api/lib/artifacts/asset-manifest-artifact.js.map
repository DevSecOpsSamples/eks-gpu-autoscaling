{
  "version": 3,
  "sources": ["asset-manifest-artifact.ts"],
  "sourcesContent": ["import * as path from 'path';\nimport * as cxschema from '../../../cloud-assembly-schema';\nimport { CloudArtifact } from '../cloud-artifact';\nimport { CloudAssembly } from '../cloud-assembly';\n\nconst ASSET_MANIFEST_ARTIFACT_SYM = Symbol.for('@aws-cdk/cx-api.AssetManifestArtifact');\n\n/**\n * Asset manifest is a description of a set of assets which need to be built and published\n */\nexport class AssetManifestArtifact extends CloudArtifact {\n  /**\n   * Checks if `art` is an instance of this class.\n   *\n   * Use this method instead of `instanceof` to properly detect `AssetManifestArtifact`\n   * instances, even when the construct library is symlinked.\n   *\n   * Explanation: in JavaScript, multiple copies of the `cx-api` library on\n   * disk are seen as independent, completely different libraries. As a\n   * consequence, the class `AssetManifestArtifact` in each copy of the `cx-api` library\n   * is seen as a different class, and an instance of one class will not test as\n   * `instanceof` the other class. `npm install` will not create installations\n   * like this, but users may manually symlink construct libraries together or\n   * use a monorepo tool: in those cases, multiple copies of the `cx-api`\n   * library can be accidentally installed, and `instanceof` will behave\n   * unpredictably. It is safest to avoid using `instanceof`, and using\n   * this type-testing method instead.\n   */\n  public static isAssetManifestArtifact(art: any): art is AssetManifestArtifact {\n    return art && typeof art === 'object' && art[ASSET_MANIFEST_ARTIFACT_SYM];\n  }\n\n  /**\n   * The file name of the asset manifest\n   */\n  public readonly file: string;\n\n  /**\n   * Version of bootstrap stack required to deploy this stack\n   */\n  public readonly requiresBootstrapStackVersion: number;\n\n  /**\n   * Name of SSM parameter with bootstrap stack version\n   *\n   * @default - Discover SSM parameter by reading stack\n   */\n  public readonly bootstrapStackVersionSsmParameter?: string;\n\n  constructor(assembly: CloudAssembly, name: string, artifact: cxschema.ArtifactManifest) {\n    super(assembly, name, artifact);\n\n    const properties = (this.manifest.properties || {}) as cxschema.AssetManifestProperties;\n    if (!properties.file) {\n      throw new Error('Invalid AssetManifestArtifact. Missing \"file\" property');\n    }\n    this.file = path.resolve(this.assembly.directory, properties.file);\n    this.requiresBootstrapStackVersion = properties.requiresBootstrapStackVersion ?? 1;\n    this.bootstrapStackVersionSsmParameter = properties.bootstrapStackVersionSsmParameter;\n  }\n}\n\n/**\n * Mark all instances of 'AssetManifestArtifact'\n *\n * Why not put this in the constructor? Because this is a class property,\n * not an instance property. It applies to all instances of the class.\n */\nObject.defineProperty(AssetManifestArtifact.prototype, ASSET_MANIFEST_ARTIFACT_SYM, {\n  value: true,\n  enumerable: false,\n  writable: false,\n});\n"],
  "mappings": "+NAAA,KAAA,QAAA,MAAA,EAEA,iBAAA,QAAA,mBAAA,EAGM,4BAA8B,OAAO,IAAI,uCAAuC,EAKtF,MAAa,6BAA8B,kBAAA,aAAa,CAuCtD,YAAY,SAAyB,KAAc,SAAmC,QACpF,MAAM,SAAU,KAAM,QAAQ,0JAE9B,KAAM,YAAc,KAAK,SAAS,YAAc,CAAA,EAChD,GAAI,CAAC,WAAW,KACd,KAAM,IAAI,OAAM,wDAAwD,EAE1E,KAAK,KAAO,KAAK,QAAQ,KAAK,SAAS,UAAW,WAAW,IAAI,EACjE,KAAK,8BAA6B,IAAG,WAAW,iCAA6B,MAAA,KAAA,OAAA,GAAI,EACjF,KAAK,kCAAoC,WAAW,wCA9BxC,yBAAwB,IAAQ,CAC5C,MAAO,MAAO,MAAO,MAAQ,UAAY,IAAI,8BAnBjD,QAAA,sBAAA,wIA0DA,OAAO,eAAe,sBAAsB,UAAW,4BAA6B,CAClF,MAAO,GACP,WAAY,GACZ,SAAU,GACX",
  "names": []
}
