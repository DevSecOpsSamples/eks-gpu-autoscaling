{
  "version": 3,
  "sources": ["cloud-artifact.ts"],
  "sourcesContent": ["import * as cxschema from '../../cloud-assembly-schema';\nimport type { CloudAssembly } from './cloud-assembly';\nimport { MetadataEntryResult, SynthesisMessage, SynthesisMessageLevel } from './metadata';\n\n/**\n * Artifact properties for CloudFormation stacks.\n */\nexport interface AwsCloudFormationStackProperties {\n  /**\n   * A file relative to the assembly root which contains the CloudFormation template for this stack.\n   */\n  readonly templateFile: string;\n\n  /**\n   * Values for CloudFormation stack parameters that should be passed when the stack is deployed.\n   */\n  readonly parameters?: { [id: string]: string };\n\n  /**\n   * The name to use for the CloudFormation stack.\n   * @default - name derived from artifact ID\n   */\n  readonly stackName?: string;\n\n  /**\n   * Whether to enable termination protection for this stack.\n   *\n   * @default false\n   */\n  readonly terminationProtection?: boolean;\n}\n\n/**\n * Represents an artifact within a cloud assembly.\n */\nexport class CloudArtifact {\n  /**\n   * Returns a subclass of `CloudArtifact` based on the artifact type defined in the artifact manifest.\n   *\n   * @param assembly The cloud assembly from which to load the artifact\n   * @param id The artifact ID\n   * @param artifact The artifact manifest\n   * @returns the `CloudArtifact` that matches the artifact type or `undefined` if it's an artifact type that is unrecognized by this module.\n   */\n  public static fromManifest(assembly: CloudAssembly, id: string, artifact: cxschema.ArtifactManifest): CloudArtifact | undefined {\n    // Implementation is defined in a separate file to break cyclic dependencies\n    void(assembly), void(id), void(artifact);\n    throw new Error('Implementation not overridden yet');\n  }\n\n  /**\n   * The artifact's manifest\n   */\n  public readonly manifest: cxschema.ArtifactManifest;\n\n  /**\n   * The set of messages extracted from the artifact's metadata.\n   */\n  public readonly messages: SynthesisMessage[];\n\n  /**\n   * IDs of all dependencies. Used when topologically sorting the artifacts within the cloud assembly.\n   * @internal\n   */\n  public readonly _dependencyIDs: string[];\n\n  /**\n   * Cache of resolved dependencies.\n   */\n  private _deps?: CloudArtifact[];\n\n  protected constructor(public readonly assembly: CloudAssembly, public readonly id: string, manifest: cxschema.ArtifactManifest) {\n    this.manifest = manifest;\n    this.messages = this.renderMessages();\n    this._dependencyIDs = manifest.dependencies || [];\n  }\n\n  /**\n   * Returns all the artifacts that this artifact depends on.\n   */\n  public get dependencies(): CloudArtifact[] {\n    if (this._deps) { return this._deps; }\n\n    this._deps = this._dependencyIDs.map(id => {\n      const dep = this.assembly.tryGetArtifact(id);\n      if (!dep) {\n        throw new Error(`Artifact ${this.id} depends on non-existing artifact ${id}`);\n      }\n      return dep;\n    });\n\n    return this._deps;\n  }\n\n  /**\n   * @returns all the metadata entries of a specific type in this artifact.\n   * @param type\n   */\n  public findMetadataByType(type: string): MetadataEntryResult[] {\n    const result = new Array<MetadataEntryResult>();\n    for (const path of Object.keys(this.manifest.metadata || {})) {\n      for (const entry of (this.manifest.metadata || {})[path]) {\n        if (entry.type === type) {\n          result.push({ path, ...entry });\n        }\n      }\n    }\n    return result;\n  }\n\n  private renderMessages() {\n    const messages = new Array<SynthesisMessage>();\n\n    for (const [id, metadata] of Object.entries(this.manifest.metadata || { })) {\n      for (const entry of metadata) {\n        let level: SynthesisMessageLevel;\n        switch (entry.type) {\n          case cxschema.ArtifactMetadataEntryType.WARN:\n            level = SynthesisMessageLevel.WARNING;\n            break;\n          case cxschema.ArtifactMetadataEntryType.ERROR:\n            level = SynthesisMessageLevel.ERROR;\n            break;\n          case cxschema.ArtifactMetadataEntryType.INFO:\n            level = SynthesisMessageLevel.INFO;\n            break;\n          default:\n            continue;\n        }\n\n        messages.push({ level, entry, id });\n      }\n    }\n\n    return messages;\n  }\n\n  /**\n   * An identifier that shows where this artifact is located in the tree\n   * of nested assemblies, based on their manifests. Defaults to the normal\n   * id. Should only be used in user interfaces.\n   */\n  public get hierarchicalId(): string {\n    return this.manifest.displayName ?? this.id;\n  }\n}\n"],
  "mappings": "oNAAA,SAAA,QAAA,6BAAA,EAEA,WAAA,QAAA,YAAA,EAiCA,MAAa,aAAa,CAoCxB,YAAsC,SAAyC,GAAY,SAAmC,CAAxF,KAAA,SAAA,SAAyC,KAAA,GAAA,2JAC7E,KAAK,SAAW,SAChB,KAAK,SAAW,KAAK,eAAc,EACnC,KAAK,eAAiB,SAAS,cAAgB,CAAA,QA9BnC,cAAa,SAAyB,GAAY,SAAmC,+JAG3F,GAAI,OAAM,mCAAmC,KAiC1C,eAAY,CACrB,MAAI,MAAK,MAAgB,KAAK,MAE9B,MAAK,MAAQ,KAAK,eAAe,IAAI,IAAK,CACxC,KAAM,KAAM,KAAK,SAAS,eAAe,EAAE,EAC3C,GAAI,CAAC,IACH,KAAM,IAAI,OAAM,YAAY,KAAK,uCAAuC,IAAI,EAE9E,MAAO,IACT,CAAC,EAEM,KAAK,OAOP,mBAAmB,KAAY,CACpC,KAAM,QAAS,GAAI,OACnB,SAAW,QAAQ,QAAO,KAAK,KAAK,SAAS,UAAY,CAAA,CAAE,EACzD,SAAW,SAAU,MAAK,SAAS,UAAY,CAAA,GAAI,MACjD,AAAI,MAAM,OAAS,MACjB,OAAO,KAAK,CAAE,QAAS,KAAK,CAAE,EAIpC,MAAO,QAGD,gBAAc,CACpB,KAAM,UAAW,GAAI,OAErB,SAAW,CAAC,GAAI,WAAa,QAAO,QAAQ,KAAK,SAAS,UAAY,CAAA,CAAG,EACvE,SAAW,SAAS,UAAU,CAC5B,GAAI,OACJ,OAAQ,MAAM,UACP,UAAS,0BAA0B,KACtC,MAAQ,WAAA,sBAAsB,QAC9B,UACG,UAAS,0BAA0B,MACtC,MAAQ,WAAA,sBAAsB,MAC9B,UACG,UAAS,0BAA0B,KACtC,MAAQ,WAAA,sBAAsB,KAC9B,cAEA,SAGJ,SAAS,KAAK,CAAE,MAAO,MAAO,EAAE,CAAE,EAItC,MAAO,aAQE,iBAAc,QACvB,MAAA,IAAO,KAAK,SAAS,eAAW,MAAA,KAAA,OAAA,GAAI,KAAK,IA5G7C,QAAA,cAAA",
  "names": []
}
