{
  "version": 3,
  "sources": ["toposort.ts"],
  "sourcesContent": ["import { GraphNode } from './graph';\n\nexport function printDependencyMap<A>(dependencies: Map<GraphNode<A>, Set<GraphNode<A>>>) {\n  const lines = ['---'];\n  for (const [k, vs] of dependencies.entries()) {\n    lines.push(`${k} -> ${Array.from(vs)}`);\n  }\n  // eslint-disable-next-line no-console\n  console.log(lines.join('\\n'));\n}\n\nexport function topoSort<A>(nodes: Set<GraphNode<A>>, dependencies: Map<GraphNode<A>, Set<GraphNode<A>>>): GraphNode<A>[][] {\n  const remaining = new Set<GraphNode<A>>(nodes);\n\n  const ret: GraphNode<A>[][] = [];\n  while (remaining.size > 0) {\n    // All elements with no more deps in the set can be ordered\n    const selectable = Array.from(remaining.values()).filter(e => {\n      if (!dependencies.has(e)) {\n        throw new Error(`No key for ${e}`);\n      }\n      return dependencies.get(e)!.size === 0;\n    });\n    selectable.sort((a, b) => a.id < b.id ? -1 : b.id < a.id ? 1 : 0);\n\n    // If we didn't make any progress, we got stuck\n    if (selectable.length === 0) {\n      const cycle = findCycle(dependencies);\n      throw new Error(`Dependency cycle in graph: ${cycle.map(n => n.id).join(' => ')}`);\n    }\n\n    ret.push(selectable);\n\n    for (const selected of selectable) {\n      remaining.delete(selected);\n      for (const depSet of dependencies.values()) {\n        depSet.delete(selected);\n      }\n    }\n  }\n\n  return ret;\n}\n\n/**\n * Find cycles in a graph\n *\n * Not the fastest, but effective and should be rare\n */\nfunction findCycle<A>(deps: Map<GraphNode<A>, Set<GraphNode<A>>>): GraphNode<A>[] {\n  for (const node of deps.keys()) {\n    const cycle = recurse(node, [node]);\n    if (cycle) { return cycle; }\n  }\n  throw new Error('No cycle found. Assertion failure!');\n\n  function recurse(node: GraphNode<A>, path: GraphNode<A>[]): GraphNode<A>[] | undefined {\n    for (const dep of deps.get(node) ?? []) {\n      if (dep === path[0]) { return [...path, dep]; }\n\n      const cycle = recurse(dep, [...path, dep]);\n      if (cycle) { return cycle; }\n    }\n\n    return undefined;\n  }\n}"],
  "mappings": "uHAEA,4BAAsC,aAAkD,CACtF,KAAM,OAAQ,CAAC,KAAK,EACpB,SAAW,CAAC,EAAG,KAAO,cAAa,QAAO,EACxC,MAAM,KAAK,GAAG,QAAQ,MAAM,KAAK,EAAE,GAAG,EAGxC,QAAQ,IAAI,MAAM,KAAK;CAAI,CAAC,CAC9B,CAPA,QAAA,mBAAA,mBASA,kBAA4B,MAA0B,aAAkD,CACtG,KAAM,WAAY,GAAI,KAAkB,KAAK,EAEvC,IAAwB,CAAA,EAC9B,KAAO,UAAU,KAAO,GAAG,CAEzB,KAAM,YAAa,MAAM,KAAK,UAAU,OAAM,CAAE,EAAE,OAAO,GAAI,CAC3D,GAAI,CAAC,aAAa,IAAI,CAAC,EACrB,KAAM,IAAI,OAAM,cAAc,GAAG,EAEnC,MAAO,cAAa,IAAI,CAAC,EAAG,OAAS,CACvC,CAAC,EAID,GAHA,WAAW,KAAK,CAAC,EAAG,IAAM,EAAE,GAAK,EAAE,GAAK,GAAK,EAAE,GAAK,EAAE,GAAK,EAAI,CAAC,EAG5D,WAAW,SAAW,EAAG,CAC3B,KAAM,OAAQ,UAAU,YAAY,EACpC,KAAM,IAAI,OAAM,8BAA8B,MAAM,IAAI,GAAK,EAAE,EAAE,EAAE,KAAK,MAAM,GAAG,EAGnF,IAAI,KAAK,UAAU,EAEnB,SAAW,YAAY,YAAY,CACjC,UAAU,OAAO,QAAQ,EACzB,SAAW,UAAU,cAAa,OAAM,EACtC,OAAO,OAAO,QAAQ,GAK5B,MAAO,IACT,CA/BA,QAAA,SAAA,SAsCA,mBAAsB,KAA0C,CAC9D,SAAW,QAAQ,MAAK,KAAI,EAAI,CAC9B,KAAM,OAAQ,QAAQ,KAAM,CAAC,IAAI,CAAC,EAClC,GAAI,MAAS,MAAO,OAEtB,KAAM,IAAI,OAAM,oCAAoC,EAEpD,iBAAiB,KAAoB,KAAoB,QACvD,SAAW,OAAG,IAAI,KAAK,IAAI,IAAI,KAAC,MAAA,KAAA,OAAA,GAAI,CAAA,EAAI,CACtC,GAAI,MAAQ,KAAK,GAAM,MAAO,CAAC,GAAG,KAAM,GAAG,EAE3C,KAAM,OAAQ,QAAQ,IAAK,CAAC,GAAG,KAAM,GAAG,CAAC,EACzC,GAAI,MAAS,MAAO,OAIxB,CACF",
  "names": []
}
