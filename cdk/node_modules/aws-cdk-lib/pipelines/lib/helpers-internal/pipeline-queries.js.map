{
  "version": 3,
  "sources": ["pipeline-queries.ts"],
  "sourcesContent": ["import { Step, ShellStep, StackOutputReference, StackDeployment, StackAsset, StageDeployment } from '../blueprint';\nimport { PipelineBase } from '../main/pipeline-base';\n\n/**\n * Answer some questions about a pipeline blueprint\n */\nexport class PipelineQueries {\n  constructor(private readonly pipeline: PipelineBase) {\n  }\n\n  /**\n   * Return the names of all outputs for the given stack that are referenced in this blueprint\n   */\n  public stackOutputsReferenced(stack: StackDeployment): string[] {\n    const steps = new Array<Step>();\n    for (const wave of this.pipeline.waves) {\n      steps.push(...wave.pre, ...wave.post);\n      for (const stage of wave.stages) {\n        steps.push(...stage.pre, ...stage.post);\n        for (const stackDeployment of stage.stacks) {\n          steps.push(...stackDeployment.pre, ...stackDeployment.changeSet, ...stackDeployment.post);\n        }\n      }\n    }\n\n    const ret = new Array<string>();\n    for (const step of steps) {\n      if (!(step instanceof ShellStep)) { continue; }\n\n      for (const outputRef of Object.values(step.envFromCfnOutputs)) {\n        if (outputRef.isProducedBy(stack)) {\n          ret.push(outputRef.outputName);\n        }\n      }\n    }\n    return ret;\n  }\n\n  /**\n   * Find the stack deployment that is producing the given reference\n   */\n  public producingStack(outputReference: StackOutputReference): StackDeployment {\n    for (const wave of this.pipeline.waves) {\n      for (const stage of wave.stages) {\n        for (const stack of stage.stacks) {\n          if (outputReference.isProducedBy(stack)) {\n            return stack;\n          }\n        }\n      }\n    }\n\n    throw new Error(`Stack '${outputReference.stackDescription}' (producing output '${outputReference.outputName}') is not in the pipeline; call 'addStage()' to add the stack's Stage to the pipeline`);\n  }\n\n  /**\n   * All assets referenced in all the Stacks of a StageDeployment\n   */\n  public assetsInStage(stage: StageDeployment): StackAsset[] {\n    const assets = new Map<string, StackAsset>();\n\n    for (const stack of stage.stacks) {\n      for (const asset of stack.assets) {\n        assets.set(asset.assetSelector, asset);\n      }\n    }\n\n    return Array.from(assets.values());\n  }\n}"],
  "mappings": "mGAAA,KAAA,aAAA,QAAA,cAAA,EAMA,MAAa,eAAe,CAC1B,YAA6B,SAAsB,CAAtB,KAAA,SAAA,SAMtB,uBAAuB,MAAsB,CAClD,KAAM,OAAQ,GAAI,OAClB,SAAW,QAAQ,MAAK,SAAS,MAAO,CACtC,MAAM,KAAK,GAAG,KAAK,IAAK,GAAG,KAAK,IAAI,EACpC,SAAW,SAAS,MAAK,OAAQ,CAC/B,MAAM,KAAK,GAAG,MAAM,IAAK,GAAG,MAAM,IAAI,EACtC,SAAW,mBAAmB,OAAM,OAClC,MAAM,KAAK,GAAG,gBAAgB,IAAK,GAAG,gBAAgB,UAAW,GAAG,gBAAgB,IAAI,GAK9F,KAAM,KAAM,GAAI,OAChB,SAAW,QAAQ,OACjB,GAAM,eAAgB,aAAA,UAEtB,SAAW,aAAa,QAAO,OAAO,KAAK,iBAAiB,EAC1D,AAAI,UAAU,aAAa,KAAK,GAC9B,IAAI,KAAK,UAAU,UAAU,EAInC,MAAO,KAMF,eAAe,gBAAqC,CACzD,SAAW,QAAQ,MAAK,SAAS,MAC/B,SAAW,SAAS,MAAK,OACvB,SAAW,SAAS,OAAM,OACxB,GAAI,gBAAgB,aAAa,KAAK,EACpC,MAAO,OAMf,KAAM,IAAI,OAAM,UAAU,gBAAgB,wCAAwC,gBAAgB,iGAAiG,EAM9L,cAAc,MAAsB,CACzC,KAAM,QAAS,GAAI,KAEnB,SAAW,SAAS,OAAM,OACxB,SAAW,SAAS,OAAM,OACxB,OAAO,IAAI,MAAM,cAAe,KAAK,EAIzC,MAAO,OAAM,KAAK,OAAO,OAAM,CAAE,GA7DrC,QAAA,gBAAA",
  "names": []
}
