{
  "version": 3,
  "sources": ["pipeline-graph.ts"],
  "sourcesContent": ["import { AssetType, FileSet, ShellStep, StackAsset, StackDeployment, StageDeployment, Step, Wave } from '../blueprint';\nimport { PipelineBase } from '../main/pipeline-base';\nimport { DependencyBuilders, Graph, GraphNode, GraphNodeCollection } from './graph';\nimport { PipelineQueries } from './pipeline-queries';\n\nexport interface PipelineGraphProps {\n  /**\n   * Add a self-mutation step.\n   *\n   * @default false\n   */\n  readonly selfMutation?: boolean;\n\n  /**\n   * Publishes the template asset to S3.\n   *\n   * @default false\n   */\n  readonly publishTemplate?: boolean;\n\n  /**\n   * Whether to combine asset publishers for the same type into one step\n   *\n   * @default false\n   */\n  readonly singlePublisherPerAssetType?: boolean;\n\n  /**\n   * Add a \"prepare\" step for each stack which can be used to create the change\n   * set. If this is disabled, only the \"execute\" step will be included.\n   *\n   * @default true\n   */\n  readonly prepareStep?: boolean;\n}\n\n/**\n * Logic to turn the deployment blueprint into a graph\n *\n * This code makes all the decisions on how to lay out the CodePipeline\n */\nexport class PipelineGraph {\n  /**\n   * A Step object that may be used as the producer of FileSets that should not be represented in the graph\n   */\n  public static readonly NO_STEP: Step = new class extends Step { }('NO_STEP');\n\n  public readonly graph: AGraph = Graph.of('', { type: 'group' });\n  public readonly cloudAssemblyFileSet: FileSet;\n  public readonly queries: PipelineQueries;\n\n  private readonly added = new Map<Step, AGraphNode>();\n  private readonly assetNodes = new Map<string, AGraphNode>();\n  private readonly assetNodesByType = new Map<AssetType, AGraphNode>();\n  private readonly synthNode?: AGraphNode;\n  private readonly selfMutateNode?: AGraphNode;\n  private readonly stackOutputDependencies = new DependencyBuilders<StackDeployment, any>();\n  private readonly publishTemplate: boolean;\n  private readonly prepareStep: boolean;\n  private readonly singlePublisher: boolean;\n\n  private lastPreparationNode?: AGraphNode;\n  private _fileAssetCtr = 0;\n  private _dockerAssetCtr = 0;\n\n  constructor(public readonly pipeline: PipelineBase, props: PipelineGraphProps = {}) {\n    this.publishTemplate = props.publishTemplate ?? false;\n    this.prepareStep = props.prepareStep ?? true;\n    this.singlePublisher = props.singlePublisherPerAssetType ?? false;\n\n    this.queries = new PipelineQueries(pipeline);\n\n    if (pipeline.synth instanceof Step) {\n      this.synthNode = this.addBuildStep(pipeline.synth);\n      if (this.synthNode?.data?.type === 'step') {\n        this.synthNode.data.isBuildStep = true;\n      }\n    }\n    this.lastPreparationNode = this.synthNode;\n\n    const cloudAssembly = pipeline.synth.primaryOutput?.primaryOutput;\n    if (!cloudAssembly) {\n      throw new Error(`The synth step must produce the cloud assembly artifact, but doesn't: ${pipeline.synth}`);\n    }\n\n    this.cloudAssemblyFileSet = cloudAssembly;\n\n    if (props.selfMutation) {\n      const stage: AGraph = Graph.of('UpdatePipeline', { type: 'group' });\n      this.graph.add(stage);\n      this.selfMutateNode = GraphNode.of('SelfMutate', { type: 'self-update' });\n      stage.add(this.selfMutateNode);\n\n      this.selfMutateNode.dependOn(this.synthNode);\n      this.lastPreparationNode = this.selfMutateNode;\n    }\n\n    const waves = pipeline.waves.map(w => this.addWave(w));\n\n    // Make sure the waves deploy sequentially\n    for (let i = 1; i < waves.length; i++) {\n      waves[i].dependOn(waves[i - 1]);\n    }\n\n    // Add additional dependencies between steps that depend on stack outputs and the stacks\n    // that produce them.\n  }\n\n  public isSynthNode(node: AGraphNode) {\n    return this.synthNode === node;\n  }\n\n  private addBuildStep(step: Step) {\n    return this.addAndRecurse(step, this.topLevelGraph('Build'));\n  }\n\n  private addWave(wave: Wave): AGraph {\n    // If the wave only has one Stage in it, don't add an additional Graph around it\n    const retGraph: AGraph = wave.stages.length === 1\n      ? this.addStage(wave.stages[0])\n      : Graph.of(wave.id, { type: 'group' }, wave.stages.map(s => this.addStage(s)));\n\n    this.addPrePost(wave.pre, wave.post, retGraph);\n    retGraph.dependOn(this.lastPreparationNode);\n    this.graph.add(retGraph);\n\n    return retGraph;\n  }\n\n  private addStage(stage: StageDeployment): AGraph {\n    const retGraph: AGraph = Graph.of(stage.stageName, { type: 'group' });\n\n    const stackGraphs = new Map<StackDeployment, AGraph>();\n\n    for (const stack of stage.stacks) {\n      const stackGraph: AGraph = Graph.of(this.simpleStackName(stack.stackName, stage.stageName), { type: 'stack-group', stack });\n      const prepareNode: AGraphNode | undefined = this.prepareStep ? GraphNode.of('Prepare', { type: 'prepare', stack }) : undefined;\n      const deployNode: AGraphNode = GraphNode.of('Deploy', {\n        type: 'execute',\n        stack,\n        captureOutputs: this.queries.stackOutputsReferenced(stack).length > 0,\n      });\n\n      retGraph.add(stackGraph);\n      stackGraph.add(deployNode);\n\n      // node or node collection that represents first point of contact in each stack\n      let firstDeployNode;\n      if (prepareNode) {\n        stackGraph.add(prepareNode);\n        deployNode.dependOn(prepareNode);\n        firstDeployNode = prepareNode;\n      } else {\n        firstDeployNode = deployNode;\n      }\n\n      // add changeset steps at the stack level\n      if (stack.changeSet.length > 0) {\n        if (prepareNode) {\n          this.addChangeSet(stack.changeSet, prepareNode, deployNode, stackGraph);\n        } else {\n          throw new Error('Your pipeline engine does not support changeSet steps');\n        }\n      }\n\n      // add pre and post steps at the stack level\n      const preNodes = this.addPrePost(stack.pre, stack.post, stackGraph);\n      if (preNodes.nodes.length > 0) {\n        firstDeployNode = preNodes;\n      }\n\n      stackGraphs.set(stack, stackGraph);\n\n      const cloudAssembly = this.cloudAssemblyFileSet;\n\n      firstDeployNode.dependOn(this.addAndRecurse(cloudAssembly.producer, retGraph));\n\n      // add the template asset\n      if (this.publishTemplate) {\n        if (!stack.templateAsset) {\n          throw new Error(`\"publishTemplate\" is enabled, but stack ${stack.stackArtifactId} does not have a template asset`);\n        }\n\n        firstDeployNode.dependOn(this.publishAsset(stack.templateAsset));\n      }\n\n      // Depend on Assets\n      // FIXME: Custom Cloud Assembly currently doesn't actually help separating\n      // out templates from assets!!!\n      for (const asset of stack.assets) {\n        const assetNode = this.publishAsset(asset);\n        firstDeployNode.dependOn(assetNode);\n      }\n\n      // Add stack output synchronization point\n      if (this.queries.stackOutputsReferenced(stack).length > 0) {\n        this.stackOutputDependencies.get(stack).dependOn(deployNode);\n      }\n    }\n\n    for (const stack of stage.stacks) {\n      for (const dep of stack.stackDependencies) {\n        const stackNode = stackGraphs.get(stack);\n        const depNode = stackGraphs.get(dep);\n        if (!stackNode) {\n          throw new Error(`cannot find node for ${stack.stackName}`);\n        }\n        if (!depNode) {\n          throw new Error(`cannot find node for ${dep.stackName}`);\n        }\n        stackNode.dependOn(depNode);\n      }\n    }\n\n    this.addPrePost(stage.pre, stage.post, retGraph);\n\n    return retGraph;\n  }\n\n  private addChangeSet(changeSet: Step[], prepareNode: AGraphNode, deployNode: AGraphNode, graph: AGraph) {\n    for (const c of changeSet) {\n      const changeSetNode = this.addAndRecurse(c, graph);\n      changeSetNode?.dependOn(prepareNode);\n      deployNode.dependOn(changeSetNode);\n    }\n  }\n\n  private addPrePost(pre: Step[], post: Step[], parent: AGraph) {\n    const currentNodes = new GraphNodeCollection(parent.nodes);\n    const preNodes = new GraphNodeCollection(new Array<AGraphNode>());\n    for (const p of pre) {\n      const preNode = this.addAndRecurse(p, parent);\n      currentNodes.dependOn(preNode);\n      preNodes.nodes.push(preNode!);\n    }\n    for (const p of post) {\n      const postNode = this.addAndRecurse(p, parent);\n      postNode?.dependOn(...currentNodes.nodes);\n    }\n    return preNodes;\n  }\n\n  private topLevelGraph(name: string): AGraph {\n    let ret = this.graph.tryGetChild(name);\n    if (!ret) {\n      ret = new Graph<GraphAnnotation>(name);\n      this.graph.add(ret);\n    }\n    return ret as AGraph;\n  }\n\n  private addAndRecurse(step: Step, parent: AGraph) {\n    if (step === PipelineGraph.NO_STEP) { return undefined; }\n\n    const previous = this.added.get(step);\n    if (previous) { return previous; }\n\n    const node: AGraphNode = GraphNode.of(step.id, { type: 'step', step });\n\n    // If the step is a source step, change the parent to a special \"Source\" stage\n    // (CodePipeline wants it that way)\n    if (step.isSource) {\n      parent = this.topLevelGraph('Source');\n    }\n\n    parent.add(node);\n    this.added.set(step, node);\n\n    for (const dep of step.dependencies) {\n      const producerNode = this.addAndRecurse(dep, parent);\n      node.dependOn(producerNode);\n    }\n\n    // Add stack dependencies (by use of the dependency builder this also works\n    // if we encounter the Step before the Stack has been properly added yet)\n    if (step instanceof ShellStep) {\n      for (const output of Object.values(step.envFromCfnOutputs)) {\n        const stack = this.queries.producingStack(output);\n        this.stackOutputDependencies.get(stack).dependBy(node);\n      }\n    }\n\n    return node;\n  }\n\n  private publishAsset(stackAsset: StackAsset): AGraphNode {\n    const assetsGraph = this.topLevelGraph('Assets');\n\n    let assetNode = this.assetNodes.get(stackAsset.assetId);\n    if (assetNode) {\n      // If there's already a node publishing this asset, add as a new publishing\n      // destination to the same node.\n    } else if (this.singlePublisher && this.assetNodesByType.has(stackAsset.assetType)) {\n      // If we're doing a single node per type, lookup by that\n      assetNode = this.assetNodesByType.get(stackAsset.assetType)!;\n    } else {\n      // Otherwise add a new one\n      const id = stackAsset.assetType === AssetType.FILE\n        ? (this.singlePublisher ? 'FileAsset' : `FileAsset${++this._fileAssetCtr}`)\n        : (this.singlePublisher ? 'DockerAsset' : `DockerAsset${++this._dockerAssetCtr}`);\n\n      assetNode = GraphNode.of(id, { type: 'publish-assets', assets: [] });\n      assetsGraph.add(assetNode);\n      assetNode.dependOn(this.lastPreparationNode);\n\n      this.assetNodesByType.set(stackAsset.assetType, assetNode);\n      this.assetNodes.set(stackAsset.assetId, assetNode);\n    }\n\n    const data = assetNode.data;\n    if (data?.type !== 'publish-assets') {\n      throw new Error(`${assetNode} has the wrong data.type: ${data?.type}`);\n    }\n    if (!data.assets.some(a => a.assetSelector === stackAsset.assetSelector)) {\n      data.assets.push(stackAsset);\n    }\n\n    return assetNode;\n  }\n\n  /**\n   * Simplify the stack name by removing the `Stage-` prefix if it exists.\n   */\n  private simpleStackName(stackName: string, stageName: string) {\n    return stripPrefix(stackName, `${stageName}-`);\n  }\n}\n\ntype GraphAnnotation =\n  { readonly type: 'group' }\n  | { readonly type: 'stack-group'; readonly stack: StackDeployment }\n  | { readonly type: 'publish-assets'; readonly assets: StackAsset[] }\n  | { readonly type: 'step'; readonly step: Step; isBuildStep?: boolean }\n  | { readonly type: 'self-update' }\n  | { readonly type: 'prepare'; readonly stack: StackDeployment }\n  | { readonly type: 'execute'; readonly stack: StackDeployment; readonly captureOutputs: boolean }\n  ;\n\n// Type aliases for the graph nodes tagged with our specific annotation type\n// (to save on generics in the code above).\nexport type AGraphNode = GraphNode<GraphAnnotation>;\nexport type AGraph = Graph<GraphAnnotation>;\n\nfunction stripPrefix(s: string, prefix: string) {\n  return s.startsWith(prefix) ? s.slice(prefix.length) : s;\n}"],
  "mappings": "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",
  "names": []
}
