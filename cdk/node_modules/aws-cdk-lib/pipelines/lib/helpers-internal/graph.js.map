{
  "version": 3,
  "sources": ["graph.ts"],
  "sourcesContent": ["/**\n * A library for nested graphs\n */\nimport { addAll, extract, flatMap, isDefined } from '../private/javascript';\nimport { topoSort } from './toposort';\n\nexport interface GraphNodeProps<A> {\n  readonly data?: A;\n}\n\nexport class GraphNode<A> {\n  public static of<A>(id: string, data: A) {\n    return new GraphNode(id, { data });\n  }\n\n  public readonly dependencies: GraphNode<A>[] = [];\n  public readonly data?: A;\n  private _parentGraph?: Graph<A>;\n\n  constructor(public readonly id: string, props: GraphNodeProps<A> = {}) {\n    this.data = props.data;\n  }\n\n  /**\n   * A graph-wide unique identifier for this node. Rendered by joining the IDs\n   * of all ancestors with hyphens.\n   */\n  public get uniqueId(): string {\n    return this.ancestorPath(this.root).map(x => x.id).join('-');\n  }\n\n  /**\n   * The union of all dependencies of this node and the dependencies of all\n   * parent graphs.\n   */\n  public get allDeps(): GraphNode<A>[] {\n    const fromParent = this.parentGraph?.allDeps ?? [];\n    return Array.from(new Set([...this.dependencies, ...fromParent]));\n  }\n\n  public dependOn(...dependencies: Array<GraphNode<A> | undefined>) {\n    if (dependencies.includes(this)) {\n      throw new Error(`Cannot add dependency on self: ${this}`);\n    }\n    this.dependencies.push(...dependencies.filter(isDefined));\n  }\n\n  public ancestorPath(upTo: GraphNode<A>): GraphNode<A>[] {\n    let x: GraphNode<A> = this;\n    const ret = [x];\n    while (x.parentGraph && x.parentGraph !== upTo) {\n      x = x.parentGraph;\n      ret.unshift(x);\n    }\n    return ret;\n  }\n\n  public rootPath(): GraphNode<A>[] {\n    let x: GraphNode<A> = this;\n    const ret = [x];\n    while (x.parentGraph) {\n      x = x.parentGraph;\n      ret.unshift(x);\n    }\n    return ret;\n  }\n\n  public get root() {\n    let x: GraphNode<A> = this;\n    while (x.parentGraph) {\n      x = x.parentGraph;\n    }\n    return x;\n  }\n\n  public get parentGraph() {\n    return this._parentGraph;\n  }\n\n  /**\n   * @internal\n   */\n  public _setParentGraph(parentGraph: Graph<A>) {\n    if (this._parentGraph) {\n      throw new Error('Node already has a parent');\n    }\n    this._parentGraph = parentGraph;\n  }\n\n  public toString() {\n    return `${this.constructor.name}(${this.id})`;\n  }\n}\n\n/**\n * A dependency set that can be constructed partially and later finished\n *\n * It doesn't matter in what order sources and targets for the dependency\n * relationship(s) get added. This class can serve as a synchronization\n * point if the order in which graph nodes get added to the graph is not\n * well-defined.\n *\n * Useful utility during graph building.\n */\nexport class DependencyBuilder<A> {\n  private readonly targets: GraphNode<A>[] = [];\n  private readonly sources: GraphNode<A>[] = [];\n\n  public dependOn(...targets: GraphNode<A>[]) {\n    for (const target of targets) {\n      for (const source of this.sources) {\n        source.dependOn(target);\n      }\n      this.targets.push(target);\n    }\n    return this;\n  }\n\n  public dependBy(...sources: GraphNode<A>[]) {\n    for (const source of sources) {\n      for (const target of this.targets) {\n        source.dependOn(target);\n      }\n      this.sources.push(source);\n    }\n    return this;\n  }\n}\n\nexport class DependencyBuilders<K, A> {\n  private readonly builders = new Map<K, DependencyBuilder<A>>();\n\n  public get(key: K) {\n    const b = this.builders.get(key);\n    if (b) { return b; }\n    const ret = new DependencyBuilder<A>();\n    this.builders.set(key, ret);\n    return ret;\n  }\n}\n\nexport interface GraphProps<A> extends GraphNodeProps<A> {\n  /**\n   * Initial nodes in the workflow\n   */\n  readonly nodes?: GraphNode<A>[];\n}\n\nexport class Graph<A> extends GraphNode<A> {\n  public static of<A, B>(id: string, data: A, nodes?: GraphNode<B>[]) {\n    return new Graph<A | B>(id, { data, nodes });\n  }\n\n  private readonly children = new Map<string, GraphNode<A>>();\n\n  constructor(name: string, props: GraphProps<A>={}) {\n    super(name, props);\n\n    if (props.nodes) {\n      this.add(...props.nodes);\n    }\n  }\n\n  public get nodes() {\n    return new Set(this.children.values());\n  }\n\n  public tryGetChild(name: string) {\n    return this.children.get(name);\n  }\n\n  public contains(node: GraphNode<A>) {\n    return this.nodes.has(node);\n  }\n\n  public add(...nodes: Array<GraphNode<A>>) {\n    for (const node of nodes) {\n      node._setParentGraph(this);\n      if (this.children.has(node.id)) {\n        throw new Error(`Node with duplicate id: ${node.id}`);\n      }\n      this.children.set(node.id, node);\n    }\n  }\n\n  public absorb(other: Graph<A>) {\n    this.add(...other.nodes);\n  }\n\n  /**\n   * Return topologically sorted tranches of nodes at this graph level\n   */\n  public sortedChildren(): GraphNode<A>[][] {\n    // Project dependencies to current children\n    const nodes = this.nodes;\n    const projectedDependencies = projectDependencies(this.deepDependencies(), (node) => {\n      while (!nodes.has(node) && node.parentGraph) {\n        node = node.parentGraph;\n      }\n      return nodes.has(node) ? [node] : [];\n    });\n\n    return topoSort(nodes, projectedDependencies);\n  }\n\n  /**\n   * Return a topologically sorted list of non-Graph nodes in the entire subgraph\n   */\n  public sortedLeaves(): GraphNode<A>[][] {\n    // Project dependencies to leaf nodes\n    const descendantsMap = new Map<GraphNode<A>, GraphNode<A>[]>();\n    findDescendants(this);\n\n    function findDescendants(node: GraphNode<A>): GraphNode<A>[] {\n      const ret: GraphNode<A>[] = [];\n\n      if (node instanceof Graph) {\n        for (const child of node.nodes) {\n          ret.push(...findDescendants(child));\n        }\n      } else {\n        ret.push(node);\n      }\n\n      descendantsMap.set(node, ret);\n      return ret;\n    }\n\n    const projectedDependencies = projectDependencies(this.deepDependencies(), (node) => descendantsMap.get(node) ?? []);\n    return topoSort(new Set(projectedDependencies.keys()), projectedDependencies);\n  }\n\n  public consoleLog(indent: number = 0) {\n    process.stdout.write(' '.repeat(indent) + this + depString(this) + '\\n');\n    for (const node of this.nodes) {\n      if (node instanceof Graph) {\n        node.consoleLog(indent + 2);\n      } else {\n        process.stdout.write(' '.repeat(indent + 2) + node + depString(node) + '\\n');\n      }\n    }\n\n    function depString(node: GraphNode<A>) {\n      if (node.dependencies.length > 0) {\n        return ` -> ${Array.from(node.dependencies).join(', ')}`;\n      }\n      return '';\n    }\n  }\n\n  /**\n   * Return the union of all dependencies of the descendants of this graph\n   */\n  private deepDependencies() {\n    const ret = new Map<GraphNode<A>, Set<GraphNode<A>>>();\n    for (const node of this.nodes) {\n      recurse(node);\n    }\n    return ret;\n\n    function recurse(node: GraphNode<A>) {\n      let deps = ret.get(node);\n      if (!deps) {\n        ret.set(node, deps = new Set());\n      }\n      for (let dep of node.dependencies) {\n        deps.add(dep);\n      }\n      if (node instanceof Graph) {\n        for (const child of node.nodes) {\n          recurse(child);\n        }\n      }\n    }\n  }\n\n  /**\n   * Return all non-Graph nodes\n   */\n  public allLeaves(): GraphNodeCollection<A> {\n    const ret: GraphNode<A>[] = [];\n    recurse(this);\n    return new GraphNodeCollection(ret);\n\n    function recurse(node: GraphNode<A>) {\n      if (node instanceof Graph) {\n        for (const child of node.nodes) {\n          recurse(child);\n        }\n      } else {\n        ret.push(node);\n      }\n    }\n  }\n}\n\n/**\n * A collection of graph nodes\n */\nexport class GraphNodeCollection<A> {\n  public readonly nodes: GraphNode<A>[];\n\n  constructor(nodes: Iterable<GraphNode<A>>) {\n    this.nodes = Array.from(nodes);\n  }\n\n  public dependOn(...dependencies: Array<GraphNode<A> | undefined>) {\n    for (const node of this.nodes) {\n      node.dependOn(...dependencies.filter(isDefined));\n    }\n  }\n\n  /**\n  * Returns the graph node that's shared between these nodes\n  */\n  public commonAncestor() {\n    const paths = new Array<GraphNode<A>[]>();\n    for (const x of this.nodes) {\n      paths.push(x.rootPath());\n    }\n\n    if (paths.length === 0) {\n      throw new Error('Cannot find common ancestor between an empty set of nodes');\n    }\n    if (paths.length === 1) {\n      const path = paths[0];\n\n      if (path.length < 2) {\n        throw new Error(`Cannot find ancestor of node without ancestor: ${path[0]}`);\n      }\n      return path[path.length - 2];\n    }\n\n    const originalPaths = [...paths];\n\n    // Remove the first element of every path as long as the 2nd elements are all\n    // the same -- this leaves the shared element in first place.\n    //\n    //   A, B, C, 1, 2    }---> C\n    //   A, B, C, 3       }\n    while (paths.every(path => paths[0].length >= 2 && path.length >= 2 && path[1] === paths[0][1])) {\n      for (const path of paths) {\n        path.shift();\n      }\n    }\n\n    // If any of the paths are left with 1 element, there's no shared parent.\n    if (paths.some(path => path.length < 2)) {\n      throw new Error(`Could not determine a shared parent between nodes: ${originalPaths.map(nodes => nodes.map(n => n.id).join('/'))}`);\n    }\n\n    return paths[0][0];\n  }\n}\n\n/**\n * Dependency map of nodes in this graph, taking into account dependencies between nodes in subgraphs\n *\n * Guaranteed to return an entry in the map for every node in the current graph.\n */\nfunction projectDependencies<A>(dependencies: Map<GraphNode<A>, Set<GraphNode<A>>>, project: (x: GraphNode<A>) => GraphNode<A>[]) {\n  // Project keys\n  for (const node of dependencies.keys()) {\n    const projectedNodes = project(node);\n    if (projectedNodes.length === 1 && projectedNodes[0] === node) { continue; } // Nothing to do, just for efficiency\n\n    const deps = extract(dependencies, node)!;\n    for (const projectedNode of projectedNodes) {\n      addAll(dependencies.get(projectedNode)!, deps);\n    }\n  }\n\n  // Project values. Ignore self-dependencies, they were just between nodes that were collapsed into the same node.\n  for (const [node, deps] of dependencies.entries()) {\n    const depset = new Set(flatMap(deps, project));\n    depset.delete(node);\n    dependencies.set(node, depset);\n  }\n\n  return dependencies;\n}\n\nexport function isGraph<A>(x: GraphNode<A>): x is Graph<A> {\n  return x instanceof Graph;\n}\n"],
  "mappings": "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",
  "names": []
}
