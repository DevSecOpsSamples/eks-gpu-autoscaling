{
  "version": 3,
  "sources": ["asset-manifest.ts"],
  "sourcesContent": ["// FIXME: copied from `ckd-assets`, because this tool needs to read the asset manifest aswell.\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport { AssetManifest, AwsDestination, DockerImageDestination, DockerImageSource, FileDestination, FileSource, Manifest } from '../../../cloud-assembly-schema';\n\n/**\n * A manifest of assets\n */\nexport class AssetManifestReader {\n  /**\n   * The default name of the asset manifest in a cdk.out directory\n   */\n  public static readonly DEFAULT_FILENAME = 'assets.json';\n\n  /**\n   * Load an asset manifest from the given file\n   */\n  public static fromFile(fileName: string) {\n    try {\n      const obj = Manifest.loadAssetManifest(fileName);\n\n      return new AssetManifestReader(path.dirname(fileName), obj);\n    } catch (e) {\n      throw new Error(`Cannot read asset manifest '${fileName}': ${e.message}`);\n    }\n  }\n\n  /**\n   * Load an asset manifest from the given file or directory\n   *\n   * If the argument given is a directoy, the default asset file name will be used.\n   */\n  public static fromPath(filePath: string) {\n    let st;\n    try {\n      st = fs.statSync(filePath);\n    } catch (e) {\n      throw new Error(`Cannot read asset manifest at '${filePath}': ${e.message}`);\n    }\n    if (st.isDirectory()) {\n      return AssetManifestReader.fromFile(path.join(filePath, AssetManifestReader.DEFAULT_FILENAME));\n    }\n    return AssetManifestReader.fromFile(filePath);\n  }\n\n  /**\n   * The directory where the manifest was found\n   */\n  public readonly directory: string;\n\n  constructor(directory: string, private readonly manifest: AssetManifest) {\n    this.directory = directory;\n  }\n\n  /**\n   * Select a subset of assets and destinations from this manifest.\n   *\n   * Only assets with at least 1 selected destination are retained.\n   *\n   * If selection is not given, everything is returned.\n   */\n  public select(selection?: DestinationPattern[]): AssetManifestReader {\n    if (selection === undefined) { return this; }\n\n    const ret: AssetManifest & Required<Pick<AssetManifest, AssetType>>\n      = { version: this.manifest.version, dockerImages: {}, files: {} };\n\n    for (const assetType of ASSET_TYPES) {\n      for (const [assetId, asset] of Object.entries(this.manifest[assetType] || {})) {\n        const filteredDestinations = filterDict(\n          asset.destinations,\n          (_, destId) => selection.some(sel => sel.matches(new DestinationIdentifier(assetId, destId))));\n\n        if (Object.keys(filteredDestinations).length > 0) {\n          ret[assetType][assetId] = {\n            ...asset,\n            destinations: filteredDestinations,\n          };\n        }\n      }\n    }\n\n    return new AssetManifestReader(this.directory, ret);\n  }\n\n  /**\n   * Describe the asset manifest as a list of strings\n   */\n  public list() {\n    return [\n      ...describeAssets('file', this.manifest.files || {}),\n      ...describeAssets('docker-image', this.manifest.dockerImages || {}),\n    ];\n\n    function describeAssets(type: string, assets: Record<string, { source: any, destinations: Record<string, any> }>) {\n      const ret = new Array<string>();\n      for (const [assetId, asset] of Object.entries(assets || {})) {\n        ret.push(`${assetId} ${type} ${JSON.stringify(asset.source)}`);\n\n        const destStrings = Object.entries(asset.destinations).map(([destId, dest]) => ` ${assetId}:${destId} ${JSON.stringify(dest)}`);\n        ret.push(...prefixTreeChars(destStrings, '  '));\n      }\n      return ret;\n    }\n  }\n\n  /**\n   * List of assets, splat out to destinations\n   */\n  public get entries(): IManifestEntry[] {\n    return [\n      ...makeEntries(this.manifest.files || {}, FileManifestEntry),\n      ...makeEntries(this.manifest.dockerImages || {}, DockerImageManifestEntry),\n    ];\n\n    function makeEntries<A, B, C>(\n      assets: Record<string, { source: A, destinations: Record<string, B> }>,\n      ctor: new (id: DestinationIdentifier, source: A, destination: B) => C): C[] {\n\n      const ret = new Array<C>();\n      for (const [assetId, asset] of Object.entries(assets)) {\n        for (const [destId, destination] of Object.entries(asset.destinations)) {\n          ret.push(new ctor(new DestinationIdentifier(assetId, destId), asset.source, destination));\n        }\n      }\n      return ret;\n    }\n  }\n}\n\ntype AssetType = 'files' | 'dockerImages';\n\nconst ASSET_TYPES: AssetType[] = ['files', 'dockerImages'];\n\n/**\n * A single asset from an asset manifest'\n */\nexport interface IManifestEntry {\n  /**\n   * The identifier of the asset\n   */\n  readonly id: DestinationIdentifier;\n\n  /**\n   * The type of asset\n   */\n  readonly type: string;\n\n  /**\n   * Type-dependent source data\n   */\n  readonly genericSource: unknown;\n\n  /**\n   * Type-dependent destination data\n   */\n  readonly destination: AwsDestination;\n}\n\n/**\n * A manifest entry for a file asset\n */\nexport class FileManifestEntry implements IManifestEntry {\n  public readonly genericSource: unknown;\n  public readonly type = 'file';\n\n  constructor(\n    /** Identifier for this asset */\n    public readonly id: DestinationIdentifier,\n    /** Source of the file asset */\n    public readonly source: FileSource,\n    /** Destination for the file asset */\n    public readonly destination: FileDestination,\n  ) {\n    this.genericSource = source;\n  }\n}\n\n/**\n * A manifest entry for a docker image asset\n */\nexport class DockerImageManifestEntry implements IManifestEntry {\n  public readonly genericSource: unknown;\n  public readonly type = 'docker-image';\n\n  constructor(\n    /** Identifier for this asset */\n    public readonly id: DestinationIdentifier,\n    /** Source of the file asset */\n    public readonly source: DockerImageSource,\n    /** Destination for the file asset */\n    public readonly destination: DockerImageDestination,\n  ) {\n    this.genericSource = source;\n  }\n}\n\n/**\n * Identify an asset destination in an asset manifest\n */\nexport class DestinationIdentifier {\n  /**\n   * Identifies the asset, by source.\n   */\n  public readonly assetId: string;\n\n  /**\n   * Identifies the destination where this asset will be published\n   */\n  public readonly destinationId: string;\n\n  constructor(assetId: string, destinationId: string) {\n    this.assetId = assetId;\n    this.destinationId = destinationId;\n  }\n\n  /**\n   * Return a string representation for this asset identifier\n   */\n  public toString() {\n    return this.destinationId ? `${this.assetId}:${this.destinationId}` : this.assetId;\n  }\n}\n\nfunction filterDict<A>(xs: Record<string, A>, pred: (x: A, key: string) => boolean): Record<string, A> {\n  const ret: Record<string, A> = {};\n  for (const [key, value] of Object.entries(xs)) {\n    if (pred(value, key)) {\n      ret[key] = value;\n    }\n  }\n  return ret;\n}\n\n/**\n * A filter pattern for an destination identifier\n */\nexport class DestinationPattern {\n  /**\n   * Parse a ':'-separated string into an asset/destination identifier\n   */\n  public static parse(s: string) {\n    if (!s) { throw new Error('Empty string is not a valid destination identifier'); }\n    const parts = s.split(':').map(x => x !== '*' ? x : undefined);\n    if (parts.length === 1) { return new DestinationPattern(parts[0]); }\n    if (parts.length === 2) { return new DestinationPattern(parts[0] || undefined, parts[1] || undefined); }\n    throw new Error(`Asset identifier must contain at most 2 ':'-separated parts, got '${s}'`);\n  }\n\n  /**\n   * Identifies the asset, by source.\n   */\n  public readonly assetId?: string;\n\n  /**\n   * Identifies the destination where this asset will be published\n   */\n  public readonly destinationId?: string;\n\n  constructor(assetId?: string, destinationId?: string) {\n    this.assetId = assetId;\n    this.destinationId = destinationId;\n  }\n\n  /**\n   * Whether or not this pattern matches the given identifier\n   */\n  public matches(id: DestinationIdentifier) {\n    return (this.assetId === undefined || this.assetId === id.assetId)\n      && (this.destinationId === undefined || this.destinationId === id.destinationId);\n  }\n\n  /**\n   * Return a string representation for this asset identifier\n   */\n  public toString() {\n    return `${this.assetId ?? '*'}:${this.destinationId ?? '*'}`;\n  }\n}\n\n/**\n * Prefix box-drawing characters to make lines look like a hanging tree\n */\nfunction prefixTreeChars(xs: string[], prefix = '') {\n  const ret = new Array<string>();\n  for (let i = 0; i < xs.length; i++) {\n    const isLast = i === xs.length - 1;\n    const boxChar = isLast ? '\u2514' : '\u251C';\n    ret.push(`${prefix}${boxChar}${xs[i]}`);\n  }\n  return ret;\n}\n"],
  "mappings": "2NACA,KAAA,IAAA,QAAA,IAAA,EACA,KAAA,QAAA,MAAA,EACA,wBAAA,QAAA,gCAAA,EAKA,MAAa,mBAAmB,CA0C9B,YAAY,UAAoC,SAAuB,CAAvB,KAAA,SAAA,SAC9C,KAAK,UAAY,gBAlCL,UAAS,SAAgB,CACrC,GAAI,CACF,KAAM,KAAM,wBAAA,SAAS,kBAAkB,QAAQ,EAE/C,MAAO,IAAI,qBAAoB,KAAK,QAAQ,QAAQ,EAAG,GAAG,QACnD,EAAP,CACA,KAAM,IAAI,OAAM,+BAA+B,cAAc,EAAE,SAAS,SAS9D,UAAS,SAAgB,CACrC,GAAI,IACJ,GAAI,CACF,GAAK,GAAG,SAAS,QAAQ,QAClB,EAAP,CACA,KAAM,IAAI,OAAM,kCAAkC,cAAc,EAAE,SAAS,EAE7E,MAAI,IAAG,YAAW,EACT,oBAAoB,SAAS,KAAK,KAAK,SAAU,oBAAoB,gBAAgB,CAAC,EAExF,oBAAoB,SAAS,QAAQ,EAmBvC,OAAO,UAAgC,CAC5C,GAAI,YAAc,OAAa,MAAO,MAEtC,KAAM,KACF,CAAE,QAAS,KAAK,SAAS,QAAS,aAAc,CAAA,EAAI,MAAO,CAAA,CAAE,EAEjE,SAAW,aAAa,aACtB,SAAW,CAAC,QAAS,QAAU,QAAO,QAAQ,KAAK,SAAS,YAAc,CAAA,CAAE,EAAG,CAC7E,KAAM,sBAAuB,WAC3B,MAAM,aACN,CAAC,EAAG,SAAW,UAAU,KAAK,KAAO,IAAI,QAAQ,GAAI,uBAAsB,QAAS,MAAM,CAAC,CAAC,CAAC,EAE/F,AAAI,OAAO,KAAK,oBAAoB,EAAE,OAAS,GAC7C,KAAI,WAAW,SAAW,IACrB,MACH,aAAc,uBAMtB,MAAO,IAAI,qBAAoB,KAAK,UAAW,GAAG,EAM7C,MAAI,CACT,MAAO,CACL,GAAG,eAAe,OAAQ,KAAK,SAAS,OAAS,CAAA,CAAE,EACnD,GAAG,eAAe,eAAgB,KAAK,SAAS,cAAgB,CAAA,CAAE,GAGpE,wBAAwB,KAAc,OAA0E,CAC9G,KAAM,KAAM,GAAI,OAChB,SAAW,CAAC,QAAS,QAAU,QAAO,QAAQ,QAAU,CAAA,CAAE,EAAG,CAC3D,IAAI,KAAK,GAAG,WAAW,QAAQ,KAAK,UAAU,MAAM,MAAM,GAAG,EAE7D,KAAM,aAAc,OAAO,QAAQ,MAAM,YAAY,EAAE,IAAI,CAAC,CAAC,OAAQ,QAAU,IAAI,WAAW,UAAU,KAAK,UAAU,IAAI,GAAG,EAC9H,IAAI,KAAK,GAAG,gBAAgB,YAAa,IAAI,CAAC,EAEhD,MAAO,IACT,KAMS,UAAO,CAChB,MAAO,CACL,GAAG,YAAY,KAAK,SAAS,OAAS,CAAA,EAAI,iBAAiB,EAC3D,GAAG,YAAY,KAAK,SAAS,cAAgB,CAAA,EAAI,wBAAwB,GAG3E,qBACE,OACA,KAAqE,CAErE,KAAM,KAAM,GAAI,OAChB,SAAW,CAAC,QAAS,QAAU,QAAO,QAAQ,MAAM,EAClD,SAAW,CAAC,OAAQ,cAAgB,QAAO,QAAQ,MAAM,YAAY,EACnE,IAAI,KAAK,GAAI,MAAK,GAAI,uBAAsB,QAAS,MAAM,EAAG,MAAM,OAAQ,WAAW,CAAC,EAG5F,MAAO,IACT,GAtHJ,QAAA,oBAAA,oBAIyB,oBAAA,iBAAmB,cAwH5C,KAAM,aAA2B,CAAC,QAAS,cAAc,EA8BzD,MAAa,iBAAiB,CAI5B,YAEkB,GAEA,OAEA,YAA4B,CAJ5B,KAAA,GAAA,GAEA,KAAA,OAAA,OAEA,KAAA,YAAA,YARF,KAAA,KAAO,OAUrB,KAAK,cAAgB,QAZzB,QAAA,kBAAA,kBAmBA,MAAa,wBAAwB,CAInC,YAEkB,GAEA,OAEA,YAAmC,CAJnC,KAAA,GAAA,GAEA,KAAA,OAAA,OAEA,KAAA,YAAA,YARF,KAAA,KAAO,eAUrB,KAAK,cAAgB,QAZzB,QAAA,yBAAA,yBAmBA,MAAa,qBAAqB,CAWhC,YAAY,QAAiB,cAAqB,CAChD,KAAK,QAAU,QACf,KAAK,cAAgB,cAMhB,UAAQ,CACb,MAAO,MAAK,cAAgB,GAAG,KAAK,WAAW,KAAK,gBAAkB,KAAK,SApB/E,QAAA,sBAAA,sBAwBA,oBAAuB,GAAuB,KAAoC,CAChF,KAAM,KAAyB,CAAA,EAC/B,SAAW,CAAC,IAAK,QAAU,QAAO,QAAQ,EAAE,EAC1C,AAAI,KAAK,MAAO,GAAG,GACjB,KAAI,KAAO,OAGf,MAAO,IACT,CAKA,MAAa,kBAAkB,CAsB7B,YAAY,QAAkB,cAAsB,CAClD,KAAK,QAAU,QACf,KAAK,cAAgB,oBApBT,OAAM,EAAS,CAC3B,GAAI,CAAC,EAAK,KAAM,IAAI,OAAM,oDAAoD,EAC9E,KAAM,OAAQ,EAAE,MAAM,GAAG,EAAE,IAAI,GAAK,IAAM,IAAM,EAAI,MAAS,EAC7D,GAAI,MAAM,SAAW,EAAK,MAAO,IAAI,oBAAmB,MAAM,EAAE,EAChE,GAAI,MAAM,SAAW,EAAK,MAAO,IAAI,oBAAmB,MAAM,IAAM,OAAW,MAAM,IAAM,MAAS,EACpG,KAAM,IAAI,OAAM,qEAAqE,IAAI,EAqBpF,QAAQ,GAAyB,CACtC,MAAQ,MAAK,UAAY,QAAa,KAAK,UAAY,GAAG,UACpD,MAAK,gBAAkB,QAAa,KAAK,gBAAkB,GAAG,eAM/D,UAAQ,WACb,MAAO,GAAG,IAAA,KAAK,WAAO,MAAA,KAAA,OAAA,GAAI,OAAO,IAAA,KAAK,iBAAa,MAAA,KAAA,OAAA,GAAI,OAvC3D,QAAA,mBAAA,mBA8CA,yBAAyB,GAAc,OAAS,GAAE,CAChD,KAAM,KAAM,GAAI,OAChB,OAAS,GAAI,EAAG,EAAI,GAAG,OAAQ,IAAK,CAElC,KAAM,SAAU,AADD,IAAM,GAAG,OAAS,EACR,SAAM,SAC/B,IAAI,KAAK,GAAG,SAAS,UAAU,GAAG,IAAI,EAExC,MAAO,IACT",
  "names": []
}
