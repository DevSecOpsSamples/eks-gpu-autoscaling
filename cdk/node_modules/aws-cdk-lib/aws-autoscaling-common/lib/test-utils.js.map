{
  "version": 3,
  "sources": ["test-utils.ts"],
  "sourcesContent": ["import * as appscaling from '../lib';\n\n/**\n * Arbitrary (valid) array of intervals\n *\n * There are many invalid combinations of interval arrays, so we have\n * to be very specific about generating arrays that are valid. We do this\n * by taking a full, valid interval schedule and progressively stripping parts\n * away from it.\n *\n * Some of the changes may change its meaning, but we take care to never leave\n * a schedule with insufficient information so that the parser will error out.\n */\nexport function generateArbitraryIntervals(mrng: IRandomGenerator): ArbitraryIntervals {\n  const ret = new Array<appscaling.ScalingInterval>();\n\n  const absolute = mrng.nextBoolean();\n\n  // Ascending or descending scaling\n  const factor = (mrng.nextBoolean() ? 1 : -1) * (absolute ? 10 : 1);\n  const bias = absolute ? 50 : 0;\n\n  // Begin with a full schedule\n  ret.push({ lower: 0, upper: 10, change: -2 * factor + bias });\n  ret.push({ lower: 10, upper: 20, change: -1 * factor + bias });\n  ret.push({ lower: 20, upper: 60, change: 0 + bias });\n  ret.push({ lower: 60, upper: 80, change: 0 + bias });\n  ret.push({ lower: 80, upper: 90, change: 1 * factor + bias });\n  ret.push({ lower: 90, upper: Infinity, change: 2 * factor + bias });\n\n  // Take away parts from this. First we see if we do something to the 0-change alarms.\n  // The actions can be: remove it OR turn it into a regular change value.\n  const noChanges = ret.filter(x => x.change === bias);\n\n  if (!absolute) {\n    if (mrng.nextBoolean()) {\n      if (mrng.nextBoolean()) {\n        ret.splice(ret.indexOf(noChanges[0]), 1);\n      } else {\n        noChanges[0] = { ...noChanges[0], change: -1 * factor + bias };\n      }\n    }\n    if (mrng.nextBoolean()) {\n      if (mrng.nextBoolean()) {\n        ret.splice(ret.indexOf(noChanges[1]), 1);\n      } else {\n        noChanges[1] = { ...noChanges[1], change: 1 * factor + bias };\n      }\n    }\n  } else {\n    // In absolute mode both have to get the same treatment at the same time\n    // otherwise we'll end up with a timeline with two gaps\n    if (mrng.nextBoolean()) {\n      ret.splice(ret.indexOf(noChanges[0]), 1);\n      ret.splice(ret.indexOf(noChanges[1]), 1);\n    } else {\n      noChanges[0] = { ...noChanges[0], change: -1 * factor + bias };\n      noChanges[1] = { ...noChanges[1], change: 1 * factor + bias };\n    }\n  }\n\n  // We might also take away either the bottom or the upper half\n  if (mrng.nextInt(0, 2) === 0) {\n    const signToStrip = mrng.nextBoolean() ? -1 : 1;\n    let ix = ret.findIndex(x => Math.sign(x.change - bias) === signToStrip);\n    while (ix >= 0) {\n      ret.splice(ix, 1);\n      ix = ret.findIndex(x => Math.sign(x.change - bias) === signToStrip);\n    }\n  }\n\n  // Then we're going to arbitrarily get rid of bounds in the most naive way possible\n  const iterations = mrng.nextInt(0, 10);\n  for (let iter = 0; iter < iterations; iter++) {\n    const i = mrng.nextInt(0, ret.length - 1);\n    if (mrng.nextBoolean()) {\n      // scrap lower bound\n      // okay if current interval has an upper bound AND the preceding interval has an upper bound\n      if (ret[i].upper !== undefined && (i === 0 || ret[i - 1].upper !== undefined)) {\n        ret[i] = { ...ret[i], lower: undefined };\n      }\n    } else {\n      // scrap upper bound\n      // okay if current interval has a lower bound AND the succeeding interval has a lower bound\n      if (ret[i].lower !== undefined && (i === ret.length - 1 || ret[i + 1].lower !== undefined)) {\n        ret[i] = { ...ret[i], upper: undefined };\n      }\n    }\n  }\n\n  return { absolute, intervals: ret };\n}\n\nexport interface IRandomGenerator {\n  nextBoolean(): boolean;\n  nextInt(min: number, max: number): number;\n}\n\nexport interface ArbitraryIntervals {\n  readonly absolute: boolean;\n  readonly intervals: appscaling.ScalingInterval[];\n}\n"],
  "mappings": "8GAaA,oCAA2C,KAAsB,CAC/D,KAAM,KAAM,GAAI,OAEV,SAAW,KAAK,YAAW,EAG3B,OAAU,MAAK,YAAW,EAAK,EAAI,IAAO,UAAW,GAAK,GAC1D,KAAO,SAAW,GAAK,EAG7B,IAAI,KAAK,CAAE,MAAO,EAAG,MAAO,GAAI,OAAQ,GAAK,OAAS,IAAI,CAAE,EAC5D,IAAI,KAAK,CAAE,MAAO,GAAI,MAAO,GAAI,OAAQ,GAAK,OAAS,IAAI,CAAE,EAC7D,IAAI,KAAK,CAAE,MAAO,GAAI,MAAO,GAAI,OAAQ,EAAI,IAAI,CAAE,EACnD,IAAI,KAAK,CAAE,MAAO,GAAI,MAAO,GAAI,OAAQ,EAAI,IAAI,CAAE,EACnD,IAAI,KAAK,CAAE,MAAO,GAAI,MAAO,GAAI,OAAQ,EAAI,OAAS,IAAI,CAAE,EAC5D,IAAI,KAAK,CAAE,MAAO,GAAI,MAAO,IAAU,OAAQ,EAAI,OAAS,IAAI,CAAE,EAIlE,KAAM,WAAY,IAAI,OAAO,GAAK,EAAE,SAAW,IAAI,EA8BnD,GA5BA,AAAK,SAkBH,AAAI,KAAK,YAAW,EAClB,KAAI,OAAO,IAAI,QAAQ,UAAU,EAAE,EAAG,CAAC,EACvC,IAAI,OAAO,IAAI,QAAQ,UAAU,EAAE,EAAG,CAAC,GAEvC,WAAU,GAAK,IAAK,UAAU,GAAI,OAAQ,GAAK,OAAS,IAAI,EAC5D,UAAU,GAAK,IAAK,UAAU,GAAI,OAAQ,EAAI,OAAS,IAAI,GAtBzD,MAAK,YAAW,GAClB,CAAI,KAAK,YAAW,EAClB,IAAI,OAAO,IAAI,QAAQ,UAAU,EAAE,EAAG,CAAC,EAEvC,UAAU,GAAK,IAAK,UAAU,GAAI,OAAQ,GAAK,OAAS,IAAI,GAG5D,KAAK,YAAW,GAClB,CAAI,KAAK,YAAW,EAClB,IAAI,OAAO,IAAI,QAAQ,UAAU,EAAE,EAAG,CAAC,EAEvC,UAAU,GAAK,IAAK,UAAU,GAAI,OAAQ,EAAI,OAAS,IAAI,IAgB7D,KAAK,QAAQ,EAAG,CAAC,IAAM,EAAG,CAC5B,KAAM,aAAc,KAAK,YAAW,EAAK,GAAK,EAC9C,GAAI,IAAK,IAAI,UAAU,GAAK,KAAK,KAAK,EAAE,OAAS,IAAI,IAAM,WAAW,EACtE,KAAO,IAAM,GACX,IAAI,OAAO,GAAI,CAAC,EAChB,GAAK,IAAI,UAAU,GAAK,KAAK,KAAK,EAAE,OAAS,IAAI,IAAM,WAAW,EAKtE,KAAM,YAAa,KAAK,QAAQ,EAAG,EAAE,EACrC,OAAS,MAAO,EAAG,KAAO,WAAY,OAAQ,CAC5C,KAAM,GAAI,KAAK,QAAQ,EAAG,IAAI,OAAS,CAAC,EACxC,AAAI,KAAK,YAAW,EAGd,IAAI,GAAG,QAAU,QAAc,KAAM,GAAK,IAAI,EAAI,GAAG,QAAU,SACjE,KAAI,GAAK,IAAK,IAAI,GAAI,MAAO,MAAS,GAKpC,IAAI,GAAG,QAAU,QAAc,KAAM,IAAI,OAAS,GAAK,IAAI,EAAI,GAAG,QAAU,SAC9E,KAAI,GAAK,IAAK,IAAI,GAAI,MAAO,MAAS,GAK5C,MAAO,CAAE,SAAU,UAAW,GAAG,CACnC,CA9EA,QAAA,2BAAA",
  "names": []
}
