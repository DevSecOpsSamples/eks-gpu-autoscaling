{
  "version": 3,
  "sources": ["outputs.ts"],
  "sourcesContent": ["import { filterLogicalId, formatFailure, matchSection } from './section';\nimport { Template } from './template';\n\nexport function findOutputs(template: Template, logicalId: string, props: any = {}): { [key: string]: { [key: string]: any } } {\n  const section = template.Outputs ?? {};\n  const result = matchSection(filterLogicalId(section, logicalId), props);\n\n  if (!result.match) {\n    return {};\n  }\n\n  return result.matches;\n}\n\nexport function hasOutput(template: Template, logicalId: string, props: any): string | void {\n  const section: { [key: string]: {} } = template.Outputs ?? {};\n  const result = matchSection(filterLogicalId(section, logicalId), props);\n  if (result.match) {\n    return;\n  }\n\n  if (result.closestResult === undefined) {\n    return `No outputs named ${logicalId} found in the template.`;\n  }\n\n  return [\n    `Template has ${result.analyzedCount} outputs named ${logicalId}, but none match as expected.`,\n    formatFailure(result.closestResult),\n  ].join('\\n');\n}\n"],
  "mappings": "iHAAA,KAAA,WAAA,QAAA,WAAA,EAGA,qBAA4B,SAAoB,UAAmB,MAAa,CAAA,EAAE,QAChF,KAAM,SAAO,IAAG,SAAS,WAAO,MAAA,KAAA,OAAA,GAAI,CAAA,EAC9B,OAAS,UAAA,aAAa,UAAA,gBAAgB,QAAS,SAAS,EAAG,KAAK,EAEtE,MAAK,QAAO,MAIL,OAAO,QAHL,CAAA,CAIX,CATA,QAAA,YAAA,YAWA,mBAA0B,SAAoB,UAAmB,MAAU,QACzE,KAAM,SAAO,IAA0B,SAAS,WAAO,MAAA,KAAA,OAAA,GAAI,CAAA,EACrD,OAAS,UAAA,aAAa,UAAA,gBAAgB,QAAS,SAAS,EAAG,KAAK,EACtE,GAAI,QAAO,MAIX,MAAI,QAAO,gBAAkB,OACpB,oBAAoB,mCAGtB,CACL,gBAAgB,OAAO,+BAA+B,yCACtD,UAAA,cAAc,OAAO,aAAa,GAClC,KAAK;CAAI,CACb,CAfA,QAAA,UAAA",
  "names": []
}
