{
  "version": 3,
  "sources": ["messages.ts"],
  "sourcesContent": ["import { SynthesisMessage } from '../../../cx-api';\nimport { Messages } from './message';\nimport { formatAllMatches, formatFailure, matchSection } from './section';\n\nexport function findMessage(messages: Messages, constructPath: string, props: any = {}): { [key: string]: { [key: string]: any } } {\n  const section: { [key: string]: SynthesisMessage } = messages;\n  const result = matchSection(filterPath(section, constructPath), props);\n\n  if (!result.match) {\n    return {};\n  }\n\n  return result.matches;\n}\n\nexport function hasMessage(messages: Messages, constructPath: string, props: any): string | void {\n  const section: { [key: string]: SynthesisMessage } = messages;\n  const result = matchSection(filterPath(section, constructPath), props);\n\n  if (result.match) {\n    return;\n  }\n\n  if (result.closestResult === undefined) {\n    return 'No messages found in the stack';\n  }\n\n  handleTrace(result.closestResult.target);\n  return [\n    `Stack has ${result.analyzedCount} messages, but none match as expected.`,\n    formatFailure(result.closestResult),\n  ].join('\\n');\n}\n\nexport function hasNoMessage(messages: Messages, constructPath: string, props: any): string | void {\n  const section: { [key: string]: SynthesisMessage } = messages;\n  const result = matchSection(filterPath(section, constructPath), props);\n\n  if (!result.match) {\n    return;\n  }\n\n  return [\n    `Expected no matches, but stack has ${Object.keys(result.matches).length} messages as follows:`,\n    formatAllMatches(result.matches),\n  ].join('\\n');\n}\n\n// We redact the stack trace by default because it is unnecessarily long and unintelligible.\n// If there is a use case for rendering the trace, we can add it later.\nfunction handleTrace(match: any, redact: boolean = true): void {\n  if (redact && match.entry?.trace !== undefined) {\n    match.entry.trace = 'redacted';\n  };\n}\n\nfunction filterPath(section: { [key: string]: SynthesisMessage }, path: string): { [key: string]: SynthesisMessage } {\n  // default signal for all paths is '*'\n  if (path === '*') return section;\n\n  return Object.entries(section ?? {})\n    .filter(([_, v]) => v.id === path)\n    .reduce((agg, [k, v]) => { return { ...agg, [k]: v }; }, {});\n}\n"],
  "mappings": "uIAEA,KAAA,WAAA,QAAA,WAAA,EAEA,qBAA4B,SAAoB,cAAuB,MAAa,CAAA,EAAE,CACpF,KAAM,SAA+C,SAC/C,OAAS,UAAA,aAAa,WAAW,QAAS,aAAa,EAAG,KAAK,EAErE,MAAK,QAAO,MAIL,OAAO,QAHL,CAAA,CAIX,CATA,QAAA,YAAA,YAWA,oBAA2B,SAAoB,cAAuB,MAAU,CAC9E,KAAM,SAA+C,SAC/C,OAAS,UAAA,aAAa,WAAW,QAAS,aAAa,EAAG,KAAK,EAErE,GAAI,QAAO,MAIX,MAAI,QAAO,gBAAkB,OACpB,iCAGT,aAAY,OAAO,cAAc,MAAM,EAChC,CACL,aAAa,OAAO,sDACpB,UAAA,cAAc,OAAO,aAAa,GAClC,KAAK;CAAI,EACb,CAjBA,QAAA,WAAA,WAmBA,sBAA6B,SAAoB,cAAuB,MAAU,CAChF,KAAM,SAA+C,SAC/C,OAAS,UAAA,aAAa,WAAW,QAAS,aAAa,EAAG,KAAK,EAErE,GAAI,EAAC,OAAO,MAIZ,MAAO,CACL,sCAAsC,OAAO,KAAK,OAAO,OAAO,EAAE,8BAClE,UAAA,iBAAiB,OAAO,OAAO,GAC/B,KAAK;CAAI,CACb,CAZA,QAAA,aAAA,aAgBA,qBAAqB,MAAY,OAAkB,GAAI,QACrD,AAAI,QAAU,KAAA,MAAM,SAAK,MAAA,KAAA,OAAA,OAAA,GAAE,SAAU,QACnC,OAAM,MAAM,MAAQ,WAExB,CAEA,oBAAoB,QAA8C,KAAY,CAE5E,MAAI,QAAS,IAAY,QAElB,OAAO,QAAQ,SAAO,KAAP,QAAW,CAAA,CAAE,EAChC,OAAO,CAAC,CAAC,EAAG,KAAO,EAAE,KAAO,IAAI,EAChC,OAAO,CAAC,IAAK,CAAC,EAAG,KAAgB,KAAK,KAAM,GAAI,CAAC,GAAO,CAAA,CAAE,CAC/D",
  "names": []
}
