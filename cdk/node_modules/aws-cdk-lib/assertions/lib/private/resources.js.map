{
  "version": 3,
  "sources": ["resources.ts"],
  "sourcesContent": ["import { Match, Matcher } from '..';\nimport { AbsentMatch } from './matchers/absent';\nimport { formatFailure, matchSection } from './section';\nimport { Resource, Template } from './template';\n\nexport function findResources(template: Template, type: string, props: any = {}): { [key: string]: { [key: string]: any } } {\n  const section = template.Resources ?? {};\n  const result = matchSection(filterType(section, type), props);\n\n  if (!result.match) {\n    return {};\n  }\n\n  return result.matches;\n}\n\nexport function hasResource(template: Template, type: string, props: any): string | void {\n  const section = template.Resources ?? {};\n  const result = matchSection(filterType(section, type), props);\n  if (result.match) {\n    return;\n  }\n\n  if (result.closestResult === undefined) {\n    return `No resource with type ${type} found`;\n  }\n\n  return [\n    `Template has ${result.analyzedCount} resources with type ${type}, but none match as expected.`,\n    formatFailure(result.closestResult),\n  ].join('\\n');\n}\n\nexport function hasResourceProperties(template: Template, type: string, props: any): string | void {\n  // amended needs to be a deep copy to avoid modifying the template.\n  let amended = JSON.parse(JSON.stringify(template));\n\n  // special case to exclude AbsentMatch because adding an empty Properties object will affect its evaluation.\n  if (!Matcher.isMatcher(props) || !(props instanceof AbsentMatch)) {\n    amended = addEmptyProperties(amended);\n  }\n\n  return hasResource(amended, type, Match.objectLike({\n    Properties: props,\n  }));\n}\n\nexport function countResources(template: Template, type: string): number {\n  const section = template.Resources ?? {};\n  const types = filterType(section, type);\n\n  return Object.entries(types).length;\n}\n\nfunction addEmptyProperties(template: Template): Template {\n  let section = template.Resources ?? {};\n\n  Object.keys(section).map((key) => {\n    if (!section[key].hasOwnProperty('Properties')) {\n      section[key].Properties = {};\n    }\n  });\n\n  return template;\n}\n\nfunction filterType(section: { [key: string]: Resource }, type: string): { [key: string]: Resource } {\n  return Object.entries(section ?? {})\n    .filter(([_, v]) => v.Type === type)\n    .reduce((agg, [k, v]) => { return { ...agg, [k]: v }; }, {});\n}"],
  "mappings": "0KAAA,KAAA,KAAA,QAAA,IAAA,EACA,SAAA,QAAA,mBAAA,EACA,UAAA,QAAA,WAAA,EAGA,uBAA8B,SAAoB,KAAc,MAAa,CAAA,EAAE,QAC7E,KAAM,SAAO,IAAG,SAAS,aAAS,MAAA,KAAA,OAAA,GAAI,CAAA,EAChC,OAAS,UAAA,aAAa,WAAW,QAAS,IAAI,EAAG,KAAK,EAE5D,MAAK,QAAO,MAIL,OAAO,QAHL,CAAA,CAIX,CATA,QAAA,cAAA,cAWA,qBAA4B,SAAoB,KAAc,MAAU,QACtE,KAAM,SAAO,IAAG,SAAS,aAAS,MAAA,KAAA,OAAA,GAAI,CAAA,EAChC,OAAS,UAAA,aAAa,WAAW,QAAS,IAAI,EAAG,KAAK,EAC5D,GAAI,QAAO,MAIX,MAAI,QAAO,gBAAkB,OACpB,yBAAyB,aAG3B,CACL,gBAAgB,OAAO,qCAAqC,oCAC5D,UAAA,cAAc,OAAO,aAAa,GAClC,KAAK;CAAI,CACb,CAfA,QAAA,YAAA,YAiBA,+BAAsC,SAAoB,KAAc,MAAU,CAEhF,GAAI,SAAU,KAAK,MAAM,KAAK,UAAU,QAAQ,CAAC,EAGjD,MAAI,EAAC,IAAA,QAAQ,UAAU,KAAK,GAAK,CAAE,iBAAiB,UAAA,eAClD,SAAU,mBAAmB,OAAO,GAG/B,YAAY,QAAS,KAAM,IAAA,MAAM,WAAW,CACjD,WAAY,MACb,CAAC,CACJ,CAZA,QAAA,sBAAA,sBAcA,wBAA+B,SAAoB,KAAY,QAC7D,KAAM,SAAO,IAAG,SAAS,aAAS,MAAA,KAAA,OAAA,GAAI,CAAA,EAChC,MAAQ,WAAW,QAAS,IAAI,EAEtC,MAAO,QAAO,QAAQ,KAAK,EAAE,MAC/B,CALA,QAAA,eAAA,eAOA,4BAA4B,SAAkB,QAC5C,GAAI,SAAO,IAAG,SAAS,aAAS,MAAA,KAAA,OAAA,GAAI,CAAA,EAEpC,cAAO,KAAK,OAAO,EAAE,IAAI,AAAC,KAAO,CAC/B,AAAK,QAAQ,KAAK,eAAe,YAAY,GAC3C,SAAQ,KAAK,WAAa,CAAA,EAE9B,CAAC,EAEM,QACT,CAEA,oBAAoB,QAAsC,KAAY,CACpE,MAAO,QAAO,QAAQ,SAAO,KAAP,QAAW,CAAA,CAAE,EAChC,OAAO,CAAC,CAAC,EAAG,KAAO,EAAE,OAAS,IAAI,EAClC,OAAO,CAAC,IAAK,CAAC,EAAG,KAAgB,KAAK,KAAM,GAAI,CAAC,GAAO,CAAA,CAAE,CAC/D",
  "names": []
}
