{
  "version": 3,
  "sources": ["section.ts"],
  "sourcesContent": ["import { Match } from '../match';\nimport { Matcher, MatchResult } from '../matcher';\n\nexport type MatchSuccess = { match: true, matches: {[key: string]: any} };\nexport type MatchFailure = { match: false, closestResult?: MatchResult, analyzedCount: number };\n\nexport function matchSection(section: any, props: any): MatchSuccess | MatchFailure {\n  const matcher = Matcher.isMatcher(props) ? props : Match.objectLike(props);\n  let closestResult: MatchResult | undefined = undefined;\n  let matching: {[key: string]: any} = {};\n  let count = 0;\n\n  eachEntryInSection(\n    section,\n\n    (logicalId, entry) => {\n      const result = matcher.test(entry);\n      result.finished();\n      if (!result.hasFailed()) {\n        matching[logicalId] = entry;\n      } else {\n        count++;\n        if (closestResult === undefined || closestResult.failCount > result.failCount) {\n          closestResult = result;\n        }\n      }\n    },\n  );\n  if (Object.keys(matching).length > 0) {\n    return { match: true, matches: matching };\n  } else {\n    return { match: false, closestResult, analyzedCount: count };\n  }\n}\n\nfunction eachEntryInSection(\n  section: any,\n  cb: (logicalId: string, entry: {[key: string]: any}) => void): void {\n\n  for (const logicalId of Object.keys(section ?? {})) {\n    const resource: { [key: string]: any } = section[logicalId];\n    cb(logicalId, resource);\n  }\n}\n\nexport function formatAllMatches(matches: {[key: string]: any}): string {\n  return [\n    leftPad(JSON.stringify(matches, undefined, 2)),\n  ].join('\\n');\n}\n\nexport function formatFailure(closestResult: MatchResult): string {\n  return [\n    'The closest result is:',\n    leftPad(JSON.stringify(closestResult.target, undefined, 2)),\n    'with the following mismatches:',\n    ...closestResult.toHumanStrings().map(s => `\\t${s}`),\n  ].join('\\n');\n}\n\nfunction leftPad(x: string, indent: number = 2): string {\n  const pad = ' '.repeat(indent);\n  return pad + x.split('\\n').join(`\\n${pad}`);\n}\n\nexport function filterLogicalId(section: { [key: string]: {} }, logicalId: string): { [key: string]: {} } {\n  // default signal for all logicalIds is '*'\n  if (logicalId === '*') return section;\n\n  return Object.entries(section ?? {})\n    .filter(([k, _]) => k === logicalId)\n    .reduce((agg, [k, v]) => { return { ...agg, [k]: v }; }, {});\n}\n"],
  "mappings": "uKAAA,KAAA,SAAA,QAAA,UAAA,EACA,UAAA,QAAA,YAAA,EAKA,sBAA6B,QAAc,MAAU,CACnD,KAAM,SAAU,UAAA,QAAQ,UAAU,KAAK,EAAI,MAAQ,QAAA,MAAM,WAAW,KAAK,EACzE,GAAI,eACA,SAAiC,CAAA,EACjC,MAAQ,EAkBZ,MAhBA,oBACE,QAEA,CAAC,UAAW,QAAS,CACnB,KAAM,QAAS,QAAQ,KAAK,KAAK,EACjC,OAAO,SAAQ,EACf,AAAK,OAAO,UAAS,EAGnB,SACI,iBAAkB,QAAa,cAAc,UAAY,OAAO,YAClE,eAAgB,SAJlB,SAAS,WAAa,KAO1B,CAAC,EAEC,OAAO,KAAK,QAAQ,EAAE,OAAS,EAC1B,CAAE,MAAO,GAAM,QAAS,QAAQ,EAEhC,CAAE,MAAO,GAAO,cAAe,cAAe,KAAK,CAE9D,CA3BA,QAAA,aAAA,aA6BA,4BACE,QACA,GAA4D,CAE5D,SAAW,aAAa,QAAO,KAAK,SAAO,KAAP,QAAW,CAAA,CAAE,EAAG,CAClD,KAAM,UAAmC,QAAQ,WACjD,GAAG,UAAW,QAAQ,EAE1B,CAEA,0BAAiC,QAA6B,CAC5D,MAAO,CACL,QAAQ,KAAK,UAAU,QAAS,OAAW,CAAC,CAAC,GAC7C,KAAK;CAAI,CACb,CAJA,QAAA,iBAAA,iBAMA,uBAA8B,cAA0B,CACtD,MAAO,CACL,yBACA,QAAQ,KAAK,UAAU,cAAc,OAAQ,OAAW,CAAC,CAAC,EAC1D,iCACA,GAAG,cAAc,eAAc,EAAG,IAAI,GAAK,IAAK,GAAG,GACnD,KAAK;CAAI,CACb,CAPA,QAAA,cAAA,cASA,iBAAiB,EAAW,OAAiB,EAAC,CAC5C,KAAM,KAAM,IAAI,OAAO,MAAM,EAC7B,MAAO,KAAM,EAAE,MAAM;CAAI,EAAE,KAAK;EAAK,KAAK,CAC5C,CAEA,yBAAgC,QAAgC,UAAiB,CAE/E,MAAI,aAAc,IAAY,QAEvB,OAAO,QAAQ,SAAO,KAAP,QAAW,CAAA,CAAE,EAChC,OAAO,CAAC,CAAC,EAAG,KAAO,IAAM,SAAS,EAClC,OAAO,CAAC,IAAK,CAAC,EAAG,KAAgB,KAAK,KAAM,GAAI,CAAC,GAAO,CAAA,CAAE,CAC/D,CAPA,QAAA,gBAAA",
  "names": []
}
