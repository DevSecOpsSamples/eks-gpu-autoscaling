{
  "version": 3,
  "sources": ["match.ts"],
  "sourcesContent": ["import { Matcher, MatchResult } from './matcher';\nimport { AbsentMatch } from './private/matchers/absent';\nimport { getType } from './private/type';\n\n/**\n * Partial and special matching during template assertions.\n */\nexport abstract class Match {\n  /**\n   * Use this matcher in the place of a field's value, if the field must not be present.\n   */\n  public static absent(): Matcher {\n    return new AbsentMatch('absent');\n  }\n\n  /**\n   * Matches the specified pattern with the array found in the same relative path of the target.\n   * The set of elements (or matchers) must be in the same order as would be found.\n   * @param pattern the pattern to match\n   */\n  public static arrayWith(pattern: any[]): Matcher {\n    return new ArrayMatch('arrayWith', pattern);\n  }\n\n  /**\n   * Matches the specified pattern with the array found in the same relative path of the target.\n   * The set of elements (or matchers) must match exactly and in order.\n   * @param pattern the pattern to match\n   */\n  public static arrayEquals(pattern: any[]): Matcher {\n    return new ArrayMatch('arrayEquals', pattern, { subsequence: false });\n  }\n\n  /**\n   * Deep exact matching of the specified pattern to the target.\n   * @param pattern the pattern to match\n   */\n  public static exact(pattern: any): Matcher {\n    return new LiteralMatch('exact', pattern, { partialObjects: false });\n  }\n\n  /**\n   * Matches the specified pattern to an object found in the same relative path of the target.\n   * The keys and their values (or matchers) must be present in the target but the target can be a superset.\n   * @param pattern the pattern to match\n   */\n  public static objectLike(pattern: {[key: string]: any}): Matcher {\n    return new ObjectMatch('objectLike', pattern);\n  }\n\n  /**\n   * Matches the specified pattern to an object found in the same relative path of the target.\n   * The keys and their values (or matchers) must match exactly with the target.\n   * @param pattern the pattern to match\n   */\n  public static objectEquals(pattern: {[key: string]: any}): Matcher {\n    return new ObjectMatch('objectEquals', pattern, { partial: false });\n  }\n\n  /**\n   * Matches any target which does NOT follow the specified pattern.\n   * @param pattern the pattern to NOT match\n   */\n  public static not(pattern: any): Matcher {\n    return new NotMatch('not', pattern);\n  }\n\n  /**\n   * Matches any string-encoded JSON and applies the specified pattern after parsing it.\n   * @param pattern the pattern to match after parsing the encoded JSON.\n   */\n  public static serializedJson(pattern: any): Matcher {\n    return new SerializedJson('serializedJson', pattern);\n  }\n\n  /**\n   * Matches any non-null value at the target.\n   */\n  public static anyValue(): Matcher {\n    return new AnyMatch('anyValue');\n  }\n\n  /**\n   * Matches targets according to a regular expression\n   */\n  public static stringLikeRegexp(pattern: string): Matcher {\n    return new StringLikeRegexpMatch('stringLikeRegexp', pattern);\n  }\n}\n\n/**\n * Options when initializing the `LiteralMatch` class.\n */\ninterface LiteralMatchOptions {\n  /**\n   * Whether objects nested at any level should be matched partially.\n   * @default false\n   */\n  readonly partialObjects?: boolean;\n}\n\n/**\n * A Match class that expects the target to match with the pattern exactly.\n * The pattern may be nested with other matchers that are then deletegated to.\n */\nclass LiteralMatch extends Matcher {\n  private readonly partialObjects: boolean;\n\n  constructor(\n    public readonly name: string,\n    private readonly pattern: any,\n    options: LiteralMatchOptions = {}) {\n\n    super();\n    this.partialObjects = options.partialObjects ?? false;\n\n    if (Matcher.isMatcher(this.pattern)) {\n      throw new Error('LiteralMatch cannot directly contain another matcher. ' +\n        'Remove the top-level matcher or nest it more deeply.');\n    }\n  }\n\n  public test(actual: any): MatchResult {\n    if (Array.isArray(this.pattern)) {\n      return new ArrayMatch(this.name, this.pattern, { subsequence: false, partialObjects: this.partialObjects }).test(actual);\n    }\n\n    if (typeof this.pattern === 'object') {\n      return new ObjectMatch(this.name, this.pattern, { partial: this.partialObjects }).test(actual);\n    }\n\n    const result = new MatchResult(actual);\n    if (typeof this.pattern !== typeof actual) {\n      result.recordFailure({\n        matcher: this,\n        path: [],\n        message: `Expected type ${typeof this.pattern} but received ${getType(actual)}`,\n      });\n      return result;\n    }\n\n    if (actual !== this.pattern) {\n      result.recordFailure({\n        matcher: this,\n        path: [],\n        message: `Expected ${this.pattern} but received ${actual}`,\n      });\n    }\n\n    return result;\n  }\n}\n\n/**\n * Options when initializing the `ArrayMatch` class.\n */\ninterface ArrayMatchOptions {\n  /**\n   * Whether the pattern is a subsequence of the target.\n   * A subsequence is a sequence that can be derived from another sequence by deleting\n   * some or no elements without changing the order of the remaining elements.\n   * @default true\n   */\n  readonly subsequence?: boolean;\n\n  /**\n   * Whether to continue matching objects inside the array partially\n   *\n   * @default false\n   */\n  readonly partialObjects?: boolean;\n}\n\n/**\n * Match class that matches arrays.\n */\nclass ArrayMatch extends Matcher {\n  private readonly subsequence: boolean;\n  private readonly partialObjects: boolean;\n\n  constructor(\n    public readonly name: string,\n    private readonly pattern: any[],\n    options: ArrayMatchOptions = {}) {\n\n    super();\n    this.subsequence = options.subsequence ?? true;\n    this.partialObjects = options.partialObjects ?? false;\n  }\n\n  public test(actual: any): MatchResult {\n    if (!Array.isArray(actual)) {\n      return new MatchResult(actual).recordFailure({\n        matcher: this,\n        path: [],\n        message: `Expected type array but received ${getType(actual)}`,\n      });\n    }\n    if (!this.subsequence && this.pattern.length !== actual.length) {\n      return new MatchResult(actual).recordFailure({\n        matcher: this,\n        path: [],\n        message: `Expected array of length ${this.pattern.length} but received ${actual.length}`,\n      });\n    }\n\n    let patternIdx = 0;\n    let actualIdx = 0;\n\n    const result = new MatchResult(actual);\n    while (patternIdx < this.pattern.length && actualIdx < actual.length) {\n      const patternElement = this.pattern[patternIdx];\n\n      const matcher = Matcher.isMatcher(patternElement)\n        ? patternElement\n        : new LiteralMatch(this.name, patternElement, { partialObjects: this.partialObjects });\n\n      const matcherName = matcher.name;\n      if (this.subsequence && (matcherName == 'absent' || matcherName == 'anyValue')) {\n        // array subsequence matcher is not compatible with anyValue() or absent() matcher. They don't make sense to be used together.\n        throw new Error(`The Matcher ${matcherName}() cannot be nested within arrayWith()`);\n      }\n\n      const innerResult = matcher.test(actual[actualIdx]);\n\n      if (!this.subsequence || !innerResult.hasFailed()) {\n        result.compose(`[${actualIdx}]`, innerResult);\n        patternIdx++;\n        actualIdx++;\n      } else {\n        actualIdx++;\n      }\n    }\n\n    for (; patternIdx < this.pattern.length; patternIdx++) {\n      const pattern = this.pattern[patternIdx];\n      const element = (Matcher.isMatcher(pattern) || typeof pattern === 'object') ? ' ' : ` [${pattern}] `;\n      result.recordFailure({\n        matcher: this,\n        path: [],\n        message: `Missing element${element}at pattern index ${patternIdx}`,\n      });\n    }\n\n    return result;\n  }\n}\n\n/**\n * Options when initializing `ObjectMatch` class.\n */\ninterface ObjectMatchOptions {\n  /**\n   * Whether the pattern should partially match with the target object.\n   * The target object can contain more keys than expected by the pattern.\n   * @default true\n   */\n  readonly partial?: boolean;\n}\n\n/**\n * Match class that matches objects.\n */\nclass ObjectMatch extends Matcher {\n  private readonly partial: boolean;\n\n  constructor(\n    public readonly name: string,\n    private readonly pattern: {[key: string]: any},\n    options: ObjectMatchOptions = {}) {\n\n    super();\n    this.partial = options.partial ?? true;\n  }\n\n  public test(actual: any): MatchResult {\n    if (typeof actual !== 'object' || Array.isArray(actual)) {\n      return new MatchResult(actual).recordFailure({\n        matcher: this,\n        path: [],\n        message: `Expected type object but received ${getType(actual)}`,\n      });\n    }\n\n    const result = new MatchResult(actual);\n    if (!this.partial) {\n      for (const a of Object.keys(actual)) {\n        if (!(a in this.pattern)) {\n          result.recordFailure({\n            matcher: this,\n            path: [`/${a}`],\n            message: 'Unexpected key',\n          });\n        }\n      }\n    }\n\n    for (const [patternKey, patternVal] of Object.entries(this.pattern)) {\n      if (!(patternKey in actual) && !(patternVal instanceof AbsentMatch)) {\n        result.recordFailure({\n          matcher: this,\n          path: [`/${patternKey}`],\n          message: 'Missing key',\n        });\n        continue;\n      }\n      const matcher = Matcher.isMatcher(patternVal) ?\n        patternVal :\n        new LiteralMatch(this.name, patternVal, { partialObjects: this.partial });\n      const inner = matcher.test(actual[patternKey]);\n      result.compose(`/${patternKey}`, inner);\n    }\n\n    return result;\n  }\n}\n\nclass SerializedJson extends Matcher {\n  constructor(\n    public readonly name: string,\n    private readonly pattern: any,\n  ) {\n    super();\n  };\n\n  public test(actual: any): MatchResult {\n    const result = new MatchResult(actual);\n    if (getType(actual) !== 'string') {\n      result.recordFailure({\n        matcher: this,\n        path: [],\n        message: `Expected JSON as a string but found ${getType(actual)}`,\n      });\n      return result;\n    }\n    let parsed;\n    try {\n      parsed = JSON.parse(actual);\n    } catch (err) {\n      if (err instanceof SyntaxError) {\n        result.recordFailure({\n          matcher: this,\n          path: [],\n          message: `Invalid JSON string: ${actual}`,\n        });\n        return result;\n      } else {\n        throw err;\n      }\n    }\n\n    const matcher = Matcher.isMatcher(this.pattern) ? this.pattern : new LiteralMatch(this.name, this.pattern);\n    const innerResult = matcher.test(parsed);\n    result.compose(`(${this.name})`, innerResult);\n    return result;\n  }\n}\n\nclass NotMatch extends Matcher {\n  constructor(\n    public readonly name: string,\n    private readonly pattern: {[key: string]: any}) {\n\n    super();\n  }\n\n  public test(actual: any): MatchResult {\n    const matcher = Matcher.isMatcher(this.pattern) ? this.pattern : new LiteralMatch(this.name, this.pattern);\n\n    const innerResult = matcher.test(actual);\n    const result = new MatchResult(actual);\n    if (innerResult.failCount === 0) {\n      result.recordFailure({\n        matcher: this,\n        path: [],\n        message: `Found unexpected match: ${JSON.stringify(actual, undefined, 2)}`,\n      });\n    }\n    return result;\n  }\n}\n\nclass AnyMatch extends Matcher {\n  constructor(public readonly name: string) {\n    super();\n  }\n\n  public test(actual: any): MatchResult {\n    const result = new MatchResult(actual);\n    if (actual == null) {\n      result.recordFailure({\n        matcher: this,\n        path: [],\n        message: 'Expected a value but found none',\n      });\n    }\n    return result;\n  }\n}\n\nclass StringLikeRegexpMatch extends Matcher {\n  constructor(\n    public readonly name: string,\n    private readonly pattern: string) {\n\n    super();\n  }\n\n  test(actual: any): MatchResult {\n    const result = new MatchResult(actual);\n\n    const regex = new RegExp(this.pattern, 'gm');\n\n    if (typeof actual !== 'string') {\n      result.recordFailure({\n        matcher: this,\n        path: [],\n        message: `Expected a string, but got '${typeof actual}'`,\n      });\n    }\n\n    if (!regex.test(actual)) {\n      result.recordFailure({\n        matcher: this,\n        path: [],\n        message: `String '${actual}' did not match pattern '${this.pattern}'`,\n      });\n    }\n\n    return result;\n  }\n\n}\n"],
  "mappings": "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",
  "names": []
}
