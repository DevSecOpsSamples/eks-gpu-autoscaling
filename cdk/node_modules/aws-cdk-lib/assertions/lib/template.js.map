{
  "version": 3,
  "sources": ["template.ts"],
  "sourcesContent": ["import * as path from 'path';\nimport { Stack, Stage } from '../../core';\nimport * as fs from 'fs-extra';\nimport { Match } from './match';\nimport { Matcher } from './matcher';\nimport { findConditions, hasCondition } from './private/conditions';\nimport { checkTemplateForCyclicDependencies } from './private/cyclic';\nimport { findMappings, hasMapping } from './private/mappings';\nimport { findOutputs, hasOutput } from './private/outputs';\nimport { findParameters, hasParameter } from './private/parameters';\nimport { countResources, findResources, hasResource, hasResourceProperties } from './private/resources';\nimport { Template as TemplateType } from './private/template';\n\n/**\n * Suite of assertions that can be run on a CDK stack.\n * Typically used, as part of unit tests, to validate that the rendered\n * CloudFormation template has expected resources and properties.\n */\nexport class Template {\n\n  /**\n   * Base your assertions on the CloudFormation template synthesized by a CDK `Stack`.\n   * @param stack the CDK Stack to run assertions on\n   */\n  public static fromStack(stack: Stack): Template {\n    return new Template(toTemplate(stack));\n  }\n\n  /**\n   * Base your assertions from an existing CloudFormation template formatted as an in-memory\n   * JSON object.\n   * @param template the CloudFormation template formatted as a nested set of records\n   */\n  public static fromJSON(template: { [key: string] : any }): Template {\n    return new Template(template);\n  }\n\n  /**\n   * Base your assertions from an existing CloudFormation template formatted as a\n   * JSON string.\n   * @param template the CloudFormation template in\n   */\n  public static fromString(template: string): Template {\n    return new Template(JSON.parse(template));\n  }\n\n  private readonly template: TemplateType;\n\n  private constructor(template: { [key: string]: any }) {\n    this.template = template as TemplateType;\n    checkTemplateForCyclicDependencies(this.template);\n  }\n\n  /**\n   * The CloudFormation template deserialized into an object.\n   */\n  public toJSON(): { [key: string]: any } {\n    return this.template;\n  }\n\n  /**\n   * Assert that the given number of resources of the given type exist in the\n   * template.\n   * @param type the resource type; ex: `AWS::S3::Bucket`\n   * @param count number of expected instances\n   */\n  public resourceCountIs(type: string, count: number): void {\n    const counted = countResources(this.template, type);\n    if (counted !== count) {\n      throw new Error(`Expected ${count} resources of type ${type} but found ${counted}`);\n    }\n  }\n\n  /**\n   * Assert that a resource of the given type and properties exists in the\n   * CloudFormation template.\n   * By default, performs partial matching on the `Properties` key of the resource, via the\n   * `Match.objectLike()`. To configure different behavour, use other matchers in the `Match` class.\n   * @param type the resource type; ex: `AWS::S3::Bucket`\n   * @param props the 'Properties' section of the resource as should be expected in the template.\n   */\n  public hasResourceProperties(type: string, props: any): void {\n    const matchError = hasResourceProperties(this.template, type, props);\n    if (matchError) {\n      throw new Error(matchError);\n    }\n  }\n\n  /**\n   * Assert that a resource of the given type and given definition exists in the\n   * CloudFormation template.\n   * By default, performs partial matching on the resource, via the `Match.objectLike()`.\n   * To configure different behavour, use other matchers in the `Match` class.\n   * @param type the resource type; ex: `AWS::S3::Bucket`\n   * @param props the entire defintion of the resource as should be expected in the template.\n   */\n  public hasResource(type: string, props: any): void {\n    const matchError = hasResource(this.template, type, props);\n    if (matchError) {\n      throw new Error(matchError);\n    }\n  }\n\n  /**\n   * Get the set of matching resources of a given type and properties in the CloudFormation template.\n   * @param type the type to match in the CloudFormation template\n   * @param props by default, matches all resources with the given type.\n   * When a literal is provided, performs a partial match via `Match.objectLike()`.\n   * Use the `Match` APIs to configure a different behaviour.\n   */\n  public findResources(type: string, props: any = {}): { [key: string]: { [key: string]: any } } {\n    return findResources(this.template, type, props);\n  }\n\n  /**\n   * Assert that a Parameter with the given properties exists in the CloudFormation template.\n   * By default, performs partial matching on the parameter, via the `Match.objectLike()`.\n   * To configure different behavior, use other matchers in the `Match` class.\n   * @param logicalId the name of the parameter. Provide `'*'` to match all parameters in the template.\n   * @param props the parameter as should be expected in the template.\n   */\n  public hasParameter(logicalId: string, props: any): void {\n    const matchError = hasParameter(this.template, logicalId, props);\n    if (matchError) {\n      throw new Error(matchError);\n    }\n  }\n\n  /**\n   * Get the set of matching Parameters that match the given properties in the CloudFormation template.\n   * @param logicalId the name of the parameter. Provide `'*'` to match all parameters in the template.\n   * @param props by default, matches all Parameters in the template.\n   * When a literal object is provided, performs a partial match via `Match.objectLike()`.\n   * Use the `Match` APIs to configure a different behaviour.\n   */\n  public findParameters(logicalId: string, props: any = {}): { [key: string]: { [key: string]: any } } {\n    return findParameters(this.template, logicalId, props);\n  }\n\n  /**\n   * Assert that an Output with the given properties exists in the CloudFormation template.\n   * By default, performs partial matching on the resource, via the `Match.objectLike()`.\n   * To configure different behavour, use other matchers in the `Match` class.\n   * @param logicalId the name of the output. Provide `'*'` to match all outputs in the template.\n   * @param props the output as should be expected in the template.\n   */\n  public hasOutput(logicalId: string, props: any): void {\n    const matchError = hasOutput(this.template, logicalId, props);\n    if (matchError) {\n      throw new Error(matchError);\n    }\n  }\n\n  /**\n   * Get the set of matching Outputs that match the given properties in the CloudFormation template.\n   * @param logicalId the name of the output. Provide `'*'` to match all outputs in the template.\n   * @param props by default, matches all Outputs in the template.\n   * When a literal object is provided, performs a partial match via `Match.objectLike()`.\n   * Use the `Match` APIs to configure a different behaviour.\n   */\n  public findOutputs(logicalId: string, props: any = {}): { [key: string]: { [key: string]: any } } {\n    return findOutputs(this.template, logicalId, props);\n  }\n\n  /**\n   * Assert that a Mapping with the given properties exists in the CloudFormation template.\n   * By default, performs partial matching on the resource, via the `Match.objectLike()`.\n   * To configure different behavour, use other matchers in the `Match` class.\n   * @param logicalId the name of the mapping. Provide `'*'` to match all mappings in the template.\n   * @param props the output as should be expected in the template.\n   */\n  public hasMapping(logicalId: string, props: any): void {\n    const matchError = hasMapping(this.template, logicalId, props);\n    if (matchError) {\n      throw new Error(matchError);\n    }\n  }\n\n  /**\n   * Get the set of matching Mappings that match the given properties in the CloudFormation template.\n   * @param logicalId the name of the mapping. Provide `'*'` to match all mappings in the template.\n   * @param props by default, matches all Mappings in the template.\n   * When a literal object is provided, performs a partial match via `Match.objectLike()`.\n   * Use the `Match` APIs to configure a different behaviour.\n   */\n  public findMappings(logicalId: string, props: any = {}): { [key: string]: { [key: string]: any } } {\n    return findMappings(this.template, logicalId, props);\n  }\n\n  /**\n   * Assert that a Condition with the given properties exists in the CloudFormation template.\n   * By default, performs partial matching on the resource, via the `Match.objectLike()`.\n   * To configure different behavour, use other matchers in the `Match` class.\n   * @param logicalId the name of the mapping. Provide `'*'` to match all conditions in the template.\n   * @param props the output as should be expected in the template.\n   */\n  public hasCondition(logicalId: string, props: any): void {\n    const matchError = hasCondition(this.template, logicalId, props);\n    if (matchError) {\n      throw new Error(matchError);\n    }\n  }\n\n  /**\n   * Get the set of matching Conditions that match the given properties in the CloudFormation template.\n   * @param logicalId the name of the condition. Provide `'*'` to match all conditions in the template.\n   * @param props by default, matches all Conditions in the template.\n   * When a literal object is provided, performs a partial match via `Match.objectLike()`.\n   * Use the `Match` APIs to configure a different behaviour.\n   */\n  public findConditions(logicalId: string, props: any = {}): { [key: string]: { [key: string]: any } } {\n    return findConditions(this.template, logicalId, props);\n  }\n\n  /**\n   * Assert that the CloudFormation template matches the given value\n   * @param expected the expected CloudFormation template as key-value pairs.\n   */\n  public templateMatches(expected: any): void {\n    const matcher = Matcher.isMatcher(expected) ? expected : Match.objectLike(expected);\n    const result = matcher.test(this.template);\n\n    if (result.hasFailed()) {\n      throw new Error([\n        'Template did not match as expected. The following mismatches were found:',\n        ...result.toHumanStrings().map(s => `\\t${s}`),\n      ].join('\\n'));\n    }\n  }\n}\n\nfunction toTemplate(stack: Stack): any {\n  const root = stack.node.root;\n  if (!Stage.isStage(root)) {\n    throw new Error('unexpected: all stacks must be part of a Stage or an App');\n  }\n\n  const assembly = root.synth();\n  if (stack.nestedStackParent) {\n    // if this is a nested stack (it has a parent), then just read the template as a string\n    return JSON.parse(fs.readFileSync(path.join(assembly.directory, stack.templateFile)).toString('utf-8'));\n  }\n  return assembly.getStackArtifact(stack.artifactId).template;\n}"],
  "mappings": "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",
  "names": []
}
