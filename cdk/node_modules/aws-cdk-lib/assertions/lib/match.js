"use strict";var _a;Object.defineProperty(exports,"__esModule",{value:!0}),exports.Match=void 0;const JSII_RTTI_SYMBOL_1=Symbol.for("jsii.rtti"),matcher_1=require("./matcher"),absent_1=require("./private/matchers/absent"),type_1=require("./private/type");class Match{static absent(){return new absent_1.AbsentMatch("absent")}static arrayWith(pattern){return new ArrayMatch("arrayWith",pattern)}static arrayEquals(pattern){return new ArrayMatch("arrayEquals",pattern,{subsequence:!1})}static exact(pattern){return new LiteralMatch("exact",pattern,{partialObjects:!1})}static objectLike(pattern){return new ObjectMatch("objectLike",pattern)}static objectEquals(pattern){return new ObjectMatch("objectEquals",pattern,{partial:!1})}static not(pattern){return new NotMatch("not",pattern)}static serializedJson(pattern){return new SerializedJson("serializedJson",pattern)}static anyValue(){return new AnyMatch("anyValue")}static stringLikeRegexp(pattern){return new StringLikeRegexpMatch("stringLikeRegexp",pattern)}}exports.Match=Match,_a=JSII_RTTI_SYMBOL_1,Match[_a]={fqn:"aws-cdk-lib.assertions.Match",version:"2.20.0"};class LiteralMatch extends matcher_1.Matcher{constructor(name,pattern,options={}){var _b;super();if(this.name=name,this.pattern=pattern,this.partialObjects=(_b=options.partialObjects)!==null&&_b!==void 0?_b:!1,matcher_1.Matcher.isMatcher(this.pattern))throw new Error("LiteralMatch cannot directly contain another matcher. Remove the top-level matcher or nest it more deeply.")}test(actual){if(Array.isArray(this.pattern))return new ArrayMatch(this.name,this.pattern,{subsequence:!1,partialObjects:this.partialObjects}).test(actual);if(typeof this.pattern=="object")return new ObjectMatch(this.name,this.pattern,{partial:this.partialObjects}).test(actual);const result=new matcher_1.MatchResult(actual);return typeof this.pattern!=typeof actual?(result.recordFailure({matcher:this,path:[],message:`Expected type ${typeof this.pattern} but received ${type_1.getType(actual)}`}),result):(actual!==this.pattern&&result.recordFailure({matcher:this,path:[],message:`Expected ${this.pattern} but received ${actual}`}),result)}}class ArrayMatch extends matcher_1.Matcher{constructor(name,pattern,options={}){var _b,_c;super();this.name=name,this.pattern=pattern,this.subsequence=(_b=options.subsequence)!==null&&_b!==void 0?_b:!0,this.partialObjects=(_c=options.partialObjects)!==null&&_c!==void 0?_c:!1}test(actual){if(!Array.isArray(actual))return new matcher_1.MatchResult(actual).recordFailure({matcher:this,path:[],message:`Expected type array but received ${type_1.getType(actual)}`});if(!this.subsequence&&this.pattern.length!==actual.length)return new matcher_1.MatchResult(actual).recordFailure({matcher:this,path:[],message:`Expected array of length ${this.pattern.length} but received ${actual.length}`});let patternIdx=0,actualIdx=0;const result=new matcher_1.MatchResult(actual);for(;patternIdx<this.pattern.length&&actualIdx<actual.length;){const patternElement=this.pattern[patternIdx],matcher=matcher_1.Matcher.isMatcher(patternElement)?patternElement:new LiteralMatch(this.name,patternElement,{partialObjects:this.partialObjects}),matcherName=matcher.name;if(this.subsequence&&(matcherName=="absent"||matcherName=="anyValue"))throw new Error(`The Matcher ${matcherName}() cannot be nested within arrayWith()`);const innerResult=matcher.test(actual[actualIdx]);(!this.subsequence||!innerResult.hasFailed())&&(result.compose(`[${actualIdx}]`,innerResult),patternIdx++),actualIdx++}for(;patternIdx<this.pattern.length;patternIdx++){const pattern=this.pattern[patternIdx],element=matcher_1.Matcher.isMatcher(pattern)||typeof pattern=="object"?" ":` [${pattern}] `;result.recordFailure({matcher:this,path:[],message:`Missing element${element}at pattern index ${patternIdx}`})}return result}}class ObjectMatch extends matcher_1.Matcher{constructor(name,pattern,options={}){var _b;super();this.name=name,this.pattern=pattern,this.partial=(_b=options.partial)!==null&&_b!==void 0?_b:!0}test(actual){if(typeof actual!="object"||Array.isArray(actual))return new matcher_1.MatchResult(actual).recordFailure({matcher:this,path:[],message:`Expected type object but received ${type_1.getType(actual)}`});const result=new matcher_1.MatchResult(actual);if(!this.partial)for(const a of Object.keys(actual))a in this.pattern||result.recordFailure({matcher:this,path:[`/${a}`],message:"Unexpected key"});for(const[patternKey,patternVal]of Object.entries(this.pattern)){if(!(patternKey in actual)&&!(patternVal instanceof absent_1.AbsentMatch)){result.recordFailure({matcher:this,path:[`/${patternKey}`],message:"Missing key"});continue}const inner=(matcher_1.Matcher.isMatcher(patternVal)?patternVal:new LiteralMatch(this.name,patternVal,{partialObjects:this.partial})).test(actual[patternKey]);result.compose(`/${patternKey}`,inner)}return result}}class SerializedJson extends matcher_1.Matcher{constructor(name,pattern){super();this.name=name,this.pattern=pattern}test(actual){const result=new matcher_1.MatchResult(actual);if(type_1.getType(actual)!=="string")return result.recordFailure({matcher:this,path:[],message:`Expected JSON as a string but found ${type_1.getType(actual)}`}),result;let parsed;try{parsed=JSON.parse(actual)}catch(err){if(err instanceof SyntaxError)return result.recordFailure({matcher:this,path:[],message:`Invalid JSON string: ${actual}`}),result;throw err}const innerResult=(matcher_1.Matcher.isMatcher(this.pattern)?this.pattern:new LiteralMatch(this.name,this.pattern)).test(parsed);return result.compose(`(${this.name})`,innerResult),result}}class NotMatch extends matcher_1.Matcher{constructor(name,pattern){super();this.name=name,this.pattern=pattern}test(actual){const innerResult=(matcher_1.Matcher.isMatcher(this.pattern)?this.pattern:new LiteralMatch(this.name,this.pattern)).test(actual),result=new matcher_1.MatchResult(actual);return innerResult.failCount===0&&result.recordFailure({matcher:this,path:[],message:`Found unexpected match: ${JSON.stringify(actual,void 0,2)}`}),result}}class AnyMatch extends matcher_1.Matcher{constructor(name){super();this.name=name}test(actual){const result=new matcher_1.MatchResult(actual);return actual==null&&result.recordFailure({matcher:this,path:[],message:"Expected a value but found none"}),result}}class StringLikeRegexpMatch extends matcher_1.Matcher{constructor(name,pattern){super();this.name=name,this.pattern=pattern}test(actual){const result=new matcher_1.MatchResult(actual),regex=new RegExp(this.pattern,"gm");return typeof actual!="string"&&result.recordFailure({matcher:this,path:[],message:`Expected a string, but got '${typeof actual}'`}),regex.test(actual)||result.recordFailure({matcher:this,path:[],message:`String '${actual}' did not match pattern '${this.pattern}'`}),result}}
//# sourceMappingURL=match.js.map
