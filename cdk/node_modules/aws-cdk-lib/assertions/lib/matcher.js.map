{
  "version": 3,
  "sources": ["matcher.ts"],
  "sourcesContent": ["import { Capture } from './capture';\n\n/**\n * Represents a matcher that can perform special data matching\n * capabilities between a given pattern and a target.\n */\nexport abstract class Matcher {\n  /**\n   * Check whether the provided object is a subtype of the `IMatcher`.\n   */\n  public static isMatcher(x: any): x is Matcher {\n    return x && x instanceof Matcher;\n  }\n\n  /**\n   * A name for the matcher. This is collected as part of the result and may be presented to the user.\n   */\n  public abstract readonly name: string;\n\n  /**\n   * Test whether a target matches the provided pattern.\n   * Every Matcher must implement this method.\n   * This method will be invoked by the assertions framework. Do not call this method directly.\n   * @param actual the target to match\n   * @return the list of match failures. An empty array denotes a successful match.\n   */\n  public abstract test(actual: any): MatchResult;\n}\n\n/**\n * Match failure details\n */\nexport interface MatchFailure {\n  /**\n   * The matcher that had the failure\n   */\n  readonly matcher: Matcher;\n\n  /**\n   * The relative path in the target where the failure occurred.\n   * If the failure occurred at root of the match tree, set the path to an empty list.\n   * If it occurs in the 5th index of an array nested within the 'foo' key of an object,\n   * set the path as `['/foo', '[5]']`.\n   */\n  readonly path: string[];\n\n  /**\n   * Failure message\n   */\n  readonly message: string;\n}\n\n/**\n * Information about a value captured during match\n */\nexport interface MatchCapture {\n  /**\n   * The instance of Capture class to which this capture is associated with.\n   */\n  readonly capture: Capture;\n  /**\n   * The value that was captured\n   */\n  readonly value: any;\n}\n\n/**\n * The result of `Match.test()`.\n */\nexport class MatchResult {\n  /**\n   * The target for which this result was generated.\n   */\n  public readonly target: any;\n  private readonly failures: MatchFailure[] = [];\n  private readonly captures: Map<Capture, any[]> = new Map();\n  private finalized: boolean = false;\n\n  constructor(target: any) {\n    this.target = target;\n  }\n\n  /**\n   * DEPRECATED\n   * @deprecated use recordFailure()\n   */\n  public push(matcher: Matcher, path: string[], message: string): this {\n    return this.recordFailure({ matcher, path, message });\n  }\n\n  /**\n   * Record a new failure into this result at a specific path.\n   */\n  public recordFailure(failure: MatchFailure): this {\n    this.failures.push(failure);\n    return this;\n  }\n\n  /** Does the result contain any failures. If not, the result is a success */\n  public hasFailed(): boolean {\n    return this.failures.length !== 0;\n  }\n\n  /** The number of failures */\n  public get failCount(): number {\n    return this.failures.length;\n  }\n\n  /**\n   * Compose the results of a previous match as a subtree.\n   * @param id the id of the parent tree.\n   */\n  public compose(id: string, inner: MatchResult): this {\n    const innerF = inner.failures;\n    this.failures.push(...innerF.map(f => {\n      return { path: [id, ...f.path], message: f.message, matcher: f.matcher };\n    }));\n    inner.captures.forEach((vals, capture) => {\n      vals.forEach(value => this.recordCapture({ capture, value }));\n    });\n    return this;\n  }\n\n  /**\n   * Prepare the result to be analyzed.\n   * This API *must* be called prior to analyzing these results.\n   */\n  public finished(): this {\n    if (this.finalized) {\n      return this;\n    }\n\n    if (this.failCount === 0) {\n      this.captures.forEach((vals, cap) => cap._captured.push(...vals));\n    }\n    this.finalized = true;\n    return this;\n  }\n\n  /**\n   * Get the list of failures as human readable strings\n   */\n  public toHumanStrings(): string[] {\n    return this.failures.map(r => {\n      const loc = r.path.length === 0 ? '' : ` at ${r.path.join('')}`;\n      return '' + r.message + loc + ` (using ${r.matcher.name} matcher)`;\n    });\n  }\n\n  /**\n   * Record a capture against in this match result.\n   */\n  public recordCapture(options: MatchCapture): void {\n    let values = this.captures.get(options.capture);\n    if (values === undefined) {\n      values = [];\n    }\n    values.push(options.value);\n    this.captures.set(options.capture, values);\n  }\n}\n"],
  "mappings": "qOAMA,MAAsB,OAAO,OAIb,WAAU,EAAM,CAC5B,MAAO,IAAK,YAAa,UAL7B,QAAA,QAAA,kGA+DA,MAAa,WAAW,CAStB,YAAY,OAAW,CAJN,KAAA,SAA2B,CAAA,EAC3B,KAAA,SAAgC,GAAI,KAC7C,KAAA,UAAqB,GAG3B,KAAK,OAAS,OAOT,KAAK,QAAkB,KAAgB,QAAe,uKACpD,KAAK,cAAc,CAAE,QAAS,KAAM,OAAO,CAAE,EAM/C,cAAc,QAAqB,6EACxC,KAAK,SAAS,KAAK,OAAO,EACnB,KAIF,WAAS,CACd,MAAO,MAAK,SAAS,SAAW,KAIvB,YAAS,CAClB,MAAO,MAAK,SAAS,OAOhB,QAAQ,GAAY,MAAkB,mEAC3C,KAAM,QAAS,MAAM,SACrB,YAAK,SAAS,KAAK,GAAG,OAAO,IAAI,GACxB,EAAE,KAAM,CAAC,GAAI,GAAG,EAAE,IAAI,EAAG,QAAS,EAAE,QAAS,QAAS,EAAE,OAAO,EACvE,CAAC,EACF,MAAM,SAAS,QAAQ,CAAC,KAAM,UAAW,CACvC,KAAK,QAAQ,OAAS,KAAK,cAAc,CAAE,QAAS,KAAK,CAAE,CAAC,CAC9D,CAAC,EACM,KAOF,UAAQ,CACb,MAAI,MAAK,UACA,KAGL,MAAK,YAAc,GACrB,KAAK,SAAS,QAAQ,CAAC,KAAM,MAAQ,IAAI,UAAU,KAAK,GAAG,IAAI,CAAC,EAElE,KAAK,UAAY,GACV,MAMF,gBAAc,CACnB,MAAO,MAAK,SAAS,IAAI,GAAI,CAC3B,KAAM,KAAM,EAAE,KAAK,SAAW,EAAI,GAAK,OAAO,EAAE,KAAK,KAAK,EAAE,IAC5D,MAAO,GAAK,EAAE,QAAU,IAAM,WAAW,EAAE,QAAQ,eACrD,CAAC,EAMI,cAAc,QAAqB,sEACxC,GAAI,QAAS,KAAK,SAAS,IAAI,QAAQ,OAAO,EAC9C,AAAI,SAAW,QACb,QAAS,CAAA,GAEX,OAAO,KAAK,QAAQ,KAAK,EACzB,KAAK,SAAS,IAAI,QAAQ,QAAS,MAAM,GAzF7C,QAAA,YAAA",
  "names": []
}
