{
  "version": 3,
  "sources": ["waiter-state-machine.ts"],
  "sourcesContent": ["import { Grant, IGrantable, Role, ServicePrincipal } from '../../../aws-iam';\nimport { IFunction } from '../../../aws-lambda';\nimport { CfnResource, Duration, Stack } from '../../../core';\n\n// keep this import separate from other imports to reduce chance for merge conflicts with v2-main\n// eslint-disable-next-line no-duplicate-imports, import/order\nimport { Construct } from 'constructs';\n\nexport interface WaiterStateMachineProps {\n  /**\n   * The main handler that notifies if the waiter to decide 'complete' or 'incomplete'.\n   */\n  readonly isCompleteHandler: IFunction;\n\n  /**\n   * The handler to call if the waiter times out and is incomplete.\n   */\n  readonly timeoutHandler: IFunction;\n\n  /**\n   * The interval to wait between attempts.\n   */\n  readonly interval: Duration;\n\n  /**\n   * Number of attempts.\n   */\n  readonly maxAttempts: number;\n\n  /**\n   * Backoff between attempts.\n   */\n  readonly backoffRate: number;\n}\n\n/**\n * A very simple StateMachine construct highly customized to the provider framework.\n * This is so that this package does not need to depend on aws-stepfunctions module.\n *\n * The state machine continuously calls the isCompleteHandler, until it succeeds or times out.\n * The handler is called `maxAttempts` times with an `interval` duration and a `backoffRate` rate.\n */\nexport class WaiterStateMachine extends Construct {\n  public readonly stateMachineArn: string;\n\n  constructor(scope: Construct, id: string, props: WaiterStateMachineProps) {\n    super(scope, id);\n\n    const role = new Role(this, 'Role', {\n      assumedBy: new ServicePrincipal('states.amazonaws.com'),\n    });\n    props.isCompleteHandler.grantInvoke(role);\n    props.timeoutHandler.grantInvoke(role);\n\n    const definition = Stack.of(this).toJsonString({\n      StartAt: 'framework-isComplete-task',\n      States: {\n        'framework-isComplete-task': {\n          End: true,\n          Retry: [{\n            ErrorEquals: ['States.ALL'],\n            IntervalSeconds: props.interval.toSeconds(),\n            MaxAttempts: props.maxAttempts,\n            BackoffRate: props.backoffRate,\n          }],\n          Catch: [{\n            ErrorEquals: ['States.ALL'],\n            Next: 'framework-onTimeout-task',\n          }],\n          Type: 'Task',\n          Resource: props.isCompleteHandler.functionArn,\n        },\n        'framework-onTimeout-task': {\n          End: true,\n          Type: 'Task',\n          Resource: props.timeoutHandler.functionArn,\n        },\n      },\n    });\n\n    const resource = new CfnResource(this, 'Resource', {\n      type: 'AWS::StepFunctions::StateMachine',\n      properties: {\n        DefinitionString: definition,\n        RoleArn: role.roleArn,\n      },\n    });\n    resource.node.addDependency(role);\n\n    this.stateMachineArn = resource.ref;\n  }\n\n  public grantStartExecution(identity: IGrantable) {\n    return Grant.addToPrincipal({\n      grantee: identity,\n      actions: ['states:StartExecution'],\n      resourceArns: [this.stateMachineArn],\n    });\n  }\n}\n"],
  "mappings": "sGAAA,KAAA,WAAA,QAAA,kBAAA,EAEA,OAAA,QAAA,eAAA,EAIA,aAAA,QAAA,YAAA,EAoCA,MAAa,0BAA2B,cAAA,SAAS,CAG/C,YAAY,MAAkB,GAAY,MAA8B,CACtE,MAAM,MAAO,EAAE,EAEf,KAAM,MAAO,GAAI,WAAA,KAAK,KAAM,OAAQ,CAClC,UAAW,GAAI,WAAA,iBAAiB,sBAAsB,EACvD,EACD,MAAM,kBAAkB,YAAY,IAAI,EACxC,MAAM,eAAe,YAAY,IAAI,EAErC,KAAM,YAAa,OAAA,MAAM,GAAG,IAAI,EAAE,aAAa,CAC7C,QAAS,4BACT,OAAQ,CACN,4BAA6B,CAC3B,IAAK,GACL,MAAO,CAAC,CACN,YAAa,CAAC,YAAY,EAC1B,gBAAiB,MAAM,SAAS,UAAS,EACzC,YAAa,MAAM,YACnB,YAAa,MAAM,YACpB,EACD,MAAO,CAAC,CACN,YAAa,CAAC,YAAY,EAC1B,KAAM,2BACP,EACD,KAAM,OACN,SAAU,MAAM,kBAAkB,aAEpC,2BAA4B,CAC1B,IAAK,GACL,KAAM,OACN,SAAU,MAAM,eAAe,cAGpC,EAEK,SAAW,GAAI,QAAA,YAAY,KAAM,WAAY,CACjD,KAAM,mCACN,WAAY,CACV,iBAAkB,WAClB,QAAS,KAAK,SAEjB,EACD,SAAS,KAAK,cAAc,IAAI,EAEhC,KAAK,gBAAkB,SAAS,IAG3B,oBAAoB,SAAoB,CAC7C,MAAO,WAAA,MAAM,eAAe,CAC1B,QAAS,SACT,QAAS,CAAC,uBAAuB,EACjC,aAAc,CAAC,KAAK,eAAe,EACpC,GAvDL,QAAA,mBAAA",
  "names": []
}
