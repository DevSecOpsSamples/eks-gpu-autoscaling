{
  "version": 3,
  "sources": ["provider.ts"],
  "sourcesContent": ["import * as path from 'path';\nimport * as ec2 from '../../../aws-ec2';\nimport * as iam from '../../../aws-iam';\nimport * as lambda from '../../../aws-lambda';\nimport * as logs from '../../../aws-logs';\nimport { Duration } from '../../../core';\nimport { Construct } from 'constructs';\nimport * as consts from './runtime/consts';\nimport { calculateRetryPolicy } from './util';\nimport { WaiterStateMachine } from './waiter-state-machine';\n\n// keep this import separate from other imports to reduce chance for merge conflicts with v2-main\n// eslint-disable-next-line no-duplicate-imports, import/order\nimport { CustomResourceProviderConfig, ICustomResourceProvider } from '../../../aws-cloudformation';\n\nconst RUNTIME_HANDLER_PATH = path.join(__dirname, 'runtime');\nconst FRAMEWORK_HANDLER_TIMEOUT = Duration.minutes(15); // keep it simple for now\n\n/**\n * Initialization properties for the `Provider` construct.\n */\nexport interface ProviderProps {\n\n  /**\n   * The AWS Lambda function to invoke for all resource lifecycle operations\n   * (CREATE/UPDATE/DELETE).\n   *\n   * This function is responsible to begin the requested resource operation\n   * (CREATE/UPDATE/DELETE) and return any additional properties to add to the\n   * event, which will later be passed to `isComplete`. The `PhysicalResourceId`\n   * property must be included in the response.\n   */\n  readonly onEventHandler: lambda.IFunction;\n\n  /**\n   * The AWS Lambda function to invoke in order to determine if the operation is\n   * complete.\n   *\n   * This function will be called immediately after `onEvent` and then\n   * periodically based on the configured query interval as long as it returns\n   * `false`. If the function still returns `false` and the alloted timeout has\n   * passed, the operation will fail.\n   *\n   * @default - provider is synchronous. This means that the `onEvent` handler\n   * is expected to finish all lifecycle operations within the initial invocation.\n   */\n  readonly isCompleteHandler?: lambda.IFunction;\n\n  /**\n   * Time between calls to the `isComplete` handler which determines if the\n   * resource has been stabilized.\n   *\n   * The first `isComplete` will be called immediately after `handler` and then\n   * every `queryInterval` seconds, and until `timeout` has been reached or until\n   * `isComplete` returns `true`.\n   *\n   * @default Duration.seconds(5)\n   */\n  readonly queryInterval?: Duration;\n\n  /**\n   * Total timeout for the entire operation.\n   *\n   * The maximum timeout is 2 hours (yes, it can exceed the AWS Lambda 15 minutes)\n   *\n   * @default Duration.minutes(30)\n   */\n  readonly totalTimeout?: Duration;\n\n  /**\n   * The number of days framework log events are kept in CloudWatch Logs. When\n   * updating this property, unsetting it doesn't remove the log retention policy.\n   * To remove the retention policy, set the value to `INFINITE`.\n   *\n   * @default logs.RetentionDays.INFINITE\n   */\n  readonly logRetention?: logs.RetentionDays;\n\n  /**\n   * The vpc to provision the lambda functions in.\n   *\n   * @default - functions are not provisioned inside a vpc.\n   */\n  readonly vpc?: ec2.IVpc;\n\n  /**\n   * Which subnets from the VPC to place the lambda functions in.\n   *\n   * Only used if 'vpc' is supplied. Note: internet access for Lambdas\n   * requires a NAT gateway, so picking Public subnets is not allowed.\n   *\n   * @default - the Vpc default strategy if not specified\n   */\n  readonly vpcSubnets?: ec2.SubnetSelection;\n\n  /**\n   * Security groups to attach to the provider functions.\n   *\n   * Only used if 'vpc' is supplied\n   *\n   * @default - If `vpc` is not supplied, no security groups are attached. Otherwise, a dedicated security\n   * group is created for each function.\n   */\n  readonly securityGroups?: ec2.ISecurityGroup[];\n\n  /**\n   * AWS Lambda execution role.\n   *\n   * The role that will be assumed by the AWS Lambda.\n   * Must be assumable by the 'lambda.amazonaws.com' service principal.\n   *\n   * @default - A default role will be created.\n   */\n  readonly role?: iam.IRole;\n\n  /**\n   * Provider Lambda name.\n   *\n   * The provider lambda function name.\n   *\n   * @default -  CloudFormation default name from unique physical ID\n   */\n  readonly providerFunctionName?: string;\n}\n\n/**\n * Defines an AWS CloudFormation custom resource provider.\n */\nexport class Provider extends Construct implements ICustomResourceProvider {\n\n  /**\n   * The user-defined AWS Lambda function which is invoked for all resource\n   * lifecycle operations (CREATE/UPDATE/DELETE).\n   */\n  public readonly onEventHandler: lambda.IFunction;\n\n  /**\n   * The user-defined AWS Lambda function which is invoked asynchronously in\n   * order to determine if the operation is complete.\n   */\n  public readonly isCompleteHandler?: lambda.IFunction;\n\n  /**\n   * The service token to use in order to define custom resources that are\n   * backed by this provider.\n   */\n  public readonly serviceToken: string;\n\n  private readonly entrypoint: lambda.Function;\n  private readonly logRetention?: logs.RetentionDays;\n  private readonly vpc?: ec2.IVpc;\n  private readonly vpcSubnets?: ec2.SubnetSelection;\n  private readonly securityGroups?: ec2.ISecurityGroup[];\n  private readonly role?: iam.IRole;\n\n  constructor(scope: Construct, id: string, props: ProviderProps) {\n    super(scope, id);\n\n    if (!props.isCompleteHandler && (props.queryInterval || props.totalTimeout)) {\n      throw new Error('\"queryInterval\" and \"totalTimeout\" can only be configured if \"isCompleteHandler\" is specified. '\n        + 'Otherwise, they have no meaning');\n    }\n\n    this.onEventHandler = props.onEventHandler;\n    this.isCompleteHandler = props.isCompleteHandler;\n\n    this.logRetention = props.logRetention;\n    this.vpc = props.vpc;\n    this.vpcSubnets = props.vpcSubnets;\n    this.securityGroups = props.securityGroups;\n\n    this.role = props.role;\n\n    const onEventFunction = this.createFunction(consts.FRAMEWORK_ON_EVENT_HANDLER_NAME, props.providerFunctionName);\n\n    if (this.isCompleteHandler) {\n      const isCompleteFunction = this.createFunction(consts.FRAMEWORK_IS_COMPLETE_HANDLER_NAME);\n      const timeoutFunction = this.createFunction(consts.FRAMEWORK_ON_TIMEOUT_HANDLER_NAME);\n\n      const retry = calculateRetryPolicy(props);\n      const waiterStateMachine = new WaiterStateMachine(this, 'waiter-state-machine', {\n        isCompleteHandler: isCompleteFunction,\n        timeoutHandler: timeoutFunction,\n        backoffRate: retry.backoffRate,\n        interval: retry.interval,\n        maxAttempts: retry.maxAttempts,\n      });\n      // the on-event entrypoint is going to start the execution of the waiter\n      onEventFunction.addEnvironment(consts.WAITER_STATE_MACHINE_ARN_ENV, waiterStateMachine.stateMachineArn);\n      waiterStateMachine.grantStartExecution(onEventFunction);\n    }\n\n    this.entrypoint = onEventFunction;\n    this.serviceToken = this.entrypoint.functionArn;\n  }\n\n  /**\n   * Called by `CustomResource` which uses this provider.\n   * @deprecated use `provider.serviceToken` instead\n   */\n  public bind(_scope: Construct): CustomResourceProviderConfig {\n    return {\n      serviceToken: this.entrypoint.functionArn,\n    };\n  }\n\n  private createFunction(entrypoint: string, name?: string) {\n    const fn = new lambda.Function(this, `framework-${entrypoint}`, {\n      code: lambda.Code.fromAsset(RUNTIME_HANDLER_PATH),\n      description: `AWS CDK resource provider framework - ${entrypoint} (${this.node.path})`.slice(0, 256),\n      runtime: lambda.Runtime.NODEJS_12_X,\n      handler: `framework.${entrypoint}`,\n      timeout: FRAMEWORK_HANDLER_TIMEOUT,\n      logRetention: this.logRetention,\n      vpc: this.vpc,\n      vpcSubnets: this.vpcSubnets,\n      securityGroups: this.securityGroups,\n      role: this.role,\n      functionName: name,\n    });\n\n    fn.addEnvironment(consts.USER_ON_EVENT_FUNCTION_ARN_ENV, this.onEventHandler.functionArn);\n    this.onEventHandler.grantInvoke(fn);\n\n    if (this.isCompleteHandler) {\n      fn.addEnvironment(consts.USER_IS_COMPLETE_FUNCTION_ARN_ENV, this.isCompleteHandler.functionArn);\n      this.isCompleteHandler.grantInvoke(fn);\n    }\n\n    return fn;\n  }\n}\n"],
  "mappings": "kNAAA,KAAA,QAAA,MAAA,EAGA,OAAA,QAAA,qBAAA,EAEA,OAAA,QAAA,eAAA,EACA,aAAA,QAAA,YAAA,EACA,OAAA,QAAA,kBAAA,EACA,OAAA,QAAA,QAAA,EACA,uBAAA,QAAA,wBAAA,EAMM,qBAAuB,KAAK,KAAK,UAAW,SAAS,EACrD,0BAA4B,OAAA,SAAS,QAAQ,EAAE,EAgHrD,MAAa,gBAAiB,cAAA,SAAS,CA2BrC,YAAY,MAAkB,GAAY,MAAoB,CAC5D,MAAM,MAAO,EAAE,EAEf,6EAAI,CAAC,MAAM,mBAAsB,OAAM,eAAiB,MAAM,cAC5D,KAAM,IAAI,OAAM,gIACqB,EAGvC,KAAK,eAAiB,MAAM,eAC5B,KAAK,kBAAoB,MAAM,kBAE/B,KAAK,aAAe,MAAM,aAC1B,KAAK,IAAM,MAAM,IACjB,KAAK,WAAa,MAAM,WACxB,KAAK,eAAiB,MAAM,eAE5B,KAAK,KAAO,MAAM,KAElB,KAAM,iBAAkB,KAAK,eAAe,OAAO,gCAAiC,MAAM,oBAAoB,EAE9G,GAAI,KAAK,kBAAmB,CAC1B,KAAM,oBAAqB,KAAK,eAAe,OAAO,kCAAkC,EAClF,gBAAkB,KAAK,eAAe,OAAO,iCAAiC,EAE9E,MAAQ,OAAA,qBAAqB,KAAK,EAClC,mBAAqB,GAAI,wBAAA,mBAAmB,KAAM,uBAAwB,CAC9E,kBAAmB,mBACnB,eAAgB,gBAChB,YAAa,MAAM,YACnB,SAAU,MAAM,SAChB,YAAa,MAAM,YACpB,EAED,gBAAgB,eAAe,OAAO,6BAA8B,mBAAmB,eAAe,EACtG,mBAAmB,oBAAoB,eAAe,EAGxD,KAAK,WAAa,gBAClB,KAAK,aAAe,KAAK,WAAW,YAO/B,KAAK,OAAiB,CAC3B,MAAO,CACL,aAAc,KAAK,WAAW,aAI1B,eAAe,WAAoB,KAAa,CACtD,KAAM,IAAK,GAAI,QAAO,SAAS,KAAM,aAAa,aAAc,CAC9D,KAAM,OAAO,KAAK,UAAU,oBAAoB,EAChD,YAAa,yCAAyC,eAAe,KAAK,KAAK,QAAQ,MAAM,EAAG,GAAG,EACnG,QAAS,OAAO,QAAQ,YACxB,QAAS,aAAa,aACtB,QAAS,0BACT,aAAc,KAAK,aACnB,IAAK,KAAK,IACV,WAAY,KAAK,WACjB,eAAgB,KAAK,eACrB,KAAM,KAAK,KACX,aAAc,KACf,EAED,UAAG,eAAe,OAAO,+BAAgC,KAAK,eAAe,WAAW,EACxF,KAAK,eAAe,YAAY,EAAE,EAE9B,KAAK,mBACP,IAAG,eAAe,OAAO,kCAAmC,KAAK,kBAAkB,WAAW,EAC9F,KAAK,kBAAkB,YAAY,EAAE,GAGhC,IArGX,QAAA,SAAA",
  "names": []
}
