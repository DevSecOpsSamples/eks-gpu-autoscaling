{
  "version": 3,
  "sources": ["manifest.ts"],
  "sourcesContent": ["import * as fs from 'fs';\nimport * as jsonschema from 'jsonschema';\nimport * as semver from 'semver';\nimport * as assets from './assets';\nimport * as assembly from './cloud-assembly';\nimport * as integ from './integ-tests';\n\n/* eslint-disable @typescript-eslint/no-var-requires */\n/* eslint-disable @typescript-eslint/no-require-imports */\n\n// this prefix is used by the CLI to identify this specific error.\n// in which case we want to instruct the user to upgrade his CLI.\n// see exec.ts#createAssembly\nexport const VERSION_MISMATCH: string = 'Cloud assembly schema version mismatch';\n\nconst ASSETS_SCHEMA = require('../schema/assets.schema.json');\n\nconst ASSEMBLY_SCHEMA = require('../schema/cloud-assembly.schema.json');\n\n/**\n * Version is shared for both manifests\n */\nconst SCHEMA_VERSION = require('../schema/cloud-assembly.version.json').version;\n\nconst INTEG_SCHEMA = require('../schema/integ.schema.json');\n\n/**\n * Options for the loadManifest operation\n */\nexport interface LoadManifestOptions {\n  /**\n   * Skip the version check\n   *\n   * This means you may read a newer cloud assembly than the CX API is designed\n   * to support, and your application may not be aware of all features that in use\n   * in the Cloud Assembly.\n   *\n   * @default false\n   */\n  readonly skipVersionCheck?: boolean;\n\n  /**\n   * Skip enum checks\n   *\n   * This means you may read enum values you don't know about yet. Make sure to always\n   * check the values of enums you encounter in the manifest.\n   *\n   * @default false\n   */\n  readonly skipEnumCheck?: boolean;\n}\n\n/**\n * Protocol utility class.\n */\nexport class Manifest {\n  /**\n   * Validates and saves the cloud assembly manifest to file.\n   *\n   * @param manifest - manifest.\n   * @param filePath - output file path.\n   */\n  public static saveAssemblyManifest(manifest: assembly.AssemblyManifest, filePath: string) {\n    Manifest.saveManifest(manifest, filePath, ASSEMBLY_SCHEMA, Manifest.patchStackTagsOnWrite);\n  }\n\n  /**\n   * Load and validates the cloud assembly manifest from file.\n   *\n   * @param filePath - path to the manifest file.\n   */\n  public static loadAssemblyManifest(filePath: string, options?: LoadManifestOptions): assembly.AssemblyManifest {\n    return Manifest.loadManifest(filePath, ASSEMBLY_SCHEMA, Manifest.patchStackTagsOnRead, options);\n  }\n\n  /**\n   * Validates and saves the asset manifest to file.\n   *\n   * @param manifest - manifest.\n   * @param filePath - output file path.\n   */\n  public static saveAssetManifest(manifest: assets.AssetManifest, filePath: string) {\n    Manifest.saveManifest(manifest, filePath, ASSETS_SCHEMA, Manifest.patchStackTagsOnRead);\n  }\n\n  /**\n   * Load and validates the asset manifest from file.\n   *\n   * @param filePath - path to the manifest file.\n   */\n  public static loadAssetManifest(filePath: string): assets.AssetManifest {\n    return this.loadManifest(filePath, ASSETS_SCHEMA);\n  }\n\n  /**\n   * Validates and saves the integ manifest to file.\n   *\n   * @param manifest - manifest.\n   * @param filePath - output file path.\n   */\n  public static saveIntegManifest(manifest: integ.IntegManifest, filePath: string) {\n    Manifest.saveManifest(manifest, filePath, INTEG_SCHEMA);\n  }\n\n  /**\n   * Load and validates the integ manifest from file.\n   *\n   * @param filePath - path to the manifest file.\n   */\n  public static loadIntegManifest(filePath: string): integ.IntegManifest {\n    return this.loadManifest(filePath, INTEG_SCHEMA);\n  }\n\n  /**\n   * Fetch the current schema version number.\n   */\n  public static version(): string {\n    return SCHEMA_VERSION;\n  }\n\n  /**\n   * Deprecated\n   * @deprecated use `saveAssemblyManifest()`\n   */\n  public static save(manifest: assembly.AssemblyManifest, filePath: string) { return this.saveAssemblyManifest(manifest, filePath); }\n\n  /**\n   * Deprecated\n   * @deprecated use `loadAssemblyManifest()`\n   */\n  public static load(filePath: string): assembly.AssemblyManifest { return this.loadAssemblyManifest(filePath); }\n\n  private static validate(manifest: { version: string }, schema: jsonschema.Schema, options?: LoadManifestOptions) {\n    function parseVersion(version: string) {\n      const ver = semver.valid(version);\n      if (!ver) {\n        throw new Error(`Invalid semver string: \"${version}\"`);\n      }\n      return ver;\n    }\n\n    const maxSupported = parseVersion(Manifest.version());\n    const actual = parseVersion(manifest.version);\n\n    // first validate the version should be accepted.\n    if (semver.gt(actual, maxSupported) && !options?.skipVersionCheck) {\n      // we use a well known error prefix so that the CLI can identify this specific error\n      // and print some more context to the user.\n      throw new Error(`${VERSION_MISMATCH}: Maximum schema version supported is ${maxSupported}, but found ${actual}`);\n    }\n\n    // now validate the format is good.\n    const validator = new jsonschema.Validator();\n    const result = validator.validate(manifest, schema, {\n\n      // does exist but is not in the TypeScript definitions\n      nestedErrors: true,\n\n      allowUnknownAttributes: false,\n\n    } as any);\n\n    let errors = result.errors;\n    if (options?.skipEnumCheck) {\n      // Enum validations aren't useful when\n      errors = stripEnumErrors(errors);\n    }\n\n    if (errors.length > 0) {\n      throw new Error(`Invalid assembly manifest:\\n${errors.map(e => e.stack).join('\\n')}`);\n    }\n  }\n\n  private static saveManifest(manifest: any, filePath: string, schema: jsonschema.Schema, preprocess?: (obj: any) => any) {\n    let withVersion = { ...manifest, version: Manifest.version() };\n    Manifest.validate(withVersion, schema);\n    if (preprocess) {\n      withVersion = preprocess(withVersion);\n    }\n    fs.writeFileSync(filePath, JSON.stringify(withVersion, undefined, 2));\n  }\n\n  private static loadManifest(filePath: string, schema: jsonschema.Schema, preprocess?: (obj: any) => any, options?: LoadManifestOptions) {\n    let obj = JSON.parse(fs.readFileSync(filePath, { encoding: 'utf-8' }));\n    if (preprocess) {\n      obj = preprocess(obj);\n    }\n    Manifest.validate(obj, schema, options);\n    return obj;\n  }\n\n  /**\n   * This requires some explaining...\n   *\n   * We previously used `{ Key, Value }` for the object that represents a stack tag. (Notice the casing)\n   * @link https://github.com/aws/aws-cdk/blob/v1.27.0/packages/aws-cdk/lib/api/cxapp/stacks.ts#L427.\n   *\n   * When that object moved to this package, it had to be JSII compliant, which meant the property\n   * names must be `camelCased`, and not `PascalCased`. This meant it no longer matches the structure in the `manifest.json` file.\n   * In order to support current manifest files, we have to translate the `PascalCased` representation to the new `camelCased` one.\n   *\n   * Note that the serialization itself still writes `PascalCased` because it relates to how CloudFormation expects it.\n   *\n   * Ideally, we would start writing the `camelCased` and translate to how CloudFormation expects it when needed. But this requires nasty\n   * backwards-compatibility code and it just doesn't seem to be worth the effort.\n   */\n  private static patchStackTagsOnRead(manifest: assembly.AssemblyManifest) {\n    return Manifest.replaceStackTags(manifest, tags => tags.map((diskTag: any) => ({\n      key: diskTag.Key,\n      value: diskTag.Value,\n    })));\n  }\n\n  /**\n   * See explanation on `patchStackTagsOnRead`\n   *\n   * Translate stack tags metadata if it has the \"right\" casing.\n   */\n  private static patchStackTagsOnWrite(manifest: assembly.AssemblyManifest) {\n    return Manifest.replaceStackTags(manifest, tags => tags.map(memTag =>\n      // Might already be uppercased (because stack synthesis generates it in final form yet)\n      ('Key' in memTag ? memTag : { Key: memTag.key, Value: memTag.value }) as any,\n    ));\n  }\n\n  /**\n   * Recursively replace stack tags in the stack metadata\n   */\n  private static replaceStackTags(manifest: assembly.AssemblyManifest, fn: Endofunctor<assembly.StackTagsMetadataEntry>): assembly.AssemblyManifest {\n    // Need to add in the `noUndefined`s because otherwise jest snapshot tests are going to freak out\n    // about the keys with values that are `undefined` (even though they would never be JSON.stringified)\n    return noUndefined({\n      ...manifest,\n      artifacts: mapValues(manifest.artifacts, artifact => {\n        if (artifact.type !== assembly.ArtifactType.AWS_CLOUDFORMATION_STACK) { return artifact; }\n        return noUndefined({\n          ...artifact,\n          metadata: mapValues(artifact.metadata, metadataEntries => metadataEntries.map(metadataEntry => {\n            if (metadataEntry.type !== assembly.ArtifactMetadataEntryType.STACK_TAGS || !metadataEntry.data) { return metadataEntry; }\n            return {\n              ...metadataEntry,\n              data: fn(metadataEntry.data as assembly.StackTagsMetadataEntry),\n            };\n          })),\n        } as assembly.ArtifactManifest);\n      }),\n    });\n  }\n\n  private constructor() {}\n}\n\ntype Endofunctor<A> = (x: A) => A;\n\nfunction mapValues<A, B>(xs: Record<string, A> | undefined, fn: (x: A) => B): Record<string, B> | undefined {\n  if (!xs) { return undefined; }\n  const ret: Record<string, B> | undefined = {};\n  for (const [k, v] of Object.entries(xs)) {\n    ret[k] = fn(v);\n  }\n  return ret;\n}\n\nfunction noUndefined<A extends object>(xs: A): A {\n  const ret: any = {};\n  for (const [k, v] of Object.entries(xs)) {\n    if (v !== undefined) {\n      ret[k] = v;\n    }\n  }\n  return ret;\n}\n\nfunction stripEnumErrors(errors: jsonschema.ValidationError[]) {\n  return errors.filter(e => typeof e.schema ==='string' || !('enum' in e.schema));\n}\n"],
  "mappings": "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",
  "names": []
}
