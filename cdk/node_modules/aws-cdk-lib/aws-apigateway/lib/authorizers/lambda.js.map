{
  "version": 3,
  "sources": ["lambda.ts"],
  "sourcesContent": ["import * as iam from '../../../aws-iam';\nimport * as lambda from '../../../aws-lambda';\nimport { Arn, ArnFormat, Duration, Lazy, Names, Stack } from '../../../core';\nimport { Construct } from 'constructs';\nimport { CfnAuthorizer } from '../apigateway.generated';\nimport { Authorizer, IAuthorizer } from '../authorizer';\nimport { IRestApi } from '../restapi';\n\n/**\n * Base properties for all lambda authorizers\n */\nexport interface LambdaAuthorizerProps {\n  /**\n   * An optional human friendly name for the authorizer. Note that, this is not the primary identifier of the authorizer.\n   *\n   * @default - the unique construcrt ID\n   */\n  readonly authorizerName?: string;\n\n  /**\n   * The handler for the authorizer lambda function.\n   *\n   * The handler must follow a very specific protocol on the input it receives and the output it needs to produce.\n   * API Gateway has documented the handler's input specification\n   * {@link https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-lambda-authorizer-input.html | here} and output specification\n   * {@link https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-lambda-authorizer-output.html | here}.\n   */\n  readonly handler: lambda.IFunction;\n\n  /**\n   * How long APIGateway should cache the results. Max 1 hour.\n   * Disable caching by setting this to 0.\n   *\n   * @default Duration.minutes(5)\n   */\n  readonly resultsCacheTtl?: Duration;\n\n  /**\n   * An optional IAM role for APIGateway to assume before calling the Lambda-based authorizer. The IAM role must be\n   * assumable by 'apigateway.amazonaws.com'.\n   *\n   * @default - A resource policy\u00A0is added to the Lambda function allowing apigateway.amazonaws.com to invoke the function.\n   */\n  readonly assumeRole?: iam.IRole;\n}\n\nabstract class LambdaAuthorizer extends Authorizer implements IAuthorizer {\n\n  /**\n   * The id of the authorizer.\n   * @attribute\n   */\n  public abstract readonly authorizerId: string;\n\n  /**\n   * The ARN of the authorizer to be used in permission policies, such as IAM and resource-based grants.\n   */\n  public abstract readonly authorizerArn: string;\n\n  /**\n   * The Lambda function handler that this authorizer uses.\n   */\n  protected readonly handler: lambda.IFunction;\n\n  /**\n   * The IAM role that the API Gateway service assumes while invoking the Lambda function.\n   */\n  protected readonly role?: iam.IRole;\n\n  protected restApiId?: string;\n\n  protected constructor(scope: Construct, id: string, props: LambdaAuthorizerProps) {\n    super(scope, id);\n\n    this.handler = props.handler;\n    this.role = props.assumeRole;\n\n    if (props.resultsCacheTtl && props.resultsCacheTtl?.toSeconds() > 3600) {\n      throw new Error('Lambda authorizer property \\'resultsCacheTtl\\' must not be greater than 3600 seconds (1 hour)');\n    }\n  }\n\n  /**\n   * Attaches this authorizer to a specific REST API.\n   * @internal\n   */\n  public _attachToApi(restApi: IRestApi) {\n    if (this.restApiId && this.restApiId !== restApi.restApiId) {\n      throw new Error('Cannot attach authorizer to two different rest APIs');\n    }\n\n    this.restApiId = restApi.restApiId;\n  }\n\n  /**\n   * Sets up the permissions necessary for the API Gateway service to invoke the Lambda function.\n   */\n  protected setupPermissions() {\n    if (!this.role) {\n      this.handler.addPermission(`${Names.uniqueId(this)}:Permissions`, {\n        principal: new iam.ServicePrincipal('apigateway.amazonaws.com'),\n        sourceArn: this.authorizerArn,\n      });\n    } else if (this.role instanceof iam.Role) { // i.e. not imported\n      this.role.attachInlinePolicy(new iam.Policy(this, 'authorizerInvokePolicy', {\n        statements: [\n          new iam.PolicyStatement({\n            resources: this.handler.resourceArnsForGrantInvoke,\n            actions: ['lambda:InvokeFunction'],\n          }),\n        ],\n      }));\n    }\n  }\n\n  /**\n   * Returns a token that resolves to the Rest Api Id at the time of synthesis.\n   * Throws an error, during token resolution, if no RestApi is attached to this authorizer.\n   */\n  protected lazyRestApiId() {\n    return Lazy.string({\n      produce: () => {\n        if (!this.restApiId) {\n          throw new Error(`Authorizer (${this.node.path}) must be attached to a RestApi`);\n        }\n        return this.restApiId;\n      },\n    });\n  }\n}\n\n/**\n * Properties for TokenAuthorizer\n */\nexport interface TokenAuthorizerProps extends LambdaAuthorizerProps {\n  /**\n   * An optional regex to be matched against the authorization token. When matched the authorizer lambda is invoked,\n   * otherwise a 401 Unauthorized is returned to the client.\n   *\n   * @default - no regex filter will be applied.\n   */\n  readonly validationRegex?: string;\n\n  /**\n   * The request header mapping expression for the bearer token. This is typically passed as part of the header, in which case\n   * this should be `method.request.header.Authorizer` where Authorizer is the header containing the bearer token.\n   * @see https://docs.aws.amazon.com/apigateway/api-reference/link-relation/authorizer-create/#identitySource\n   * @default `IdentitySource.header('Authorization')`\n   */\n  readonly identitySource?: string;\n}\n\n/**\n * Token based lambda authorizer that recognizes the caller's identity as a bearer token,\n * such as a JSON Web Token (JWT) or an OAuth token.\n * Based on the token, authorization is performed by a lambda function.\n *\n * @resource AWS::ApiGateway::Authorizer\n */\nexport class TokenAuthorizer extends LambdaAuthorizer {\n\n  public readonly authorizerId: string;\n\n  public readonly authorizerArn: string;\n\n  constructor(scope: Construct, id: string, props: TokenAuthorizerProps) {\n    super(scope, id, props);\n\n    const restApiId = this.lazyRestApiId();\n    const resource = new CfnAuthorizer(this, 'Resource', {\n      name: props.authorizerName ?? Names.uniqueId(this),\n      restApiId,\n      type: 'TOKEN',\n      authorizerUri: lambdaAuthorizerArn(props.handler),\n      authorizerCredentials: props.assumeRole?.roleArn,\n      authorizerResultTtlInSeconds: props.resultsCacheTtl?.toSeconds(),\n      identitySource: props.identitySource || 'method.request.header.Authorization',\n      identityValidationExpression: props.validationRegex,\n    });\n\n    this.authorizerId = resource.ref;\n    this.authorizerArn = Stack.of(this).formatArn({\n      service: 'execute-api',\n      resource: restApiId,\n      resourceName: `authorizers/${this.authorizerId}`,\n    });\n\n    this.setupPermissions();\n  }\n}\n\n/**\n * Properties for RequestAuthorizer\n */\nexport interface RequestAuthorizerProps extends LambdaAuthorizerProps {\n  /**\n   * An array of request header mapping expressions for identities. Supported parameter types are\n   * Header, Query String, Stage Variable, and Context. For instance, extracting an authorization\n   * token from a header would use the identity source `IdentitySource.header('Authorizer')`.\n   *\n   * Note: API Gateway uses the specified identity sources as the request authorizer caching key. When caching is\n   * enabled, API Gateway calls the authorizer's Lambda function only after successfully verifying that all the\n   * specified identity sources are present at runtime. If a specified identify source is missing, null, or empty,\n   * API Gateway returns a 401 Unauthorized response without calling the authorizer Lambda function.\n   *\n   * @see https://docs.aws.amazon.com/apigateway/api-reference/link-relation/authorizer-create/#identitySource\n   */\n  readonly identitySources: string[];\n}\n\n/**\n * Request-based lambda authorizer that recognizes the caller's identity via request parameters,\n * such as headers, paths, query strings, stage variables, or context variables.\n * Based on the request, authorization is performed by a lambda function.\n *\n * @resource AWS::ApiGateway::Authorizer\n */\nexport class RequestAuthorizer extends LambdaAuthorizer {\n\n  public readonly authorizerId: string;\n\n  public readonly authorizerArn: string;\n\n  constructor(scope: Construct, id: string, props: RequestAuthorizerProps) {\n    super(scope, id, props);\n\n    if ((props.resultsCacheTtl === undefined || props.resultsCacheTtl.toSeconds() !== 0) && props.identitySources.length === 0) {\n      throw new Error('At least one Identity Source is required for a REQUEST-based Lambda authorizer if caching is enabled.');\n    }\n\n    const restApiId = this.lazyRestApiId();\n    const resource = new CfnAuthorizer(this, 'Resource', {\n      name: props.authorizerName ?? Names.uniqueId(this),\n      restApiId,\n      type: 'REQUEST',\n      authorizerUri: lambdaAuthorizerArn(props.handler),\n      authorizerCredentials: props.assumeRole?.roleArn,\n      authorizerResultTtlInSeconds: props.resultsCacheTtl?.toSeconds(),\n      identitySource: props.identitySources.map(is => is.toString()).join(','),\n    });\n\n    this.authorizerId = resource.ref;\n    this.authorizerArn = Stack.of(this).formatArn({\n      service: 'execute-api',\n      resource: restApiId,\n      resourceName: `authorizers/${this.authorizerId}`,\n    });\n\n    this.setupPermissions();\n  }\n}\n\n/**\n * constructs the authorizerURIArn.\n */\nfunction lambdaAuthorizerArn(handler: lambda.IFunction) {\n  const { region, partition } = Arn.split( handler.functionArn, ArnFormat.COLON_RESOURCE_NAME);\n  return `arn:${partition}:apigateway:${region}:lambda:path/2015-03-31/functions/${handler.functionArn}/invocations`;\n}\n"],
  "mappings": "sPAAA,IAAA,QAAA,kBAAA,EAEA,OAAA,QAAA,eAAA,EAEA,uBAAA,QAAA,yBAAA,EACA,aAAA,QAAA,eAAA,EAyCA,MAAe,wBAAyB,cAAA,UAAU,CAyBhD,YAAsB,MAAkB,GAAY,MAA4B,QAC9E,MAAM,MAAO,EAAE,EAKf,GAHA,KAAK,QAAU,MAAM,QACrB,KAAK,KAAO,MAAM,WAEd,MAAM,iBAAmB,KAAA,MAAM,mBAAe,MAAA,KAAA,OAAA,OAAA,GAAE,UAAS,GAAK,KAChE,KAAM,IAAI,OAAM,6FAA+F,EAQ5G,aAAa,QAAiB,CACnC,GAAI,KAAK,WAAa,KAAK,YAAc,QAAQ,UAC/C,KAAM,IAAI,OAAM,qDAAqD,EAGvE,KAAK,UAAY,QAAQ,UAMjB,kBAAgB,CACxB,AAAK,KAAK,KAKC,KAAK,eAAgB,KAAI,MAClC,KAAK,KAAK,mBAAmB,GAAI,KAAI,OAAO,KAAM,yBAA0B,CAC1E,WAAY,CACV,GAAI,KAAI,gBAAgB,CACtB,UAAW,KAAK,QAAQ,2BACxB,QAAS,CAAC,uBAAuB,EAClC,GAEJ,CAAC,EAZF,KAAK,QAAQ,cAAc,GAAG,OAAA,MAAM,SAAS,IAAI,gBAAiB,CAChE,UAAW,GAAI,KAAI,iBAAiB,0BAA0B,EAC9D,UAAW,KAAK,cACjB,EAiBK,eAAa,CACrB,MAAO,QAAA,KAAK,OAAO,CACjB,QAAS,IAAK,CACZ,GAAI,CAAC,KAAK,UACR,KAAM,IAAI,OAAM,eAAe,KAAK,KAAK,qCAAqC,EAEhF,MAAO,MAAK,SACd,EACD,GAgCL,MAAa,uBAAwB,iBAAgB,CAMnD,YAAY,MAAkB,GAAY,MAA2B,cACnE,MAAM,MAAO,GAAI,KAAK,iFAEtB,KAAM,WAAY,KAAK,cAAa,EAC9B,SAAW,GAAI,wBAAA,cAAc,KAAM,WAAY,CACnD,KAAI,IAAE,MAAM,kBAAc,MAAA,KAAA,OAAA,GAAI,OAAA,MAAM,SAAS,IAAI,EACjD,UACA,KAAM,QACN,cAAe,oBAAoB,MAAM,OAAO,EAChD,sBAAqB,IAAE,MAAM,cAAU,MAAA,KAAA,OAAA,OAAA,GAAE,QACzC,6BAA4B,IAAE,MAAM,mBAAe,MAAA,KAAA,OAAA,OAAA,GAAE,UAAS,EAC9D,eAAgB,MAAM,gBAAkB,sCACxC,6BAA8B,MAAM,gBACrC,EAED,KAAK,aAAe,SAAS,IAC7B,KAAK,cAAgB,OAAA,MAAM,GAAG,IAAI,EAAE,UAAU,CAC5C,QAAS,cACT,SAAU,UACV,aAAc,eAAe,KAAK,eACnC,EAED,KAAK,iBAAgB,GA5BzB,QAAA,gBAAA,8HA0DA,MAAa,yBAA0B,iBAAgB,CAMrD,YAAY,MAAkB,GAAY,MAA6B,cACrE,MAAM,MAAO,GAAI,KAAK,EAEtB,oFAAK,OAAM,kBAAoB,QAAa,MAAM,gBAAgB,UAAS,IAAO,IAAM,MAAM,gBAAgB,SAAW,EACvH,KAAM,IAAI,OAAM,uGAAuG,EAGzH,KAAM,WAAY,KAAK,cAAa,EAC9B,SAAW,GAAI,wBAAA,cAAc,KAAM,WAAY,CACnD,KAAI,IAAE,MAAM,kBAAc,MAAA,KAAA,OAAA,GAAI,OAAA,MAAM,SAAS,IAAI,EACjD,UACA,KAAM,UACN,cAAe,oBAAoB,MAAM,OAAO,EAChD,sBAAqB,IAAE,MAAM,cAAU,MAAA,KAAA,OAAA,OAAA,GAAE,QACzC,6BAA4B,IAAE,MAAM,mBAAe,MAAA,KAAA,OAAA,OAAA,GAAE,UAAS,EAC9D,eAAgB,MAAM,gBAAgB,IAAI,IAAM,GAAG,SAAQ,CAAE,EAAE,KAAK,GAAG,EACxE,EAED,KAAK,aAAe,SAAS,IAC7B,KAAK,cAAgB,OAAA,MAAM,GAAG,IAAI,EAAE,UAAU,CAC5C,QAAS,cACT,SAAU,UACV,aAAc,eAAe,KAAK,eACnC,EAED,KAAK,iBAAgB,GA/BzB,QAAA,kBAAA,oIAsCA,6BAA6B,QAAyB,CACpD,KAAM,CAAE,OAAQ,WAAc,OAAA,IAAI,MAAO,QAAQ,YAAa,OAAA,UAAU,mBAAmB,EAC3F,MAAO,OAAO,wBAAwB,2CAA2C,QAAQ,yBAC3F",
  "names": []
}
