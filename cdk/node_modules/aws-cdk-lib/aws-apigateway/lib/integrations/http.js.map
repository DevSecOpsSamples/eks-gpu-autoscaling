{
  "version": 3,
  "sources": ["http.ts"],
  "sourcesContent": ["import { Integration, IntegrationOptions, IntegrationType } from '../integration';\n\nexport interface HttpIntegrationProps {\n  /**\n   * Determines whether to use proxy integration or custom integration.\n   *\n   * @default true\n   */\n  readonly proxy?: boolean;\n\n  /**\n   * HTTP method to use when invoking the backend URL.\n   * @default GET\n   */\n  readonly httpMethod?: string;\n\n  /**\n   * Integration options, such as request/resopnse mapping, content handling,\n   * etc.\n   *\n   * @default defaults based on `IntegrationOptions` defaults\n   */\n  readonly options?: IntegrationOptions;\n}\n\n/**\n * You can integrate an API method with an HTTP endpoint using the HTTP proxy\n * integration or the HTTP custom integration,.\n *\n * With the proxy integration, the setup is simple. You only need to set the\n * HTTP method and the HTTP endpoint URI, according to the backend requirements,\n * if you are not concerned with content encoding or caching.\n *\n * With the custom integration, the setup is more involved. In addition to the\n * proxy integration setup steps, you need to specify how the incoming request\n * data is mapped to the integration request and how the resulting integration\n * response data is mapped to the method response.\n */\nexport class HttpIntegration extends Integration {\n  constructor(url: string, props: HttpIntegrationProps = { }) {\n    const proxy = props.proxy ?? true;\n    const method = props.httpMethod || 'GET';\n    super({\n      type: proxy ? IntegrationType.HTTP_PROXY : IntegrationType.HTTP,\n      integrationHttpMethod: method,\n      uri: url,\n      options: props.options,\n    });\n  }\n}\n"],
  "mappings": "yNAAA,cAAA,QAAA,gBAAA,EAsCA,MAAa,uBAAwB,eAAA,WAAW,CAC9C,YAAY,IAAa,MAA8B,CAAA,EAAG,uFACxD,KAAM,OAAK,IAAG,MAAM,SAAK,MAAA,KAAA,OAAA,GAAI,GACvB,OAAS,MAAM,YAAc,MACnC,MAAM,CACJ,KAAM,MAAQ,cAAA,gBAAgB,WAAa,cAAA,gBAAgB,KAC3D,sBAAuB,OACvB,IAAK,IACL,QAAS,MAAM,QAChB,GATL,QAAA,gBAAA",
  "names": []
}
