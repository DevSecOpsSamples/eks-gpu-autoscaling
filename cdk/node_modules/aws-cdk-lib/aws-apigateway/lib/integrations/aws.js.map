{
  "version": 3,
  "sources": ["aws.ts"],
  "sourcesContent": ["import * as cdk from '../../../core';\nimport { ArnFormat } from '../../../core';\nimport { IConstruct } from 'constructs';\nimport { Integration, IntegrationConfig, IntegrationOptions, IntegrationType } from '../integration';\nimport { Method } from '../method';\nimport { parseAwsApiCall } from '../util';\n\nexport interface AwsIntegrationProps {\n  /**\n   * Use AWS_PROXY integration.\n   *\n   * @default false\n   */\n  readonly proxy?: boolean;\n\n  /**\n   * The name of the integrated AWS service (e.g. `s3`)\n   */\n  readonly service: string;\n\n  /**\n   * A designated subdomain supported by certain AWS service for fast\n   * host-name lookup.\n   */\n  readonly subdomain?: string;\n\n  /**\n   * The path to use for path-base APIs.\n   *\n   * For example, for S3 GET, you can set path to `bucket/key`.\n   * For lambda, you can set path to `2015-03-31/functions/${function-arn}/invocations`\n   *\n   * Mutually exclusive with the `action` options.\n   */\n  readonly path?: string;\n\n  /**\n   * The AWS action to perform in the integration.\n   *\n   * Use `actionParams` to specify key-value params for the action.\n   *\n   * Mutually exclusive with `path`.\n   */\n  readonly action?: string;\n\n  /**\n   * Parameters for the action.\n   *\n   * `action` must be set, and `path` must be undefined.\n   * The action params will be URL encoded.\n   */\n  readonly actionParameters?: { [key: string]: string };\n\n  /**\n   * The integration's HTTP method type.\n   *\n   * @default POST\n   */\n  readonly integrationHttpMethod?: string;\n\n  /**\n   * Integration options, such as content handling, request/response mapping, etc.\n   */\n  readonly options?: IntegrationOptions\n\n  /**\n   * The region of the integrated AWS service.\n   *\n   * @default - same region as the stack\n   */\n  readonly region?: string;\n}\n\n/**\n * This type of integration lets an API expose AWS service actions. It is\n * intended for calling all AWS service actions, but is not recommended for\n * calling a Lambda function, because the Lambda custom integration is a legacy\n * technology.\n */\nexport class AwsIntegration extends Integration {\n  private scope?: IConstruct;\n\n  constructor(props: AwsIntegrationProps) {\n    const backend = props.subdomain ? `${props.subdomain}.${props.service}` : props.service;\n    const type = props.proxy ? IntegrationType.AWS_PROXY : IntegrationType.AWS;\n    const { apiType, apiValue } = parseAwsApiCall(props.path, props.action, props.actionParameters);\n    super({\n      type,\n      integrationHttpMethod: props.integrationHttpMethod || 'POST',\n      uri: cdk.Lazy.string({\n        produce: () => {\n          if (!this.scope) { throw new Error('AwsIntegration must be used in API'); }\n          return cdk.Stack.of(this.scope).formatArn({\n            service: 'apigateway',\n            account: backend,\n            resource: apiType,\n            arnFormat: ArnFormat.SLASH_RESOURCE_NAME,\n            resourceName: apiValue,\n            region: props.region,\n          });\n        },\n      }),\n      options: props.options,\n    });\n  }\n\n  public bind(method: Method): IntegrationConfig {\n    const bindResult = super.bind(method);\n    this.scope = method;\n    return bindResult;\n  }\n}\n"],
  "mappings": "wNAAA,IAAA,QAAA,eAAA,EACA,OAAA,QAAA,eAAA,EAEA,cAAA,QAAA,gBAAA,EAEA,OAAA,QAAA,SAAA,EA0EA,MAAa,sBAAuB,eAAA,WAAW,CAG7C,YAAY,MAA0B,+EACpC,KAAM,SAAU,MAAM,UAAY,GAAG,MAAM,aAAa,MAAM,UAAY,MAAM,QAC1E,KAAO,MAAM,MAAQ,cAAA,gBAAgB,UAAY,cAAA,gBAAgB,IACjE,CAAE,QAAS,UAAa,OAAA,gBAAgB,MAAM,KAAM,MAAM,OAAQ,MAAM,gBAAgB,EAC9F,MAAM,CACJ,KACA,sBAAuB,MAAM,uBAAyB,OACtD,IAAK,IAAI,KAAK,OAAO,CACnB,QAAS,IAAK,CACZ,GAAI,CAAC,KAAK,MAAS,KAAM,IAAI,OAAM,oCAAoC,EACvE,MAAO,KAAI,MAAM,GAAG,KAAK,KAAK,EAAE,UAAU,CACxC,QAAS,aACT,QAAS,QACT,SAAU,QACV,UAAW,OAAA,UAAU,oBACrB,aAAc,SACd,OAAQ,MAAM,OACf,CACH,EACD,EACD,QAAS,MAAM,QAChB,EAGI,KAAK,OAAc,mEACxB,KAAM,YAAa,MAAM,KAAK,MAAM,EACpC,YAAK,MAAQ,OACN,YA9BX,QAAA,eAAA",
  "names": []
}
