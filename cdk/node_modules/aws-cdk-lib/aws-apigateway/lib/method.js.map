{
  "version": 3,
  "sources": ["method.ts"],
  "sourcesContent": ["import { ArnFormat, Lazy, Resource, Stack } from '../../core';\nimport { Construct } from 'constructs';\nimport { CfnMethod, CfnMethodProps } from './apigateway.generated';\nimport { Authorizer, IAuthorizer } from './authorizer';\nimport { Integration, IntegrationConfig } from './integration';\nimport { MockIntegration } from './integrations/mock';\nimport { MethodResponse } from './methodresponse';\nimport { IModel } from './model';\nimport { IRequestValidator, RequestValidatorOptions } from './requestvalidator';\nimport { IResource } from './resource';\nimport { IRestApi, RestApi, RestApiBase } from './restapi';\nimport { validateHttpMethod } from './util';\n\nexport interface MethodOptions {\n  /**\n   * A friendly operation name for the method. For example, you can assign the\n   * OperationName of ListPets for the GET /pets method.\n   */\n  readonly operationName?: string;\n\n  /**\n   * Method authorization.\n   * If the value is set of `Custom`, an `authorizer` must also be specified.\n   *\n   * If you're using one of the authorizers that are available via the {@link Authorizer} class, such as {@link Authorizer#token()},\n   * it is recommended that this option not be specified. The authorizer will take care of setting the correct authorization type.\n   * However, specifying an authorization type using this property that conflicts with what is expected by the {@link Authorizer}\n   * will result in an error.\n   *\n   * @default - open access unless `authorizer` is specified\n   */\n  readonly authorizationType?: AuthorizationType;\n\n  /**\n   * If `authorizationType` is `Custom`, this specifies the ID of the method\n   * authorizer resource.\n   * If specified, the value of `authorizationType` must be set to `Custom`\n   */\n  readonly authorizer?: IAuthorizer;\n\n  /**\n   * Indicates whether the method requires clients to submit a valid API key.\n   * @default false\n   */\n  readonly apiKeyRequired?: boolean;\n\n  /**\n   * The responses that can be sent to the client who calls the method.\n   * @default None\n   *\n   * This property is not required, but if these are not supplied for a Lambda\n   * proxy integration, the Lambda function must return a value of the correct format,\n   * for the integration response to be correctly mapped to a response to the client.\n   * @see https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-method-settings-method-response.html\n   */\n  readonly methodResponses?: MethodResponse[];\n\n  /**\n   * The request parameters that API Gateway accepts. Specify request parameters\n   * as key-value pairs (string-to-Boolean mapping), with a source as the key and\n   * a Boolean as the value. The Boolean specifies whether a parameter is required.\n   * A source must match the format method.request.location.name, where the location\n   * is querystring, path, or header, and name is a valid, unique parameter name.\n   * @default None\n   */\n  readonly requestParameters?: { [param: string]: boolean };\n\n  /**\n   * The models which describe data structure of request payload. When\n   * combined with `requestValidator` or `requestValidatorOptions`, the service\n   * will validate the API request payload before it reaches the API's Integration (including proxies).\n   * Specify `requestModels` as key-value pairs, with a content type\n   * (e.g. `'application/json'`) as the key and an API Gateway Model as the value.\n   *\n   * @example\n   *\n   *     declare const api: apigateway.RestApi;\n   *     declare const userLambda: lambda.Function;\n   *\n   *     const userModel: apigateway.Model = api.addModel('UserModel', {\n   *         schema: {\n   *             type: apigateway.JsonSchemaType.OBJECT,\n   *             properties: {\n   *                 userId: {\n   *                     type: apigateway.JsonSchemaType.STRING\n   *                 },\n   *                 name: {\n   *                     type: apigateway.JsonSchemaType.STRING\n   *                 }\n   *             },\n   *             required: ['userId']\n   *         }\n   *     });\n   *     api.root.addResource('user').addMethod('POST',\n   *         new apigateway.LambdaIntegration(userLambda), {\n   *             requestModels: {\n   *                 'application/json': userModel\n   *             }\n   *         }\n   *     );\n   *\n   * @see https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-method-settings-method-request.html#setup-method-request-model\n   */\n  readonly requestModels?: { [param: string]: IModel };\n\n  /**\n   * The ID of the associated request validator.\n   * Only one of `requestValidator` or `requestValidatorOptions` must be specified.\n   * Works together with `requestModels` or `requestParameters` to validate\n   * the request before it reaches integration like Lambda Proxy Integration.\n   * @default - No default validator\n   */\n  readonly requestValidator?: IRequestValidator;\n\n  /**\n   * A list of authorization scopes configured on the method. The scopes are used with\n   * a COGNITO_USER_POOLS authorizer to authorize the method invocation.\n   * @see https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-apigateway-method.html#cfn-apigateway-method-authorizationscopes\n   * @default - no authorization scopes\n   */\n  readonly authorizationScopes?: string[];\n\n  /**\n   * Request validator options to create new validator\n   * Only one of `requestValidator` or `requestValidatorOptions` must be specified.\n   * Works together with `requestModels` or `requestParameters` to validate\n   * the request before it reaches integration like Lambda Proxy Integration.\n   * @default - No default validator\n   */\n  readonly requestValidatorOptions?: RequestValidatorOptions;\n}\n\nexport interface MethodProps {\n  /**\n   * The resource this method is associated with. For root resource methods,\n   * specify the `RestApi` object.\n   */\n  readonly resource: IResource;\n\n  /**\n   * The HTTP method (\"GET\", \"POST\", \"PUT\", ...) that clients use to call this method.\n   */\n  readonly httpMethod: string;\n\n  /**\n   * The backend system that the method calls when it receives a request.\n   *\n   * @default - a new `MockIntegration`.\n   */\n  readonly integration?: Integration;\n\n  /**\n   * Method options.\n   *\n   * @default - No options.\n   */\n  readonly options?: MethodOptions;\n}\n\nexport class Method extends Resource {\n  /** @attribute */\n  public readonly methodId: string;\n\n  public readonly httpMethod: string;\n  public readonly resource: IResource;\n  /**\n   * The API Gateway RestApi associated with this method.\n   */\n  public readonly api: IRestApi;\n\n  private methodResponses: MethodResponse[];\n\n  constructor(scope: Construct, id: string, props: MethodProps) {\n    super(scope, id);\n\n    this.resource = props.resource;\n    this.api = props.resource.api;\n    this.httpMethod = props.httpMethod.toUpperCase();\n\n    validateHttpMethod(this.httpMethod);\n\n    const options = props.options || {};\n\n    const defaultMethodOptions = props.resource.defaultMethodOptions || {};\n    const authorizer = options.authorizer || defaultMethodOptions.authorizer;\n    const authorizerId = authorizer?.authorizerId;\n\n    const authorizationTypeOption = options.authorizationType || defaultMethodOptions.authorizationType;\n    const authorizationType = authorizer?.authorizationType || authorizationTypeOption || AuthorizationType.NONE;\n\n    // if the authorizer defines an authorization type and we also have an explicit option set, check that they are the same\n    if (authorizer?.authorizationType && authorizationTypeOption && authorizer?.authorizationType !== authorizationTypeOption) {\n      throw new Error(`${this.resource}/${this.httpMethod} - Authorization type is set to ${authorizationTypeOption} ` +\n        `which is different from what is required by the authorizer [${authorizer.authorizationType}]`);\n    }\n\n    if (Authorizer.isAuthorizer(authorizer)) {\n      authorizer._attachToApi(this.api);\n    }\n\n    this.methodResponses = options.methodResponses ?? [];\n\n    const integration = props.integration ?? this.resource.defaultIntegration ?? new MockIntegration();\n    const bindResult = integration.bind(this);\n\n    const methodProps: CfnMethodProps = {\n      resourceId: props.resource.resourceId,\n      restApiId: this.api.restApiId,\n      httpMethod: this.httpMethod,\n      operationName: options.operationName || defaultMethodOptions.operationName,\n      apiKeyRequired: options.apiKeyRequired || defaultMethodOptions.apiKeyRequired,\n      authorizationType,\n      authorizerId,\n      requestParameters: options.requestParameters || defaultMethodOptions.requestParameters,\n      integration: this.renderIntegration(bindResult),\n      methodResponses: Lazy.any({ produce: () => this.renderMethodResponses(this.methodResponses) }, { omitEmptyArray: true }),\n      requestModels: this.renderRequestModels(options.requestModels),\n      requestValidatorId: this.requestValidatorId(options),\n      authorizationScopes: options.authorizationScopes ?? defaultMethodOptions.authorizationScopes,\n    };\n\n    const resource = new CfnMethod(this, 'Resource', methodProps);\n\n    this.methodId = resource.ref;\n\n    if (RestApiBase._isRestApiBase(props.resource.api)) {\n      props.resource.api._attachMethod(this);\n    }\n\n    const deployment = props.resource.api.latestDeployment;\n    if (deployment) {\n      deployment.node.addDependency(resource);\n      deployment.addToLogicalId({\n        method: {\n          ...methodProps,\n          integrationToken: bindResult?.deploymentToken,\n        },\n      });\n    }\n  }\n\n  /**\n   * The RestApi associated with this Method\n   * @deprecated - Throws an error if this Resource is not associated with an instance of `RestApi`. Use `api` instead.\n   */\n  public get restApi(): RestApi {\n    return this.resource.restApi;\n  }\n\n  /**\n   * Returns an execute-api ARN for this method:\n   *\n   *   arn:aws:execute-api:{region}:{account}:{restApiId}/{stage}/{method}/{path}\n   *\n   * NOTE: {stage} will refer to the `restApi.deploymentStage`, which will\n   * automatically set if auto-deploy is enabled, or can be explicitly assigned.\n   * When not configured, {stage} will be set to '*', as a shorthand for 'all stages'.\n   *\n   * @attribute\n   */\n  public get methodArn(): string {\n    const stage = this.api.deploymentStage?.stageName;\n    return this.api.arnForExecuteApi(this.httpMethod, pathForArn(this.resource.path), stage);\n  }\n\n  /**\n   * Returns an execute-api ARN for this method's \"test-invoke-stage\" stage.\n   * This stage is used by the AWS Console UI when testing the method.\n   */\n  public get testMethodArn(): string {\n    return this.api.arnForExecuteApi(this.httpMethod, pathForArn(this.resource.path), 'test-invoke-stage');\n  }\n\n  /**\n   * Add a method response to this method\n   */\n  public addMethodResponse(methodResponse: MethodResponse): void {\n    this.methodResponses.push(methodResponse);\n  }\n\n  private renderIntegration(bindResult: IntegrationConfig): CfnMethod.IntegrationProperty {\n    const options = bindResult.options ?? {};\n    let credentials;\n    if (options.credentialsRole) {\n      credentials = options.credentialsRole.roleArn;\n    } else if (options.credentialsPassthrough) {\n      // arn:aws:iam::*:user/*\n      // eslint-disable-next-line max-len\n      credentials = Stack.of(this).formatArn({ service: 'iam', region: '', account: '*', resource: 'user', arnFormat: ArnFormat.SLASH_RESOURCE_NAME, resourceName: '*' });\n    }\n\n    return {\n      type: bindResult.type,\n      uri: bindResult.uri,\n      cacheKeyParameters: options.cacheKeyParameters,\n      cacheNamespace: options.cacheNamespace,\n      contentHandling: options.contentHandling,\n      integrationHttpMethod: bindResult.integrationHttpMethod,\n      requestParameters: options.requestParameters,\n      requestTemplates: options.requestTemplates,\n      passthroughBehavior: options.passthroughBehavior,\n      integrationResponses: options.integrationResponses,\n      connectionType: options.connectionType,\n      connectionId: options.vpcLink ? options.vpcLink.vpcLinkId : undefined,\n      credentials,\n      timeoutInMillis: options.timeout?.toMilliseconds(),\n    };\n  }\n\n  private renderMethodResponses(methodResponses: MethodResponse[] | undefined): CfnMethod.MethodResponseProperty[] | undefined {\n    if (!methodResponses) {\n      // Fall back to nothing\n      return undefined;\n    }\n\n    return methodResponses.map(mr => {\n      let responseModels: {[contentType: string]: string} | undefined;\n\n      if (mr.responseModels) {\n        responseModels = {};\n        for (const contentType in mr.responseModels) {\n          if (mr.responseModels.hasOwnProperty(contentType)) {\n            responseModels[contentType] = mr.responseModels[contentType].modelId;\n          }\n        }\n      }\n\n      const methodResponseProp = {\n        statusCode: mr.statusCode,\n        responseParameters: mr.responseParameters,\n        responseModels,\n      };\n\n      return methodResponseProp;\n    });\n  }\n\n  private renderRequestModels(requestModels: { [param: string]: IModel } | undefined): { [param: string]: string } | undefined {\n    if (!requestModels) {\n      // Fall back to nothing\n      return undefined;\n    }\n\n    const models: {[param: string]: string} = {};\n    for (const contentType in requestModels) {\n      if (requestModels.hasOwnProperty(contentType)) {\n        models[contentType] = requestModels[contentType].modelId;\n      }\n    }\n\n    return models;\n  }\n\n  private requestValidatorId(options: MethodOptions): string | undefined {\n    if (options.requestValidator && options.requestValidatorOptions) {\n      throw new Error('Only one of \\'requestValidator\\' or \\'requestValidatorOptions\\' must be specified.');\n    }\n\n    if (options.requestValidatorOptions) {\n      const validator = (this.api as RestApi).addRequestValidator('validator', options.requestValidatorOptions);\n      return validator.requestValidatorId;\n    }\n\n    // For backward compatibility\n    return options.requestValidator?.requestValidatorId;\n  }\n}\n\nexport enum AuthorizationType {\n  /**\n   * Open access.\n   */\n  NONE = 'NONE',\n\n  /**\n   * Use AWS IAM permissions.\n   */\n  IAM = 'AWS_IAM',\n\n  /**\n   * Use a custom authorizer.\n   */\n  CUSTOM = 'CUSTOM',\n\n  /**\n   * Use an AWS Cognito user pool.\n   */\n  COGNITO = 'COGNITO_USER_POOLS',\n}\n\nfunction pathForArn(path: string): string {\n  return path.replace(/\\{[^\\}]*\\}/g, '*'); // replace path parameters (like '{bookId}') with asterisk\n}\n"],
  "mappings": "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",
  "names": []
}
