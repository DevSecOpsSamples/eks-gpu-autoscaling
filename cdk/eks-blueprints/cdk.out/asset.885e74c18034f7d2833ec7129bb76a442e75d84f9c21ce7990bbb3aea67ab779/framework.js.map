{
  "version": 3,
  "sources": ["framework.ts"],
  "sourcesContent": ["/* eslint-disable max-len */\n/* eslint-disable no-console */\nimport { IsCompleteResponse, OnEventResponse } from '../types';\nimport * as cfnResponse from './cfn-response';\nimport * as consts from './consts';\nimport { invokeFunction, startExecution } from './outbound';\nimport { getEnv, log } from './util';\n\n// use consts for handler names to compiler-enforce the coupling with construction code.\nexport = {\n  [consts.FRAMEWORK_ON_EVENT_HANDLER_NAME]: cfnResponse.safeHandler(onEvent),\n  [consts.FRAMEWORK_IS_COMPLETE_HANDLER_NAME]: cfnResponse.safeHandler(isComplete),\n  [consts.FRAMEWORK_ON_TIMEOUT_HANDLER_NAME]: onTimeout,\n};\n\n/**\n * The main runtime entrypoint of the async custom resource lambda function.\n *\n * Any lifecycle event changes to the custom resources will invoke this handler, which will, in turn,\n * interact with the user-defined `onEvent` and `isComplete` handlers.\n *\n * This function will always succeed. If an error occurs\n *\n * @param cfnRequest The cloudformation custom resource event.\n */\nasync function onEvent(cfnRequest: AWSLambda.CloudFormationCustomResourceEvent) {\n  log('onEventHandler', cfnRequest);\n\n  cfnRequest.ResourceProperties = cfnRequest.ResourceProperties || { };\n\n  const onEventResult = await invokeUserFunction(consts.USER_ON_EVENT_FUNCTION_ARN_ENV, cfnRequest) as OnEventResponse;\n  log('onEvent returned:', onEventResult);\n\n  // merge the request and the result from onEvent to form the complete resource event\n  // this also performs validation.\n  const resourceEvent = createResponseEvent(cfnRequest, onEventResult);\n  log('event:', onEventResult);\n\n  // determine if this is an async provider based on whether we have an isComplete handler defined.\n  // if it is not defined, then we are basically ready to return a positive response.\n  if (!process.env[consts.USER_IS_COMPLETE_FUNCTION_ARN_ENV]) {\n    return cfnResponse.submitResponse('SUCCESS', resourceEvent, { noEcho: resourceEvent.NoEcho });\n  }\n\n  // ok, we are not complete, so kick off the waiter workflow\n  const waiter = {\n    stateMachineArn: getEnv(consts.WAITER_STATE_MACHINE_ARN_ENV),\n    name: resourceEvent.RequestId,\n    input: JSON.stringify(resourceEvent),\n  };\n\n  log('starting waiter', waiter);\n\n  // kick off waiter state machine\n  await startExecution(waiter);\n}\n\n// invoked a few times until `complete` is true or until it times out.\nasync function isComplete(event: AWSCDKAsyncCustomResource.IsCompleteRequest) {\n  log('isComplete', event);\n\n  const isCompleteResult = await invokeUserFunction(consts.USER_IS_COMPLETE_FUNCTION_ARN_ENV, event) as IsCompleteResponse;\n  log('user isComplete returned:', isCompleteResult);\n\n  // if we are not complete, return false, and don't send a response back.\n  if (!isCompleteResult.IsComplete) {\n    if (isCompleteResult.Data && Object.keys(isCompleteResult.Data).length > 0) {\n      throw new Error('\"Data\" is not allowed if \"IsComplete\" is \"False\"');\n    }\n\n    throw new cfnResponse.Retry(JSON.stringify(event));\n  }\n\n  const response = {\n    ...event,\n    ...isCompleteResult,\n    Data: {\n      ...event.Data,\n      ...isCompleteResult.Data,\n    },\n  };\n\n  await cfnResponse.submitResponse('SUCCESS', response, { noEcho: event.NoEcho });\n}\n\n// invoked when completion retries are exhaused.\nasync function onTimeout(timeoutEvent: any) {\n  log('timeoutHandler', timeoutEvent);\n\n  const isCompleteRequest = JSON.parse(JSON.parse(timeoutEvent.Cause).errorMessage) as AWSCDKAsyncCustomResource.IsCompleteRequest;\n  await cfnResponse.submitResponse('FAILED', isCompleteRequest, {\n    reason: 'Operation timed out',\n  });\n}\n\nasync function invokeUserFunction(functionArnEnv: string, payload: any) {\n  const functionArn = getEnv(functionArnEnv);\n  log(`executing user function ${functionArn} with payload`, payload);\n\n  // transient errors such as timeouts, throttling errors (429), and other\n  // errors that aren't caused by a bad request (500 series) are retried\n  // automatically by the JavaScript SDK.\n  const resp = await invokeFunction({\n    FunctionName: functionArn,\n    Payload: JSON.stringify(payload),\n  });\n\n  log('user function response:', resp, typeof(resp));\n\n  const jsonPayload = parseJsonPayload(resp.Payload);\n  if (resp.FunctionError) {\n    log('user function threw an error:', resp.FunctionError);\n\n    const errorMessage = jsonPayload.errorMessage || 'error';\n\n    // parse function name from arn\n    // arn:${Partition}:lambda:${Region}:${Account}:function:${FunctionName}\n    const arn = functionArn.split(':');\n    const functionName = arn[arn.length - 1];\n\n    // append a reference to the log group.\n    const message = [\n      errorMessage,\n      '',\n      `Logs: /aws/lambda/${functionName}`, // cloudwatch log group\n      '',\n    ].join('\\n');\n\n    const e = new Error(message);\n\n    // the output that goes to CFN is what's in `stack`, not the error message.\n    // if we have a remote trace, construct a nice message with log group information\n    if (jsonPayload.trace) {\n      // skip first trace line because it's the message\n      e.stack = [message, ...jsonPayload.trace.slice(1)].join('\\n');\n    }\n\n    throw e;\n  }\n\n  return jsonPayload;\n}\n\nfunction parseJsonPayload(payload: any): any {\n  if (!payload) { return { }; }\n  const text = payload.toString();\n  try {\n    return JSON.parse(text);\n  } catch (e) {\n    throw new Error(`return values from user-handlers must be JSON objects. got: \"${text}\"`);\n  }\n}\n\nfunction createResponseEvent(cfnRequest: AWSLambda.CloudFormationCustomResourceEvent, onEventResult: OnEventResponse): AWSCDKAsyncCustomResource.IsCompleteRequest {\n  //\n  // validate that onEventResult always includes a PhysicalResourceId\n\n  onEventResult = onEventResult || { };\n\n  // if physical ID is not returned, we have some defaults for you based\n  // on the request type.\n  const physicalResourceId = onEventResult.PhysicalResourceId || defaultPhysicalResourceId(cfnRequest);\n\n  // if we are in DELETE and physical ID was changed, it's an error.\n  if (cfnRequest.RequestType === 'Delete' && physicalResourceId !== cfnRequest.PhysicalResourceId) {\n    throw new Error(`DELETE: cannot change the physical resource ID from \"${cfnRequest.PhysicalResourceId}\" to \"${onEventResult.PhysicalResourceId}\" during deletion`);\n  }\n\n  // if we are in UPDATE and physical ID was changed, it's a replacement (just log)\n  if (cfnRequest.RequestType === 'Update' && physicalResourceId !== cfnRequest.PhysicalResourceId) {\n    log(`UPDATE: changing physical resource ID from \"${cfnRequest.PhysicalResourceId}\" to \"${onEventResult.PhysicalResourceId}\"`);\n  }\n\n  // merge request event and result event (result prevails).\n  return {\n    ...cfnRequest,\n    ...onEventResult,\n    PhysicalResourceId: physicalResourceId,\n  };\n}\n\n/**\n * Calculates the default physical resource ID based in case user handler did\n * not return a PhysicalResourceId.\n *\n * For \"CREATE\", it uses the RequestId.\n * For \"UPDATE\" and \"DELETE\" and returns the current PhysicalResourceId (the one provided in `event`).\n */\nfunction defaultPhysicalResourceId(req: AWSLambda.CloudFormationCustomResourceEvent): string {\n  switch (req.RequestType) {\n    case 'Create':\n      return req.RequestId;\n\n    case 'Update':\n    case 'Delete':\n      return req.PhysicalResourceId;\n\n    default:\n      throw new Error(`Invalid \"RequestType\" in request \"${JSON.stringify(req)}\"`);\n  }\n}\n"],
  "mappings": "aAGA,KAAA,aAAA,QAAA,gBAAA,EACA,OAAA,QAAA,UAAA,EACA,WAAA,QAAA,YAAA,EACA,OAAA,QAAA,QAAA,EAmBA,uBAAuB,WAAuD,CAC5E,OAAA,IAAI,iBAAkB,UAAU,EAEhC,WAAW,mBAAqB,WAAW,oBAAsB,CAAA,EAEjE,KAAM,eAAgB,KAAM,oBAAmB,OAAO,+BAAgC,UAAU,EAChG,OAAA,IAAI,oBAAqB,aAAa,EAItC,KAAM,eAAgB,oBAAoB,WAAY,aAAa,EAKnE,GAJA,OAAA,IAAI,SAAU,aAAa,EAIvB,CAAC,QAAQ,IAAI,OAAO,mCACtB,MAAO,aAAY,eAAe,UAAW,cAAe,CAAE,OAAQ,cAAc,MAAM,CAAE,EAI9F,KAAM,QAAS,CACb,gBAAiB,OAAA,OAAO,OAAO,4BAA4B,EAC3D,KAAM,cAAc,UACpB,MAAO,KAAK,UAAU,aAAa,GAGrC,OAAA,IAAI,kBAAmB,MAAM,EAG7B,KAAM,YAAA,eAAe,MAAM,CAC7B,CAGA,0BAA0B,MAAkD,CAC1E,OAAA,IAAI,aAAc,KAAK,EAEvB,KAAM,kBAAmB,KAAM,oBAAmB,OAAO,kCAAmC,KAAK,EAIjG,GAHA,OAAA,IAAI,4BAA6B,gBAAgB,EAG7C,CAAC,iBAAiB,WACpB,KAAI,kBAAiB,MAAQ,OAAO,KAAK,iBAAiB,IAAI,EAAE,OAAS,EACjE,GAAI,OAAM,kDAAkD,EAG9D,GAAI,aAAY,MAAM,KAAK,UAAU,KAAK,CAAC,EAGnD,KAAM,UAAW,IACZ,SACA,iBACH,KAAM,IACD,MAAM,QACN,iBAAiB,OAIxB,KAAM,aAAY,eAAe,UAAW,SAAU,CAAE,OAAQ,MAAM,MAAM,CAAE,CAChF,CAGA,yBAAyB,aAAiB,CACxC,OAAA,IAAI,iBAAkB,YAAY,EAElC,KAAM,mBAAoB,KAAK,MAAM,KAAK,MAAM,aAAa,KAAK,EAAE,YAAY,EAChF,KAAM,aAAY,eAAe,SAAU,kBAAmB,CAC5D,OAAQ,sBACT,CACH,CAEA,kCAAkC,eAAwB,QAAY,CACpE,KAAM,aAAc,OAAA,OAAO,cAAc,EACzC,OAAA,IAAI,2BAA2B,2BAA4B,OAAO,EAKlE,KAAM,MAAO,KAAM,YAAA,eAAe,CAChC,aAAc,YACd,QAAS,KAAK,UAAU,OAAO,EAChC,EAED,OAAA,IAAI,0BAA2B,KAAM,MAAO,KAAK,EAEjD,KAAM,aAAc,iBAAiB,KAAK,OAAO,EACjD,GAAI,KAAK,cAAe,CACtB,OAAA,IAAI,gCAAiC,KAAK,aAAa,EAEvD,KAAM,cAAe,YAAY,cAAgB,QAI3C,IAAM,YAAY,MAAM,GAAG,EAC3B,aAAe,IAAI,IAAI,OAAS,GAGhC,QAAU,CACd,aACA,GACA,qBAAqB,eACrB,IACA,KAAK;CAAI,EAEL,EAAI,GAAI,OAAM,OAAO,EAI3B,KAAI,aAAY,OAEd,GAAE,MAAQ,CAAC,QAAS,GAAG,YAAY,MAAM,MAAM,CAAC,CAAC,EAAE,KAAK;CAAI,GAGxD,EAGR,MAAO,YACT,CAEA,0BAA0B,QAAY,CACpC,GAAI,CAAC,QAAW,MAAO,CAAA,EACvB,KAAM,MAAO,QAAQ,SAAQ,EAC7B,GAAI,CACF,MAAO,MAAK,MAAM,IAAI,OACtB,CACA,KAAM,IAAI,OAAM,gEAAgE,OAAO,EAE3F,CAEA,6BAA6B,WAAyD,cAA8B,CAIlH,cAAgB,eAAiB,CAAA,EAIjC,KAAM,oBAAqB,cAAc,oBAAsB,0BAA0B,UAAU,EAGnG,GAAI,WAAW,cAAgB,UAAY,qBAAuB,WAAW,mBAC3E,KAAM,IAAI,OAAM,wDAAwD,WAAW,2BAA2B,cAAc,qCAAqC,EAInK,MAAI,YAAW,cAAgB,UAAY,qBAAuB,WAAW,oBAC3E,OAAA,IAAI,+CAA+C,WAAW,2BAA2B,cAAc,qBAAqB,EAIvH,IACF,cACA,cACH,mBAAoB,mBAExB,CASA,mCAAmC,IAAgD,CACjF,OAAQ,IAAI,iBACL,SACH,MAAO,KAAI,cAER,aACA,SACH,MAAO,KAAI,2BAGX,KAAM,IAAI,OAAM,qCAAqC,KAAK,UAAU,GAAG,IAAI,EAEjF,CA/LA,OAAA,QAAS,EACN,OAAO,iCAAkC,YAAY,YAAY,OAAO,GACxE,OAAO,oCAAqC,YAAY,YAAY,UAAU,GAC9E,OAAO,mCAAoC",
  "names": []
}
